\input texinfo   @c -*-texinfo-*-
@c
@c $Id: ede.texi,v 1.30 2010/07/25 14:12:32 zappo Exp $
@c
@setfilename ede.info
@settitle Emacs Development Environment

@ifinfo
@format
START-INFO-DIR-ENTRY
* ede: (ede).       Project management for Emacs
END-INFO-DIR-ENTRY
@end format
@end ifinfo

@titlepage
@sp 10
@center @titlefont{ede}
@vskip 0pt plus 1 fill
Copyright @copyright{} 1998, 1999, 2000, 2001, 2004, 2005, 2008, 2009, 2010 Eric M. Ludlam
@end titlepage

@macro cedet{}
@i{CEDET}
@end macro

@macro semantic{}
@i{semantic}
@end macro

@macro srecode{}
@i{SRecode}
@end macro

@macro eieio{}
@i{EIEIO}
@end macro

@macro ede{}
@i{EDE}
@end macro

@macro cogre{}
@i{COGRE}
@end macro

@macro speedbar{}
@i{Speedbar}
@end macro

@contents

@node top, EDE Project Concepts, (dir), (dir)
@comment  node-name,  next,  previous,  up

@ede{} is a collection of definitions called the 
@emph{Emacs Development Extensions}.  @ede{} provides the gloss that
simplifies the learning curve for all the very useful functionality of
building and debugging under emacs.  In doing so it attempts to emulate
a typical IDE (Integrated Development Environment).  What this means is
that @ede{} can manage or create your makefiles and other building
environment duties so the developer can concentrate on code, and not
support files.  In doing so, it will be much easier for new programmers
to learn and adopt the GNU ways of doing things.
@refill

@menu
* EDE Project Concepts::        @ede{} Project Concepts
* EDE Mode::                    Turning on @ede{} mode.
* Creating a project::          Creating a project.
* Modifying your project::      Adding and removing files and targets.
* Building and Debugging::      Initiating a build or debug session.
* Miscellaneous commands::      Other project related commands.
* Project types::               There are different types of projects.
* Extending EDE::               Programming tips when extending.
* Project::                     
* Targets::                     
* Sourcecode::                  
* Compilers::                   
@end menu

@node EDE Project Concepts, EDE Mode, top, top
@chapter @ede{} Project Concepts

@ede{} is a generic interface for managing projects.  In other words,
there is one set of menus and keybindings specified by @ede{}, but there
are multiple ways a project can be expressed via a build system.

You can learn about multiple @ref{Project types}, or the specific
build or debug commands in other chapters.

In @ede{}, a project hierarchy matches a directory hierarchy.  There
would be a project root, and subprojects in different subdirectories.

Within each project, there can be multiple targets.  A target at the
simplest level is a named collection of files within a project.  There
are two important reasons for specifying a target.

@enumerate
@item
A collection of files to be added to a distribution.
@item
A collection of files that can be built into something else.
@end enumerate

If you intend to write code, and have it tarred up and distributed
under the GPL, all important files must be a part of some target so
that they will be added to the distribution file.

Targets that are lists of files that can be built into something else
will also be distributed, but the build process will also convert
those files into some specified built thing, such as a program or
compiled documentation.

Lastly, @ede{} provides a way for other tools to easily learn file
associations.  For example, a program might need to restrict some sort
of search to files in a single target, or need to discover the
location of documentation or interface files.  @ede{} can provide this
information.

@node EDE Mode, Creating a project, EDE Project Concepts, top
@chapter @ede{} Mode

@ede{} is implemented as a minor-mode, which augments other modes such as C
mode, and Texinfo mode.  You can turn @ede{} on for all buffers by running
the command @code{global-ede-mode}, or by putting this in your
@file{~/.emacs} file.

@example
(global-ede-mode t)
@end example

When @ede{} is active for a given buffer, the menu item ``Project''
appears.  This menu contains several high-level functions to make
working on a code set easier.  These items and keybindings never change
regardless of the type of project you are actually working on.

The @file{ede.el} file is a minimal set of loading routines.  When
different types of projects are encountered, source code for those
projects are loaded at that time.

@node Creating a project, Modifying your project, EDE Mode, top
@chapter Creating a project

@emph{Note:} It is not necessary to Create a project as described below to
use @ede{}.  Some kinds of projects are autodetected, such as projects
that use Automake, Emacs, or Linux.  See @xref{Simple projects}.

To create a new project that will also create Makefiles for you, first
load a file you would want in that project into a buffer.  If you have
a hierarchy of directories, choose a file in the topmost directory
first.  From this buffer, run @command{ede-new}.

@ede{} can support several types of projects.  When creating a new
project with the command @command{ede-new} you must choose the type of
project you would like to create.  @xref{Project types}.

Each type has its own benefits or language specific enhancements.  You
will be prompted for the type of project you would like to create.  The
simplest and most language agnostic project type is @emph{Make}.  A
derivation of this is the @samp{Automake} type.

Not all project types can be created in this way.  For example, there
are two ways to handle Automake based projects.  One is by making an
@emph{Automake} project with @command{ede-new}.  The other is to just write
some automake files which @ede{} will automatically detect, and put
you into a different Automake mode.  Any GNU project using Automake
will be detected in this way, and you can use @ede{} to modify those
Makefiles for you.

If you just want to use @ede{} to know about a project so that other
libraries, such as @semantic{}, can take advantage of some core @ede{}
APIs, then you can use some simpler projects.  See  @xref{Simple projects}.

@section Creating a subproject

A subproject is merely a project in a subdirectory of another project.
You can create a subproject by using the @command{ede-new} command (or
@samp{"Create Project"} from the menu) while a in a subdirectory below
an existing project.  This new project will be automatically added to
the parent project, and will be automatically loaded when the parent
is read.

When using a project command that involves a makefile, @ede{} uses
the top-most project's makefile as a starting place for the build.  How
the toplevel project handles subprojects in the build process is
dependent on that project's type.

@node Modifying your project, Building and Debugging, Creating a project, top
@chapter Modifying your project

Your project and targets are systems with lots of options.  Generic
features are listed here.  You will need to read sections on specific
project types for detailed information on the project you might be
using.

@menu
* Add/Remove target::           
* Add/Remove files::            
* Customize Features::          
* EDE Project Features::        
@end menu

@node Add/Remove target, Add/Remove files, Modifying your project, Modifying your project
@section Add/Remove target

A project with no targets isn't very useful, so you can use @ede{} to add
and remove targets from your project.

You can create a new target with the @command{ede-new-target} command
@kbd{C-c . t}.  If appropriate you will be given the option to add the
current buffer into the newly created target.

When creating a target, you will be given an option list of target
types.  Each target type will have its own build process and class of
files it will accept.

You can remove a target with the command @code{ede-delete-target}.

The add and remove commands are in the @samp{Project->Project Options}
menu.

@node Add/Remove files, Customize Features, Add/Remove target, Modifying your project
@section Add/Remove files

A target with no files isn't very useful, so you can use @ede{} to add
and remove files to targets.  Sometimes files can belong to multiple
targets, and that is OK.

You can add files into targets with the command @command{ede-add-file}
bound to @kbd{C-c . a}.   If there are no targets created that you
wish to use, you can type in @samp{new target} to create a new target
apropriate for the file you are adding.

You can remove files from a target with the @command{ede-remove-file}
bound to @kbd{C-c . d}.  If the file is in multiple targets, it will
query for every target it could be removed from.

When you are working in a project, if you load a new file into a
buffer that is not a part of an active target, @ede{} will automatically
remind you to add it to a target of your choosing.  If you do not wish
to add it to a target, you can choose @samp{none}.  You can customize
the behavior with the variable @command{ede-auto-add-method}.

@node Customize Features, EDE Project Features, Add/Remove files, Modifying your project
@section Customize Features

A project, and its targets, are objects using the @samp{EIEIO} object
system. @xref{(eieio)EIEIO}.  These objects have data fields containing
important information related to your work.

If the high-level functions aren't enough, you can tweak all
user-customizable fields at any time by running the command
@command{customize-project} or @command{customize-target}.  This will
load the current project or target into a @emph{customization buffer}
where you tweak individual slots.  This is usually necessary for
project modes that are very complex.

Some project modes do not have a project file, but directly read a
Makefile, or existing file.  Instead of letting you directly edit the
object, you can edit the file.  Use the command
@command{ede-edit-file-target} bound to @kbd{C-c . e}.

@node EDE Project Features,  , Customize Features, Modifying your project
@section EDE Project Features

This section details user facing features of an @ede{} @samp{Make} style
project.  The specified options may be the same as in a
@samp{Automake} project, but are not the same as in an direct Automake
project.

To modify any of the specific features mentioned here, you need to
customize the project or target with @command{customize-project} or
@command{customize-target}.

When you are customizing, you are directly manipulating slot values in
@eieio{} objects.  If you are interested in additional details, see
@ref{Extending EDE}

@menu
* Changing Compilers and Flags::  
* Configurations::              
@end menu

@node Changing Compilers and Flags, Configurations, EDE Project Features, EDE Project Features
@subsection Changing Compilers and Flags

Targets that build stuff need compilers.  To change compilers, you
need to customize the desired target.

In the @samp{[Make]} section, you can then choose a new compiler or
linker from the list.  If a linker you need is not available, you will
need to create a new one.  @ref{Compiler and Linker objects}.

If an existing compiler or linker is close, but you need to modify
some flag set such as adding an include path you will need to add a
configuration variable.

To start, you should create the basic setup, and construct a makefile
with @command{ede-proj-regenerate}.  Look in the @file{Makefile} to
see what commands are inserted.  Once you have determined the variable
you need to modify, you can add a configuration for it.
@ref{Configurations}.

@node Configurations,  , Changing Compilers and Flags, EDE Project Features
@subsection Configurations

Configurations specify different ways to build a project.  For
example, you may configure a project to be in ``debug'' mode, or
perhaps in ``release'' mode.

The project, and each target type all have a slot named
@code{configuration-variables}.  To add new variables to a
configuration find this slot in the custom buffer, and insert a new
configuration.  Name it either ``debug'' or ``release'', then insert
some number of name/value pairs to it.

You can have any number of valid configurations too.  To add a new
configuration, customize your project.  Work in the @samp{[Settings]}
block for ``configurations''.  Add a new named configuration here.

To switch between different active configurations, modify the
``configuration default'' slot.

@node Building and Debugging, Miscellaneous commands, Modifying your project, top
@chapter Building and Debugging

@ede{} assumes you are writing some sort of program, so it attempts to
facilitate this activity.  @ede{} will associate the current buffer with a
target.  The target then knows how to compile or debug the given source
file.

The following commands enable compilation and debugging.

@table @kbd
@item C-c . c
Compile the current target.
@item C-c . C
Compile the entire project.
@item c-c . D
Debug the current target.
@item ede-make-dist
Build a distribution file for your project.
@end table

These commands, plus project or target specific options are available
in the @samp{Project} menu.

@node Miscellaneous commands, Project types, Building and Debugging, top
@chapter Miscellaneous commands

@section Rescan

If you opt to go in and edit @ede{} project files directly, perhaps with
the @command{ede-edit-file-target}, you will need to have Emacs rescan
the project files to update the internal data structures.

Use @command{ede-rescan-toplevel} bound to @kbd{C-c . g} to refresh
your system.

@section EDE Find File

@ede{} can help you find files in your project.  Use
@command{ede-find-file} bound to @kbd{C-c . f}.  It will prompt you
for a name.  You can specify the name without a directory.  EDE will
try to find a file with that name somewhere in your project.

@ede{} can use external tools to help with file finding.  Configure
the variable @code{ede-locate-setup-options} to help EDE find external
tools.

@defvar ede-locate-setup-options
@anchor{ede-locate-setup-options}
List of locate objects to try out by default.
Listed in order of preference.  If the first item cannot be used in
a particular project, then the next one is tried.
It is always assumed that @dfn{ede-locate-base} is at end of the list.
@end defvar

@section Speedbar

@ede{} also supports the speedbar package.  While speedbar works great
against directories already, @ede{} provides a project display mode.
This lets you look at your source files as they are structured in your
project.  Thus, where many files may be clumped together in one
directory, the Project view will provide a hierarchical view of your
files as grouped by target.

You can activate speedbar in this mode with the command
@command{ede-speedbar}.  This is bound to @kbd{C-c . s}.

@node Project types, Extending EDE, Miscellaneous commands, top
@chapter Project types

There are currently three types of project modes.  One is
@samp{ede-project}, and shows up as @samp{Make} and @samp{Automake}
when creating new projects.

The other project type handles automake projects directly from the
automake files.  @ede{} cannot make new projects of this type, assuming
the user will do it themselves.  Use @samp{ede-project} in
@samp{Automake} mode to have @ede{} create @file{Makefile.am} file, and a
@file{configure.in} file.
@refill

The third project style are ``Simple'' projects.  If you already have
project infrastructure for building and debugging, you can instead
create a simple project that identifies a project root and can look up
files.  The simple project styles are useful for working with tools
that use @ede{} to look up files.

@menu
* Make and Automake projects::  Project types of @samp{ede-project}
* Automake direct projects::    Project interface on hand-written automake files.
* Simple projects::             Projects @ede{} doesn't manage.
@end menu

@node Make and Automake projects
@section Make and Automake projects

A project of @samp{ede-project} type creates a file called
@file{Project.ede} in every project directory.  This is used to track
your configuration information.  If you configure this project to be
in @samp{Makefile} mode, then this project will autogenerate a
@file{Makefile}.  If you configure it in @samp{Automake} mode a
@file{Makefile.am} file will be created.  The automake bootstrapping
routines will also import and maintain a configure.am script and a
host of other files required by Automake.

@node Automake direct projects
@section Automake direct projects

The project type that reads @file{Makefile.am} directly is derived
from the sources of the original @file{project-am.el} mode that was
distributed independently.  This mode eventually became @ede{}.  The
@samp{project-am} project will read existing automake files, but will
not generate them automatically, or create new ones.  As such, it is
useful as a browsing tool, or as maintenance in managing file lists.

@node Simple projects
@section Simple Projects

There can be a wide array of Simple projects.  The root for simple
projects is the class @code{ede-simple-project}.  This handles the
infrastructure of storing a .ede file if needed.

The class @code{ede-simple-project} is designed to be subclassed.
Then key @ede{} methods can be overridden to provide a quick wrapper
over any project.

A second project type is @code{ede-cpp-root}.  This project type is
designed to be created for a directory hierarchy full of C/C++ code.
It can be configured with minimal lisp knowledge to do header file
lookup for @semantic{}, improving code completion performance.

@menu
* Generic::             Detect generic Make, SCons or CMake projects
* Add Generic Support:: Support more build types with Generic projects
* ede-cpp-root::        This project marks the root of a C/C++ code project.
* ede-emacs::           A project for working with Emacs.
* ede-linux::           A project for working with Linux kernels.
* Custom Locate::       Customizing how to locate files in a simple project
@end menu

@node Generic
@subsection Generic Projects

The Generic project system provides a way for EDE to identify a
project based on the build system.  Simple aspects of how this project
builds or interacts with @semantic{} can be done via the Customize
interface.

For C++ projects, even if the build system is supported by Generic,
may want to use @ref{ede-cpp-root} which has addtional options for
C/C++.

Generic projects are new, and disabled by default to prevent possible
conflicts with other types of projects, to enable them, use
@code{ede-enable-generic-projects}.

@defun ede-enable-generic-projects
@anchor{ede-enable-generic-projects}
Enable generic project loaders.
@end defun

When a generic project identifies your code, you can use:

@example
M-x ede-customize-project
@end example

to create an customization buffer and edit any configuration items for
your project.  It will save the configuration in @file{EDEConfig.el}
at the root of your project.

Generic projects also support @ref{Building and Debugging} for the
different project types.

@node Add Generic Support
@subsection Add Generic Support for new build systems

The Generic EDE project type can support almost any kind of build
system.  To add support for a new build system using the Generic type
is pretty easy.  Here is an example for supporting SCons:

@example
;;; SCONS
(defclass ede-generic-scons-project (ede-generic-project)
  ((buildfile :initform "SConstruct")
   )
  "Generic Project for scons.")

(defmethod ede-generic-setup-configuration ((proj ede-generic-scons-project) config)
  "Setup a configuration for SCONS."
  (oset config build-command "scons")
  (oset config debug-command "gdb ")
  )
@end example

The first block of code creates a new class for the SCons project
type.  It inherits from @code{ede-generic-project}.  The only
configuration really needed is to specify the initial value for the
@code{buildfile} slot.  This is @file{SConstruct} for SCons, and is
@file{Makefile} for supporting Make.

The second thing to do is implement a method for your build system
that will setup the Configuration.  Each generic project gets a common
Configuration object which contains details on how to work with the
different kinds of Source code.  It also contains the build and debug
commands which should be setup here.  These are the defaults.  A user
of your generic project can customize the configuration and change
these values later.

Once the class is created, it needs to be registered.  If you wish to
permanently add this to ede-generic.el, then you would edit
@code{ede-enable-generic-projects}.  If you write support just for
you, you would add a line of code like this example from SCons.

@example
(ede-generic-new-autoloader "edeproject-scons" "SCons"
			    "SConstruct" 'ede-generic-scons-project)
@end example

Adding a generic autoloader tells EDE how to identify, and
automatically create your project.

@defun ede-generic-new-autoloader internal-name external-name projectfile class
@anchor{ede-generic-new-autoloader}
Add a new @var{EDE} Autoload instance for identifying a generic project.
@var{INTERNAL-NAME} is a long name that identifies thsi project type.
@var{EXTERNAL-NAME} is a shorter human readable name to describe the project.
@var{PROJECTFILE} is a file name that identifies a project of this type to @var{EDE}, such as 
a Makefile, or SConstruct file.
@var{CLASS} is the @var{EIEIO} class that is used to track this project.  It should subclass
the class @dfn{ede-generic-project} project.
@end defun

@node ede-cpp-root
@subsection ede-cpp-root

The @code{ede-cpp-root} project type will allow you to create a single
object with no save-file in your @file{.emacs} file.  It will allow
@ede{} to provide @semantic{} with the ability to find header files
quickly.

The @code{ede-cpp-root} class knows a few things about C++ projects,
such as the prevalence of "include" directories, and typical
file-layout stuff.  If this isn't sufficient, you can subclass
@code{ede-cpp-root-project} and add your own tweaks in just a few
lines.  See the end of this file for an example.

In the most basic case, add this to your @file{.emacs} file, modifying
appropriate bits as needed.

@example
(ede-cpp-root-project "SOMENAME" :file "/dir/to/some/file")
@end example

Replace @var{SOMENAME} with whatever name you want, and the filename
to an actual file at the root of your project.  It might be a
Makefile, a README file.  Whatever.  It doesn't matter.  It's just a
key to hang the rest of @ede{} off of.

The most likely reason to create this project, is to speed up
searching for includes files, or to simplify bootstrapping @semantic{}'s
ability to find files without much user interaction.  In conjunction
with @semantic{} completion, having a short include path is key.  You can
override the default include path and system include path like this:

@example
(ede-cpp-root-project "NAME" :file "FILENAME"
    :include-path '( "/include" "../include" "/c/include" )
    :system-include-path '( "/usr/include/c++/3.2.2/" )
    :spp-table '( ("MOOSE" . "")
                  ("CONST" . "const") ) )
@end example

 In this case each item in the include path list is searched.  If the
directory starts with "/", then that expands to the project root
directory.  If a directory does not start with "/", then it is
relative to the default-directory of the current buffer when the file
name is expanded.

 The include path only affects C/C++ header files.  Use the slot
@code{:header-match-regexp} to change it.

The @code{:system-include-path} allows you to specify full directory
names to include directories where system header files can be found.
These will be applied to files in this project only.

The @code{:spp-table} provides a list of project specific #define
style macros that are unique to this project, passed in to the
compiler on the command line, or are in special headers.
See the @code{semantic-lex-c-preprocessor-symbol-map} for more
on how to format this entry.

If there is a single file in your project, you can instead set the
@code{:spp-files} to a list of file names relative to the root of your
project.  Specifying this is like setting the variable
@code{semantic-lex-c-preprocessor-symbol-file} in semantic.

If you want to override the file-finding tool with your own
function you can do this:

@example
(ede-cpp-root-project "NAME" :file "FILENAME" :locate-fcn 'MYFCN)
@end example

Where @var{MYFCN} is a symbol for a function.  The locate function can
be used in place of @code{ede-expand-filename} so you can quickly
customize your custom target to use specialized local routines instead
of the default @ede{} routines.  The function symbol must take two
arguments: 

@table @var
@item NAME
The name of the file to find.
@item DIR
The directory root for this cpp-root project.
@end table


If the cpp-root project style is right for you, but you want a dynamic
loader, instead of hard-coding path name values in your @file{.emacs}, you
can do that too, but you will need to write some lisp code.

To do that, you need to add an entry to the
@code{ede-project-class-files} list, and also provide two functions to
teach @ede{} how to load your project pattern

It would look like this:

@example
(defun MY-FILE-FOR-DIR (&optional dir)
  "Return a full file name to the project file stored in DIR."
  <write your code here, or return nil>
  )

(defun MY-ROOT-FCN ()
  "Return the root fcn for `default-directory'"
  ;; You might be able to use `ede-cpp-root-project-root'
  ;; and not write this at all.
  )

(defun MY-LOAD (dir)
  "Load a project of type `cpp-root' for the directory DIR.
Return nil if there isn't one."
  ;; Use your preferred constructin method here.
  (ede-cpp-root-project "NAME" :file (expand-file-name "FILE" dir)
                               :locate-fcn 'MYFCN)
  )

(add-to-list 'ede-project-class-files
             (ede-project-autoload "cpp-root"
              :name "CPP ROOT"
              :file 'ede-cpp-root
              :proj-file 'MY-FILE-FOR-DIR
              :proj-root 'MY-ROOT-FCN
              :load-type 'MY-LOAD
              :class-sym 'ede-cpp-root)
             t)
@end example

This example only creates an auto-loader, and does not create a new kind
of project.

@node ede-emacs
@subsection ede-emacs

The @code{ede-emacs} project will automatically identify an Emacs
source tree, and enable EDE project mode for it.

It pre-populates the C Preprocessor symbol map for correct parsing,
and has an optimized include file identification function.

@node ede-linux
@subsection ede-linux

The @code{ede-linux} project will automatically identify a Linux
Kernel source tree, and enable EDE project mode for it.

It pre-populates the C Preprocessor symbol map for reasonable parsing,
and has an optimized include file identification function.

@node Custom Locate
@subsection Custom Locate

The various simple project styles all have one major drawback, which
is that the files in the project are not completely known to EDE.
When the EDE API is used to try and file files by some reference name
in the project, then that could fail.

@@TODO - Add ID Utils and CScope examples

@ede{} can therefore use some external locate commands, such as the unix
``locate'' command, or ``GNU Global''.

Configuration of the tool you want to use such as @code{locate}, or
@code{global} will need to be done without the aid of @ede{}.  Once
configured, however, @ede{} can use it.

To enable one of these tools, set the variable
@code{ede-locate-setup-options} with the names of different locate
objects.  @ref{Miscellaneous commands}.

Configure this in your @file{.emacs} before loading in CEDET or EDE.
If you want to add support for GNU Global, your configuration would
look like this:

@example
(setq ede-locate-setup-options '(ede-locate-global ede-locate-base))
@end example

That way, when a search needs to be done, it will first try using
GLOBAL.  If global is not available for that directory, then it will
revert to the base locate object.  The base object always fails to
find a file.

You can add your own locate tool but subclassing from
@code{ede-locate-base}.  The subclass should also implement two
methods.  See the code in @file{ede-locate.el} for GNU Global as a
simple example.

@node Extending EDE, Project, Project types, top
@chapter Extending @ede{}

This chapter is intended for users who want to write new parts or fix
bugs in @ede{}.  A knowledge of Emacs Lisp, and some @eieio{}(CLOS) is
required.

If you are in this chapter because you need to enhance or fix @ede{},
here are some suggestions:

@table @asis
@item @ede{} doesn't recognize your project
In this case, you will need to read @ref{Detecting a Project}.  If you
think one of the existing project types should work, then you will
need to understand the detection process, then investigate the project
code to see what may be wrong.
@item @ede{} doesn't support your project
In this case, you will need to read all the sections, though you can
skip those sections specific to the secions on sourcecode and
compiler/linker objects which are specific to the project type that
autogenerates Makefiles.
@item @ede{} doesn't support your compiler/linker
For the @ede{} project types that build makefiles, you will want to
read the @ref{Compiler and Linker objects} section.
@item @ede{} doesn't support your language
For the @ede{} project types that build makefiles, you will need to
read the section on the @code{ede-proj-project}, which is a project
type that will accept new types of languages, and build Makefiles that
support that language.
@end table


@menu
* Development Overview::        Overview for developers
* Detecting a Project::         How EDE identifies projects
* User interface methods::      Methods associated with keybindings
* Base project methods::        The most basic methods on @ede{} objects.
* EDE proj-project::            Extending Makefile generating project types.
* Sourcecode objects::          Defining new sourcecode classes.
* Compiler and Linker objects::  Defining new compilers and linkers.
@end menu

@node Development Overview
@section Development Overview

@ede{} is made up of a series of classes implemented with @eieio{}.
These classes define an interface that can be used to create different
types of projects. 

@ede{} defines two superclasses which are @code{ede-project} and
@code{ede-target}.  All commands in @ede{} are usually meant to
address the current project, or current target.

All specific projects in @ede{} derive subclasses of the @ede{} superclasses.
In this way, specific behaviors such as how a project is saved, or how a
target is compiled can be customized by a project author in detail.  @ede{}
communicates to these project objects via an API using methods.  The
commands you use in @ede{} mode are high-level functional wrappers over
these methods.  For details on different types of projects,
@ref{Project types}.  @ref{(eieio)Top}. For details on using @eieio{} to
extending classes, and writing methods.

Some example project types are:

@table @code
@item project-am
Autmake project which reads existing Automake files.
@item ede-proj-project
This project type will create @file{Makefiles},
or @file{Makefile.am} files to compile your project.
@item ede-linux
This project type will detect linux source trees.
@item ede-emacs
This proejct will detect an Emacs source tree.
@end table

There are several other project types as well.

The first class you need to know to create a new project type is
@code{ede-project-autoload}.  New instances of this class are needed
to define how Emacs associates different files/buffers with different
project types.  All the autoloads are kept in the variable
@code{ede-project-class-files}.

The next most important class to know is @code{ede-project}.  This is
the baseclass defines how all projects behave.  The basic pattern for
a project is that there is one project per directory, and the topmost
project or directory defines the project as a whole.

Key features of @code{ede-project} are things like name and version
number.  It also holds a list of @code{ede-target} objects and a list
of sub projects, or more @code{ede-project} objects.

New project types must subclass @code{ede-project} to add special
behavior. New project types also need to subclass @code{ede-target} to
add specialty behavior.

In this way, the common @ede{} interface is designed to work against
@code{ede-project}, and thus all subclasses.

@code{ede-project} subclasses @code{ede-project-placeholder}.  This is
the minimum necessary project needed to be cached between runs of
Emacs.  This way, Emacs can track all projects ever seen, without
loading those projects into memory.

Here is a high-level UML diagram for the @ede{} system created with @cogre{}..

@example
+-----------------------+        +-----------------------+
|                       |        |ede-project-placeholder|
|ede-project-class-files|        +-----------------------+
|                       |        +-----------------------+
+-----------------------+        +-----------------------+
           /\                                ^ 
           \/                               /_\
            |                                |
 +--------------------+                +-----------+         +----------+
 |ede-project-autoload|                |ede-project|         |ede-target|
 +--------------------+<>--------------+-----------+<>-------+----------+
 +--------------------+                +-----------+         +----------+
 +--------------------+                +-----------+         +----------+
                                             ^ 
                                            /_\
                                             |
                       +---------------------+-----------------+
                       |                     |                 |
                       |                     |                 |
                       |                     |                 |
              +----------------+   +-------------------+  +---------+
              |ede-proj-project|   |project-am-makefile|  |ede-emacs|
              +----------------+   +-------------------+  +---------+
              +----------------+   +-------------------+  +---------+
              +----------------+   +-------------------+  +---------+
@end example


@node Detecting a Project
@section Detecting a Project

Project detection happens with the list of @code{ede-project-autoload}
instances stored in @code{ede-project-class-files}.  The full project
detection scheme works like this:

@table @asis
@item Step 1:
@code{find-file-hooks} calls @code{ede-turn-on-hook} on BUFFER.
@item Step 2:
@code{ede-turn-on-hook} turns on @code{ede-minor-mode}
@item Step 3:
@code{ede-minor-mode} looks to see if BUFFER is assicated with any
open projects.  If not, it calls @code{ede-load-project-file} to find
a project associated with the current directory BUFFER is in.
@item Step 4:
@code{ede-minor-mode} associates the found project with the current
buffer with a series of variables, such as @code{ede-object}, and
@code{ede-object-project} and @code{ede-object-root-project}.
@end table

Once a buffer is associated, @ede{} minor mode commands will operate
on that buffer.

The function @code{ede-load-project-file} is at the heart of detecting
projects, and it works by looping over all the known project autoload
types in @code{ede-project-autoload} using the utility
@code{ede-directory-project-p}.

The function @code{ede-directory-project-p} will call
@code{ede-dir-to-projectfile} on every @code{ede-project-autoload}
until one of them returns true.  The method
@code{ede-dir-to-projectfile} in turn gets the @code{:proj-file} slot
from the autoload.  If it is a string (ie, a project file name), it
checks to see if that exists in BUFFER's directory.  If it is a
function, then it calls that function and expects it to return a file
name or nil.  If the file exists, then this directory is assumed to be
part of a project, and @code{ede-directory-project-p} returns the
instance of @code{ede-project-autoload} that matched.

If the current directory contains the file @code{.ede-ignore} then
that directory is automatically assumed to contain no projects, even
if there is a matching pattern.  Use this type of file in a directory
that may contain many other sub projects, but still has a Makefile of
some sort.

If the current directory is a project, then @ede{} scans upwards till
it finds the top of the project.  It does this by calling
@code{ede-toplevel-project}.  If this hasn't already been discovered,
the directories as scanned upward one at a time until a directory with
no project is found.  The last found project becomes the project
root.  If the ofund instance of @code{ede-project-autoload} has a
valid @code{proj-root} slot value, then that function is called instead
of scanning the project by hand.  Some project types have a short-cut
for determining the root of a project, so this comes in handy.

Getting back to @code{ede-load-project-file}, this now has an instance
of @code{ede-project-autoload}.  It uses the @code{load-type} slot to
both autoload in the project type, and to create a new instance of the
project type found for the root of the project.  That project is added
to the global list of all projects.  All subprojects are then created
and assembled into the project data structures.


@node User interface methods
@section User interface methods

These methods are core behaviors associated with user commands.
If you do not implement a method, there is a reasonable default that
may do what you need.

@table @code
@item project-add-file
Add a file to your project.  Override this if you want to put new
sources into different fields depending on extension, or other details.
@item project-remove-file
Reverse of project-add-file.
@item project-compile-target
Override this if you want to do something special when the user
"compiles" this target.
@item project-debug-target
What to do when a user wants to debug your target.
@item project-update-version
Easily update the version number of your project.
@item project-edit-file-target
Edit the file the project's information is stored in.
@item project-new-target
Create a new target in a project.
@item project-delete-target
Delete a target from a project.
@item project-make-dist
Make a distribution (tar archive) of the project.
@item project-rescan
Rescan a project file, changing the data in the existing objects.
@end table

@node Base project methods
@section Base project methods

These methods are important for querying base information from project
and target types:

@table @code
@item ede-name
Return a string that is the name of this target.
@item ede-target-name
Return a string that is the name of the target used by a Make system.
@item ede-description
A brief description of the project or target.  This is currently used
by the @samp{ede-speedbar} interface.
@item ede-want-file-p
Return non-nil if a target will accept a given file.
It is generally unecessary to override this.  See the section on source
code.
@item ede-buffer-mine
Return non-nil if a buffer belongs to this target.  Used during
association when a file is loaded.  It is generally unecessary to
override this unless you keep auxiliary files.
@end table

These methods are used by the semantic package extensions @xref{(semantic)Top}.

@table @code
@item ede-buffer-header-file
Return a header file belonging to a given buffer.  Prototypes are place
there when appropriate
@item ede-buffer-documentation-files
Return the documentation file information about this file would be
stored in.
@item ede-documentation
List all documentation a project or target is responsible for.
@end table

@node EDE proj-project
@section EDE proj-project

The @ede{} proj-project is a project type that will build Makefiles.
This project type stores data in a @file{Project.ede}, and implements
new user commands for building a Makefile.

This project type can be extended through the use of new Targets,
@ref{Sourcecode objects}, or @ref{Compiler and Linker objects}.

This project type could also be extended to support alternate forms of
build systems, though no documentation has been setup for this.

TODO - write more for this.  See cedet-devel mailing list for help here.


@node Sourcecode objects
@section Sourcecode objects

@ede{} projects track source file / target associates via source code
objects.  The definitions for this is in @file{ede-source.el}.  A source
code object contains methods that know how to identify a file as being
of that class, (ie, a C file ends with @file{.c}).  Some targets can
handle many different types of sources which must all be compiled
together.  For example, a mixed C and C++ program would have
instantiations of both sourcecode types.

When a target needs to know if it will accept a source file, it
references its list of source code objects.  These objects then make
that decision.

Source code objects are stored in the target objects as a list of
symbols, where the symbol's value is the object.  This enables the
project save file mechanism to work.

Here is an example for an instantiation of an Emacs Lisp source code object:

@example
(defvar ede-source-emacs
  (ede-sourcecode "ede-emacs-source"
                  :name "Emacs Lisp"
                  :sourcepattern "\\.el$"
                  :garbagepattern '("*.elc"))
  "Emacs Lisp source code definition.")
@end example

If you want to recycle parts of an existing sourcecode object, you can
clone the original, and then just tweak the parts that are different.
For example:

@example
(defvar ede-source-emacs-autoload
  (clone ede-source-emacs "ede-source-emacs-autoload"
         :name "Emacs Lisp Autoload"
         :sourcepattern "-loaddefs\\.el")
  "Emacs Lisp autoload source code.")
@end example

In this case, the garbage pattern is the same.

@xref{Sourcecode}.

@node Compiler and Linker objects
@section Compiler and Linker objects

In order for a target to create a @file{Makefile}, it must know how to
compile the sources into the program or desired data file, and
possibly link them together.

A compiler object instantiation is used to associate a given target
with a given source code type.  Some targets can handle many types of
sources, and thus has many compilers available to it.  Some targets
may have multiple compilers for a given type of source code.

@ede{} will examine the actual source files in a target, cross reference
that against the compiler list to come up with the final set of
compilers that will be inserted into the Makefile.

Compiler instantiations must also insert variables specifying the
compiler it plans to use, in addition to creating Automake settings for
@file{configure.in} when appropriate.

Compiler objects are stored in the target objects as a list of
symbols, where the symbols value is the object.  This enables the
project output mechanism to work more efficiently.

Targets will also have a special "compiler" slot which lets a user
explicitly choose the compiler they want to use.

Here is an example for texinfo:

@example
(defvar ede-makeinfo-compiler
  (ede-compiler
   "ede-makeinfo-compiler"
   :name "makeinfo"
   :variables '(("MAKEINFO" . "makeinfo"))
   :commands '("makeinfo -o $@ $<")
   :autoconf '(("AC_CHECK_PROG" . "MAKEINFO, makeinfo"))
   :sourcetype '(ede-makeinfo-source)
   )
  "Compile texinfo files into info files.")
@end example

@xref{Compilers}.

When creating compiler instantiations, it may be useful to @code{clone}
an existing compiler variable.  Cloning allows you to only modify
parts of the original, while keeping the rest of the same.
Modification of the original will result in the clone also being
changed for shared value slots.

The second important object is the linker class.  The linker is similar
to the compiler, except several compilers might be used to create some
object files, and only one linker is used to link those objects together.

See @file{ede-proj-obj.el} for examples of the combination.

@section Class hierarchies

@menu
* Project    :: The different project types.
* Targets    :: The different target types.
* Sourcecode :: Source Code management types.
* Compilers  :: Compiler management types.
@end menu

@defindex pj
@defindex tg
@defindex sc
@defindex cm

@node Project, Targets, Extending EDE, top
@chapter Project

@include ede-projects.texi

@node Targets, Sourcecode, Project, top
@chapter Targets

@include ede-targets.texi

@node Sourcecode, Compilers, Targets, top
@chapter Sourcecode

The source code type is an object designed to associated files with
targets.

@include ede-sourcecode.texi

@node Compilers,  , Sourcecode, top
@chapter Compilers

The compiler object is designed to associate source code with
compilers.  The target then references the compilers it can use.
When the makefile is created, this object type knows how to create
compile commands.

@include ede-compilers.texi

@bye
