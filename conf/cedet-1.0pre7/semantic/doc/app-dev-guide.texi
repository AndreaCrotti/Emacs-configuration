\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename semantic-appdev.info
@set TITLE  Semantic Application Development Manual
@set AUTHOR Eric M. Ludlam, David Ponce, and Richard Y. Kim
@settitle @value{TITLE}

@c *************************************************************************
@c @ Header
@c *************************************************************************

@c Merge all indexes into a single index for now.
@c We can always separate them later into two or more as needed.
@syncodeindex vr cp
@syncodeindex fn cp
@syncodeindex ky cp
@syncodeindex pg cp
@syncodeindex tp cp

@c @footnotestyle separate
@c @paragraphindent 2
@c @@smallbook
@c %**end of header

@copying
This manual documents Application Development with Semantic.

Copyright @copyright{} 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009 Eric M. Ludlam
Copyright @copyright{} 2001, 2002, 2003, 2004 David Ponce
Copyright @copyright{} 2002, 2003 Richard Y. Kim

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being list their titles, with the Front-Cover Texts
being list, and with the Back-Cover Texts being list.  A copy of the
license is included in the section entitled ``GNU Free Documentation
License''.
@end quotation
@end copying

@ifinfo
@dircategory Emacs
@direntry
* Semantic Application Writer's guide: (semantic-appdev).
@end direntry
@end ifinfo

@iftex
@finalout
@end iftex

@c @setchapternewpage odd
@c @setchapternewpage off

@ifinfo
This file documents Application Development with Semantic.
@emph{Infrastructure for parser based text analysis in Emacs}

Copyright @copyright{} 1999, 2000, 2001, 2002, 2003, 2004 @value{AUTHOR}
@end ifinfo

@titlepage
@sp 10
@title @value{TITLE}
@author by @value{AUTHOR}
@vskip 0pt plus 1 fill
Copyright @copyright{} 1999, 2000, 2001, 2002, 2003, 2004 @value{AUTHOR}
@page
@vskip 0pt plus 1 fill
@insertcopying
@end titlepage
@page

@c MACRO inclusion
@include semanticheader.texi


@c *************************************************************************
@c @ Document
@c *************************************************************************
@contents

@node top
@top @value{TITLE}

A @semantic{} application takes the semantic tags generated
by semantic parsers then provides useful services to the user.
For a list of such applications,
@inforef{top, the Semantic User's Guide , semantic-user}.

An application developer needs to know
@itemize @bullet
@item when to invoke the parser to generate or regenerate the tag lists.
@item how to access the tag lists.
@item how to access information about each tag.
@end itemize

This chapter describes @semantic{} functions and concepts an application
developer needs to know to perform all of the tasks just listed.

@menu
* Semantic Tags::               
* Searching Tag Tables::        Searching tag tables.
* Tags at Point::               Finding tags at point.
* Tag Decoration::              Decorating tags
* Tag Sorting::                 Reorganizing streams.
* Tag Completion::              Completing read functions.
* Override Methods::            Language dependent functions covering
                                conversion to text strings, language dependent
                                queries and local context information
* Parser Features::             Application available parser features.
* Semantic Database::           Persistent storage of tags.
* Idle Scheduling::             Scheduling jobs in idle time.
* Example Programs::            Simple programming examples.
* Current Context::             Local context analysis.
* Data Debugger::               Application Debugger
* GNU Free Documentation License::  
* Index::                       
@end menu

@node Semantic Tags
@chapter Semantic Tags

@include tags.texi

@node Searching Tag Tables
@chapter Searching Tag Tables

These functions take some key, and return information found in a tag
table.  Some will return one tag (the first matching item found.)
Others will return a list of all items matching a given criterion.
Most of these functions work regardless of a buffer being in memory or
not.

Any specialty search routine that claims to use a function that is an
overload method will need to execute in a buffer of the same mode as
the tags being searched.

If you are looking for a search across multiple files, see
@ref{Semantic Database}.

@menu
* Breadth Search::              Searching only one level of tags.
* Deep Search::                 Deep searches into types or argument lists.
* Specialty Search::            Specialty Searches.
* Custom Search::               Write custom search routines.
@end menu

@node Breadth Search
@section Breadth Search

Searching the breadth of a list of tags means that only one level of
the tags will be searched.  If one of the tags is a datatype with
additional members, those members are not searched.

@defun semantic-find-first-tag-by-name name &optional table
@anchor{semantic-find-first-tag-by-name}
Find the first tag with @var{NAME} in @var{TABLE}.
@var{NAME} is a string.
@var{TABLE} is a semantic tags table.  See @dfn{semantic-something-to-tag-table}.
This routine uses @dfn{assoc} to quickly find the first matching entry.
@end defun

@defun semantic-find-tags-by-name name &optional table
@anchor{semantic-find-tags-by-name}
Find all tags with @var{NAME} in @var{TABLE}.
@var{NAME} is a string.
@var{TABLE} is a tag table.  See @dfn{semantic-something-to-tag-table}.
@end defun

@defun semantic-find-tags-for-completion prefix &optional table
@anchor{semantic-find-tags-for-completion}
Find all tags whos name begins with @var{PREFIX} in @var{TABLE}.
@var{PREFIX} is a string.
@var{TABLE} is a tag table.  See @dfn{semantic-something-to-tag-table}.
While it would be nice to use @dfn{try-completion} or @dfn{all-completions},
those functions do not return the tags, only a string.
Uses @dfn{compare-strings} for fast comparison.
@end defun

@defun semantic-find-tags-by-name-regexp regexp &optional table
@anchor{semantic-find-tags-by-name-regexp}
Find all tags with name matching @var{REGEXP} in @var{TABLE}.
@var{REGEXP} is a string containing a regular expression,
@var{TABLE} is a tag table.  See @dfn{semantic-something-to-tag-table}.
Consider using @dfn{semantic-find-tags-for-completion} if you are
attempting to do completions.
@end defun

@defun semantic-find-tags-by-class class &optional table
@anchor{semantic-find-tags-by-class}
Find all tags of class @var{CLASS} in @var{TABLE}.
@var{CLASS} is a symbol representing the class of the token, such as
@code{'variable}, of 'function..
@var{TABLE} is a tag table.  See @dfn{semantic-something-to-tag-table}.
@end defun

@defun semantic-find-tags-by-type type &optional table
@anchor{semantic-find-tags-by-type}
Find all tags of with a type @var{TYPE} in @var{TABLE}.
@var{TYPE} is a string or tag representing a data type as defined in the
language the tags were parsed from, such as ``int'', or perhaps
a tag whose name is that of a struct or class.
@var{TABLE} is a tag table.  See @dfn{semantic-something-to-tag-table}.
@end defun

@defun semantic-find-tags-included &optional table
@anchor{semantic-find-tags-included}
Find all tags in @var{TABLE} that are of the @code{'include} class.
@var{TABLE} is a tag table.  See @dfn{semantic-something-to-tag-table}.
@end defun

@node Deep Search
@section Deep Search

@defun semantic-brute-find-first-tag-by-name name streamorbuffer &optional search-parts search-include
Find a tag @var{NAME} within @var{STREAMORBUFFER}.  @var{NAME} is a string.
If @var{SEARCH-PARTS} is non-@code{nil}, search children of tags.
If @var{SEARCH-INCLUDE} is non-@code{nil}, search include files.

Use @dfn{semantic-find-first-tag-by-name} instead.

@obsolete{semantic-find-nonterminal-by-name,semantic-brute-find-first-tag-by-name}
@end defun

@defun semantic-brute-find-tag-by-property property value streamorbuffer &optional search-parts search-includes
Find all tags with @var{PROPERTY} equal to @var{VALUE} in @var{STREAMORBUFFER}.
Optional argument @var{SEARCH-PARTS} and @var{SEARCH-INCLUDES} are passed to
@dfn{semantic-brute-find-tag-by-function}.

@obsolete{semantic-find-nonterminal-by-property,semantic-brute-find-tag-by-property}
@end defun

@defun semantic-brute-find-tag-by-attribute attr streamorbuffer &optional search-parts search-includes
Find all tags with a given @var{ATTR} in @var{STREAMORBUFFER}.
@var{ATTR} is a symbol key into the attributes list.
Optional argument @var{SEARCH-PARTS} and @var{SEARCH-INCLUDES} are passed to
@dfn{semantic-brute-find-tag-by-function}.

@obsolete{semantic-find-nonterminal-by-extra-spec,semantic-brute-find-tag-by-attribute}
@end defun

@defun semantic-brute-find-tag-by-attribute-value attr value streamorbuffer &optional search-parts search-includes
Find all tags with a given @var{ATTR} equal to @var{VALUE} in @var{STREAMORBUFFER}.
@var{ATTR} is a symbol key into the attributes list.
@var{VALUE} is the value that @var{ATTR} should match.
Optional argument @var{SEARCH-PARTS} and @var{SEARCH-INCLUDES} are passed to
@dfn{semantic-brute-find-tag-by-function}.

@obsolete{semantic-find-nonterminal-by-extra-spec-value,semantic-brute-find-tag-by-attribute-value}
@end defun

@defun semantic-brute-find-tag-by-position position streamorbuffer &optional nomedian
Find a token covering @var{POSITION} within @var{STREAMORBUFFER}.
@var{POSITION} is a number, or marker.  If @var{NOMEDIAN} is non-@code{nil}, don't do
the median calculation, and return nil.

@obsolete{semantic-find-nonterminal-by-position,semantic-brute-find-tag-by-position}
@end defun

@defun semantic-brute-find-innermost-tag-by-position position streamorbuffer &optional nomedian
Find a list of tags covering @var{POSITION} within @var{STREAMORBUFFER}.
@var{POSITION} is a number, or marker.  If @var{NOMEDIAN} is non-@code{nil}, don't do
the median calculation, and return nil.
This function will find the topmost item, and recurse until no more
details are available of findable.

@obsolete{semantic-find-innermost-nonterminal-by-position,semantic-brute-find-innermost-tag-by-position}
@end defun

@defun semantic-brute-find-tag-by-class class streamorbuffer &optional search-parts search-includes
Find all tags with a class @var{CLASS} within @var{STREAMORBUFFER}.
@var{CLASS} is a symbol representing the class of the tags to find.
See @dfn{semantic-tag-class}.
Optional argument @var{SEARCH-PARTS} and @var{SEARCH-INCLUDES} are passed to
@dfn{semantic-brute-find-tag-by-function}.

Use @code{semantic-find-tag-by-class} instead.

@obsolete{semantic-find-nonterminal-by-token,semantic-brute-find-tag-by-class}
@end defun

@defun semantic-brute-find-tag-standard streamorbuffer &optional search-parts search-includes
Find all tags in @var{STREAMORBUFFER} which define simple class types.
See @dfn{semantic-tag-class}.
Optional argument @var{SEARCH-PARTS} and @var{SEARCH-INCLUDES} are passed to
@dfn{semantic-brute-find-tag-by-function}.

@obsolete{semantic-find-nonterminal-standard,semantic-brute-find-tag-standard}
@end defun

@defun semantic-brute-find-tag-by-type type streamorbuffer &optional search-parts search-includes
Find all tags with type @var{TYPE} within @var{STREAMORBUFFER}.
@var{TYPE} is a string which is the name of the type of the tags returned.
See @dfn{semantic-tag-type}.
Optional argument @var{SEARCH-PARTS} and @var{SEARCH-INCLUDES} are passed to
@dfn{semantic-brute-find-tag-by-function}.

@obsolete{semantic-find-nonterminal-by-type,semantic-brute-find-tag-by-type}
@end defun

@defun semantic-brute-find-tag-by-function function streamorbuffer &optional search-parts search-includes
Find all tags for which FUNCTION's value is non-@code{nil} within @var{STREAMORBUFFER}.
@var{FUNCTION} must return non-@code{nil} if an element of @var{STREAM} will be included
in the new list.

If optional argument @var{SEARCH-PARTS} is non-@code{nil}, all sub-parts of tags
are searched.  The overloadable function @code{semantic-tag-componenets} is
used for the searching child lists.  If @var{SEARCH-PARTS} is the symbol
@code{'positiononly}, then only children that have positional information are
searched.

If @var{SEARCH-INCLUDES} is non-@code{nil}, then all include files are also
searched for matches.  This parameter hasn't be active for a while
and is obsolete.

@obsolete{semantic-find-nonterminal-by-function,semantic-brute-find-tag-by-function}
@end defun

@defun semantic-brute-find-first-tag-by-function function streamorbuffer &optional search-parts search-includes
Find the first tag which @var{FUNCTION} match within @var{STREAMORBUFFER}.
@var{FUNCTION} must return non-@code{nil} if an element of @var{STREAM} will be included
in the new list.

The following parameters were never implemented.

If optional argument @var{SEARCH-PARTS}, all sub-parts of tags are searched.
The overloadable function @dfn{semantic-tag-components} is used for
searching.
If @var{SEARCH-INCLUDES} is non-@code{nil}, then all include files are also
searched for matches.

@obsolete{semantic-find-nonterminal-by-function-first-match,semantic-brute-find-first-tag-by-function}
@end defun

@node Specialty Search
@section Specialty Search

There are some specialty searches needed by some semantic tools that
could prove useful.  These specialty searches often do not match
against some single attribute as most breadth searches do.

@defun semantic-find-tags-of-compound-type &optional table
@anchor{semantic-find-tags-of-compound-type}
Find all tags which are a compound type in @var{TABLE}.
Compound types are structures, or other data type which
is not of a primitive nature, such as int or double.
Used in completion.
@end defun

@defun semantic-find-tags-by-scope-protection scopeprotection parent &optional table
@anchor{semantic-find-tags-by-scope-protection}
Find all tags accessible by @var{SCOPEPROTECTION}.
@var{SCOPEPROTECTION} is a symbol which can be returned by the method
@dfn{semantic-tag-protection}.  @var{A} hard-coded order is used to determine a match.
@var{PARENT} is a tag representing the @var{PARENT} slot needed for
@dfn{semantic-tag-protection}.
@var{TABLE} is a list of tags (a subset of @var{PARENT} members) to scan.  If @var{TABLE} is @code{nil},
the type members of @var{PARENT} are used.
See @dfn{semantic-tag-protected-p} for details on which tags are returned.
@end defun

@defun semantic-find-tags-external-children-of-type type &optional table
@anchor{semantic-find-tags-external-children-of-type}
Find all tags in whose parent is @var{TYPE} in @var{TABLE}.
These tags are defined outside the scope of the original @var{TYPE} declaration.
@var{TABLE} is a tag table.  See @dfn{semantic-something-to-tag-table}.
@end defun

@defun semantic-find-tags-subclasses-of-type type &optional table
@anchor{semantic-find-tags-subclasses-of-type}
Find all tags of class type in whose parent is @var{TYPE} in @var{TABLE}.
These tags are defined outside the scope of the original @var{TYPE} declaration.
@var{TABLE} is a tag table.  See @dfn{semantic-something-to-tag-table}.
@end defun

@node Custom Search
@section Custom Search

The searching framework for semantic for tag tables has two basic
root methods.  One is a function and the other is a macro.  The
functional version is needed if some sort of macro conflict arises.
The macro version is useful because it eliminates a level of function
call, and is faster.

@defun semantic--find-tags-by-function predicate &optional table
@anchor{semantic--find-tags-by-function}
Find tags for which @var{PREDICATE} is non-@code{nil} in @var{TABLE}.
@var{PREDICATE} is a lambda expression which accepts on @var{TAG}.
@var{TABLE} is a semantic tags table.  See @dfn{semantic-something-to-tag-table}.
@end defun

@defun semantic--find-tags-by-macro form &optional table
@anchor{semantic--find-tags-by-macro}
Find tags for which @var{FORM} is non-@code{nil} in @var{TABLE}.
@var{TABLE} is a semantic tags table.  See @dfn{semantic-something-to-tag-table}.
@end defun

@c @defun semantic-recursive-find-nonterminal-by-name name buffer
@c Recursivly find the first occurance of @var{NAME}.
@c Start search with @var{BUFFER}.  Recurse through all dependencies till
@c found.  The return item is of the form (@var{BUFFER} @var{TOKEN})
@c where @var{BUFFER} is the buffer in which @var{TOKEN} (the token found
@c to match @var{NAME}) was found.
@c 
@c @var{THIS} ISN'T @var{USED} @var{IN} @var{SEMANTIC}.  @var{DELETE}
@c @var{ME} @var{SOON}.
@c @end defun

@node Tags at Point
@chapter Tags at Point

When you need to get the tag the cursor is on, there is a more
efficient mechanism than using
@code{semantic-brute-find-tag-by-position}.  This mechanism directly
queries the overlays the parsing step leaves in the buffer.  This
provides for very rapid retrieval of what function or variable the
cursor is currently in.
@refill

These functions query the current buffer's overlay system for tags.

@defun semantic-find-tag-by-overlay &optional positionormarker buffer
Find all tags covering @var{POSITIONORMARKER} by using overlays.
If @var{POSITIONORMARKER} is @code{nil}, use the current point.
Optional @var{BUFFER} is used if @var{POSITIONORMARKER} is a number, otherwise the current
buffer is used.  This finds all tags covering the specified position
by checking for all overlays covering the current spot.  They are then sorted
from largest to smallest via the start location.

@obsolete{semantic-find-nonterminal-by-overlay,semantic-find-tag-by-overlay}
@end defun

@defun semantic-find-tag-by-overlay-in-region start end &optional buffer
Find all tags which exist in whole or in part between @var{START} and @var{END}.
Uses overlays to determine position.
Optional @var{BUFFER} argument specifies the buffer to use.

@obsolete{semantic-find-nonterminal-by-overlay-in-region,semantic-find-tag-by-overlay-in-region}
@end defun

@defun semantic-find-tag-by-overlay-next &optional start buffer
Find the next tag after @var{START} in @var{BUFFER}.
If @var{START} is in an overlay, find the tag which starts next,
not the current tag.
@end defun

@defun semantic-find-tag-by-overlay-prev &optional start buffer
Find the next tag before @var{START} in @var{BUFFER}.
If @var{START} is in an overlay, find the tag which starts next,
not the current tag.
@end defun

@defun semantic-current-tag
Return the current tag in the current buffer.
If there are more than one in the same location, return the
smallest tag.  Return @code{nil} if there is no tag here.

@obsolete{semantic-current-nonterminal,semantic-current-tag}
@end defun

@defun semantic-current-tag-parent
Return the current tags parent in the current buffer.
@var{A} tag's parent would be a containing structure, such as a type
containing a field.  Return @code{nil} if there is no parent.

@obsolete{semantic-current-nonterminal-parent,semantic-current-tag-parent}
@end defun

@node Tag Decoration
@chapter Tag Decoration

Tags can be decorated in different ways.  One way a user can control
it is through @code{semantic-decoration-mode}.
@inforef{semantic-user,,Tag Decoration Mode}

Applications can use the same routines to decorate tags as well.

@menu
* Tag Highlighting::            Highlighting a tag
* Tag Visible Properties::      Invisible, intangible and read only
* Tag Secondary Overlays::      Decorating parts of a tag text
* Tag Folding::                 Visibly Folding up tags
@end menu

@node Tag Highlighting
@section Highlighting

@defun semantic-highlight-tag tag &optional face
@anchor{semantic-highlight-tag}
Specify that @var{tag} should be highlighted.
Optional @var{face} specifies the face to use.
@obsolete{semantic-highlight-token,semantic-highlight-tag}
@end defun

@defun semantic-unhighlight-tag tag
@anchor{semantic-unhighlight-tag}
Unhighlight @var{tag}, restoring its previous face.
@obsolete{semantic-unhighlight-token,semantic-unhighlight-tag}
@end defun

@defun semantic-momentary-highlight-tag tag &optional face
@anchor{semantic-momentary-highlight-tag}
Highlight @var{tag}, removing highlighting when the user hits a key.
Optional argument @var{face} is the face to use for highlighting.
If @var{face} is not specified, then @code{highlight} will be used.
@obsolete{semantic-momentary-highlight-token,semantic-momentary-highlight-tag}
@end defun

The highlighting routines do their work by changing the face property
of the tag overlay.  The raw routine is:

@defun semantic-set-tag-face tag face
@anchor{semantic-set-tag-face}
Specify that @var{tag} should use @var{face} for display.
@obsolete{semantic-set-token-face,semantic-set-tag-face}
@end defun

@node Tag Visible Properties
@section Changing a tag's visible properties

You can give a tag other properties as well, such as making it
invisible or intangible.  You can control how code is edited
programatically through these routines.

@defun semantic-set-tag-invisible tag &optional visible
@anchor{semantic-set-tag-invisible}
Enable the text in @var{tag} to be made invisible.
If @var{visible} is non-@code{nil}, make the text visible.
@obsolete{semantic-set-token-invisible,semantic-set-tag-invisible}
@end defun

@defun semantic-tag-invisible-p tag
@anchor{semantic-tag-invisible-p}
Return non-@code{nil} if @var{tag} is invisible.
@obsolete{semantic-token-invisible-p,semantic-tag-invisible-p}
@end defun

@defun semantic-set-tag-intangible tag &optional tangible
@anchor{semantic-set-tag-intangible}
Enable the text in @var{tag} to be made intangible.
If @var{tangible} is non-@code{nil}, make the text visible.
This function does not have meaning in XEmacs because it seems that
the extent 'intangible' property does not exist.
@obsolete{semantic-set-token-intangible,semantic-set-tag-intangible}
@end defun

@defun semantic-tag-intangible-p tag
@anchor{semantic-tag-intangible-p}
Return non-@code{nil} if @var{tag} is intangible.
This function does not have meaning in XEmacs because it seems that
the extent 'intangible' property does not exist.
@obsolete{semantic-token-intangible-p,semantic-tag-intangible-p}
@end defun

@defun semantic-set-tag-read-only tag &optional writable
@anchor{semantic-set-tag-read-only}
Enable the text in @var{tag} to be made read-only.
Optional argument @var{writable} should be non-@code{nil} to make the text writable
instead of read-only.
@obsolete{semantic-set-token-read-only,semantic-set-tag-read-only}
@end defun

@defun semantic-tag-read-only-p tag
@anchor{semantic-tag-read-only-p}
Return non-@code{nil} if the current @var{tag} is marked read only.
@obsolete{semantic-token-read-only-p,semantic-tag-read-only-p}
@end defun

@node Tag Secondary Overlays
@section Secondary Overlays

Each tag which is being visited in a buffer has one overlay.  This
overlay is used to track where the tag is while a user is editing, and
can also be used for fast tag identification, and some simple
decoration techniques.

A secondary overlay associates a new overlay object with a tag which
does not cover the entire body of a tag.  You can then put visible
features on that overlay to decorate portions of a tag.  This is how
tag boundaries are drawn.

@subsection Creation and Deletion

@defun semantic-tag-create-secondary-overlay tag &optional link-hook
@anchor{semantic-tag-create-secondary-overlay}
Create a secondary overlay for @var{tag}.
Returns an overlay.  The overlay is also saved in @var{tag}.
@var{link-hook} is a function called whenever @var{tag} is to be linked into
a buffer.  It should take @var{tag} and @var{overlay} as arguments.
The @var{link-hook} should be used to position and set properties on the
generated secondary overlay.
@end defun

@defun semantic-tag-delete-secondary-overlay tag overlay-or-property
@anchor{semantic-tag-delete-secondary-overlay}
Delete from @var{tag} the secondary overlay @var{overlay-or-property}.
If @var{overlay-or-property} is an overlay, delete that overlay.
If @var{overlay-or-property} is a symbol, find the overlay with that property.
@end defun

@subsection Queries

@defun semantic-tag-get-secondary-overlay tag property
@anchor{semantic-tag-get-secondary-overlay}
Return secondary overlays from @var{tag} with @var{property}.
@var{property} is a symbol and all overlays with that symbol are returned..
@end defun

@defun semantic-tag-secondary-overlays tag
@anchor{semantic-tag-secondary-overlays}
Return a list of secondary overlays active on @var{tag}.
@end defun

@subsection Linking and Unlinking

When a tag's file is put in a buffer, that tag is ``linked'' into the
buffer.  When the buffer is deleted, the tag is ``unlinked''.  This
process adds and removes the default overlay on the tag.  Secondary
overlays use @code{semantic-tag-add-hook} and
@code{semantic-tag-remove-hook} too apply link and unlink hooks.

This allows the secondary overlays to be automatically removed or
added by the secondary overlay system whenever a tag's file goes in or
out of a buffeor.

@node Tag Folding
@section Folding

Using secondary overlays, a set of tag folding routines are made
available.  These routines are similar to the tag visible properties.

@defun semantic-set-tag-folded tag &optional folded
@anchor{semantic-set-tag-folded}
Fold @var{tag}, such that only the first line of text is shown.
Optional argument @var{folded} should be non-@code{nil} to fold the tag.
@code{nil} implies the tag should be fully shown.
@end defun

@defun semantic-tag-folded-p tag
@anchor{semantic-tag-folded-p}
Non-@code{nil} if @var{tag} is currently folded.
@end defun

@node Tag Sorting
@chapter Tag Sorting

Sometimes it is important to reorganize a tag stream into a form that
is better for display to a user.  It is important to not use functions
with side effects that could effect the tag cache.

There are some existing utility functions which will reorganize the
tag list for you.

@defun semantic-unique-tag-table tags
@anchor{semantic-unique-tag-table}
Scan a list of @var{TAGS}, removing duplicates.
This must first sort the tags by position ascending.
@var{TAGS} are removed only if they are equivalent, as can happen when
multiple tag sources are scanned.
@end defun

@defun semantic-unique-tag-table-by-name tags
@anchor{semantic-unique-tag-table-by-name}
Scan a list of @var{TAGS}, removing duplicate names.
This must first sort the tags by name alphabetically ascending.
@end defun

@defun semantic-bucketize tags &optional parent filter
@anchor{semantic-bucketize}
Sort @var{tags} into a group of buckets based on tag class.
Unknown classes are placed in a Misc bucket.
Type bucket names are defined by either @code{semantic-symbol->name-assoc-list}.
If @var{parent} is specified, then @var{tags} belong to this @var{parent} in some way.
This will use @code{semantic-symbol->name-assoc-list-for-type-parts} to
generate bucket names.
Optional argument @var{filter} is a filter function to be applied to each bucket.
The filter function will take one argument, which is a list of tokens, and
may re-organize the list with side-effects.
@end defun

@defvar semantic-bucketize-tag-class
@anchor{semantic-bucketize-tag-class}
Function used to get a symbol describing the class of a tag.
This function must take one argument of a semantic tag.
It should return a symbol found in @code{semantic-symbol->name-assoc-list}
which @dfn{semantic-bucketize} uses to bin up tokens.
To create new bins for an application augment
@code{semantic-symbol->name-assoc-list}, and
@code{semantic-symbol->name-assoc-list-for-type-parts} in addition
to setting this variable (locally in your function).
@end defvar

@defun semantic-adopt-external-members tags
@anchor{semantic-adopt-external-members}
Rebuild @var{tags} so that externally defined members are regrouped.
Some languages such as @var{c}++ and @var{clos} permit the declaration of member
functions outside the definition of the class.  It is easier to study
the structure of a program when such methods are grouped together
more logically.

This function uses @dfn{semantic-tag-external-member-p} to
determine when a potential child is an externally defined member.

Note: Applications which use this function must account for token
types which do not have a position, but have children which *do*
have positions.

Applications should use @code{semantic-mark-external-member-function}
to modify all tags which are found as externally defined to some
type.  For example, changing the token type for generating extra
buckets with the bucket function.
@end defun

@defvar semantic-orphaned-member-metaparent-type
@anchor{semantic-orphaned-member-metaparent-type}
In @dfn{semantic-adopt-external-members}, the type of @code{'type} for metaparents.
A metaparent is a made-up type semantic token used to hold the child list
of orphaned members of a named type.
@end defvar

@defvar semantic-mark-external-member-function
@anchor{semantic-mark-external-member-function}
Function called when an externally defined orphan is found.
By default, the token is always marked with the @code{adopted} property.
This function should be locally bound by a program that needs
to add additional behaviors into the token list.
This function is called with two arguments.  The first is @var{token} which is
a shallow copy of the token to be modified.  The second is the @var{parent}
which is adopting @var{token}.  This function should return @var{token} (or a copy of it)
which is then integrated into the revised token list.
@end defvar

@node Tag Completion
@chapter Tag Completion

Often time, it is useful to ask the user for the name of some tag.
This can be as simple as just prompting for a name, but often time,
the semantics can be quite complex.  If two tags have the same name,
which do you choose?

Semantic provides a completion engine for prompting for tags by name,
and providing fancy ways to display completion lists that allow the
user to choose a tag if several have the same name.

To use a completion function in your interactive function, you can
augment the @dfn{interactive} command like this:

@example
(defun my-function (tag)
   "Do something to TAG."
   (interactive (list (my-completion-function "Tag: ")))
   ...)
@end example

@menu
* Tag Completion Convenience Functions::  Provided functions
* Custom Tag Completion Functions::  Build your own completion function
* Old Tag Completion::          Completion functions from older releases
@end menu

@node Tag Completion Convenience Functions
@section Tag Completion Convenience Functions

There are some pre written completion functions that can be used in your
programs.

@defun semantic-complete-read-tag-buffer-deep prompt &optional default-tag initial-input history
Ask for a tag by name from the current buffer.
Available tags are from the current buffer, at any level.
Completion options are presented in a traditional way, with highlighting
to resolve same-name collisions.
@var{PROMPT} is a string to prompt with.
@var{DEFAULT-TAG} is a semantic tag or string to use as the default value.
If @var{INITIAL-INPUT} is non-@code{nil}, insert it in the minibuffer initially.
@var{HISTORY} is a symbol representing a variable to story the history in.
@end defun

@defun semantic-complete-read-tag-project prompt &optional default-tag initial-input history
@anchor{semantic-complete-read-tag-project}
Ask for a tag by name from the current project.
Available tags are from the current project, at the top level.
Completion options are presented in a traditional way, with highlighting
to resolve same-name collisions.
@var{prompt} is a string to prompt with.
@var{default-tag} is a semantic tag or string to use as the default value.
If @var{initial-input} is non-@code{nil}, insert it in the minibuffer initially.
@var{history} is a symbol representing a variable to store the history in.
@end defun

@defun semantic-complete-read-tag-analyzer prompt &optional context history
@anchor{semantic-complete-read-tag-analyzer}
Ask for a tag by name based on the current context.
The function @dfn{semantic-analyze-current-context} is used to
calculate the context.  @dfn{semantic-analyze-possible-completions} is used 
to generate the list of possible completions.
@var{prompt} is the first part of the prompt.  Additional prompt
is added based on the contexts full prefix.
@var{context} is the semantic analyzer context to start with.
@var{history} is a symbol representing a variable to store the history in.
usually a default-tag and initial-input are available for completion
prompts.  these are calculated from the @var{context} variable passed in.
@end defun

@defun semantic-complete-inline-analyzer context
@anchor{semantic-complete-inline-analyzer}
Complete a symbol name by name based on the current context.
This is similar to @code{semantic-complete-read-tag-analyze}, except
that the completion interaction is in the buffer where the context
was calculated from.
@var{context} is the semantic analyzer context to start with.
See @code{semantic-complete-inline-tag-engine} for details on how
completion works.
@end defun

@node Custom Tag Completion Functions
@section Custom Tag Completion Functions

There aren't many built in completion functions, but there are many
parts that can be put together into custom completion functions.

A completion function is built up of three important parts.

@table @asis
@item Tag Collection
Something that selects tags, and provides some list of tags
available, such as all functions, or all classes named ``bob''.
@item Typing and selecting
The prompt where you can type in the name of a tag.
@item Displaying possible completion values
A mechanism for displaying completion lists.
@end table

There is one typing and selecting routine that can be used to create
your custom completion prompt.

@defun semantic-complete-read-tag-engine collector displayor prompt default-tag initial-input history
@anchor{semantic-complete-read-tag-engine}
Read a semantic tag, and return a tag for the selection.
Argument @var{collector} is an object which can be used to to calculate
a list of possible hits.  See @code{semantic-completion-collector-engine}
for details on @var{collector}.
Argumeng @var{displayor} is an object used to display a list of possible
completions for a given prefix.  See@code{semantic-completion-display-engine}
for details on @var{displayor}.
@var{prompt} is a string to prompt with.
@var{default-tag} is a semantic tag or string to use as the default value.
If @var{initial-input} is non-@code{nil}, insert it in the minibuffer initially.
@var{history} is a symbol representing a variable to story the history in.
@end defun

As you can see, this takes one @dfn{collector}, and one
@dfn{displayor}.  These are objects created for this prompt at
runtime.  The completion engine then uses to perform their tasks.

For example:

@example
(defun semantic-complete-read-tag-buffer-deep (prompt &optional
						      default-tag initial-input history)
  "Ask for a tag by name from the current buffer.
PROMPT is a string to prompt with.
DEFAULT-TAG is a semantic tag or string to use as the default value.
If INITIAL-INPUT is non-nil, insert it in the minibuffer initially.
HISTORY is a symbol representing a variable to story the history in."
  (semantic-complete-read-tag-engine
   (semantic-collector-buffer-deep prompt :buffer (current-buffer))
   (semantic-displayor-traditional-with-focus-highlight "simple")
   ;;(semantic-displayor-tooltip "simple")
   prompt
   default-tag
   initial-input
   history)
  )
@end example

@menu
* Tag Collectors::              
* Tag Displayors::              
@end menu

@node Tag Collectors
@subsection Tag Collectors

A tag collector is an object that inherits from
@dfn{semantic-collector-abstract}.  A new collector is needed for
each specialized type of prompt that draws from a different selection
of tags.

You can have a collector that satisfies multiple purposes using slots
filled in the initializer for that object.

Collectors inherit from some of the following:

@deffn Type semantic-collector-abstract
@anchor{semantic-collector-abstract}
Root class for completion engines.
The baseclass provides basic functionality for interacting with
a completion displayor object, and tracking the current progress
of a completion.
@end deffn

@deffn Type semantic-collector-buffer-abstract
@anchor{semantic-collector-buffer-abstract}
Root class for per-buffer completion engines.
These collectors track themselves on a per-buffer basis.
@end deffn

@deffn Type semantic-collector-project-abstract
@anchor{semantic-collector-project-abstract}
Root class for project wide completion engines.
Uses semanticdb for searching all tags in the current project.
@end deffn

Available instantiable classes are:

@deffn Type semantic-collector-buffer-deep
@anchor{semantic-collector-buffer-deep}
Completion engine for tags in the current buffer.
When searching for a tag, uses semantic  deep search functions.
Basics search only in the current buffer.
@end deffn

@deffn Type semantic-collector-project
@anchor{semantic-collector-project}
Completion engine for tags in a project.
@end deffn

@deffn Type semantic-collector-project-brutish
@anchor{semantic-collector-project-brutish}
Completion engine for tags in a project.
@end deffn

@deffn Type semantic-collector-analyze-completions
@anchor{semantic-collector-analyze-completions}
Completion engine that uses the context analyzer to provide options.
The only options available for completion are those which can be logically
inserted into the current context.
@end deffn

NOTE: Add sections for writing new collectors.

@c (eieiodoc-class semantic-collector-abstract "cc")

@c END OF COLLECTOR

@node Tag Displayors
@subsection Tag Displayors

When a user is interacting with the prompt, and requests completion,
those tags are drawn from the collector.  If the user asks for a list
of completion by hitting a complete key twice, then the list of
completions heeds to be displayed in some way.

Displayors can be used to manage the display of all tags currently
available, AND often needs to be used to @b{focus} one one particular
tag of many in a visible way.

All displayors inherit from the displayor baseclass that defines the
default behaviors:

@deffn Type semantic-displayor-abstract
@anchor{semantic-displayor-abstract}
Manages the display of some number of tags.
Provides the basics for a displayor, including interacting with
a collector, and tracking tables of completion to display.
@end deffn

@deffn Type semantic-displayor-focus-abstract
@anchor{semantic-displayor-focus-abstract}
A displayor which has the ability to focus in on one tag.
Focusing is a way of differentiationg between multiple tags
which have the same name.
@end deffn

Distinct implementations of displayors include:

@deffn Type semantic-displayor-traditional
@anchor{semantic-displayor-traditional}
Traditional display mechanism for a list of possible completions.
Completions are showin in a new buffer and listed with the ability
to click on the items to aid in completion.
@end deffn

@deffn Type semantic-displayor-traditional-with-focus-highlight
@anchor{semantic-displayor-traditional-with-focus-highlight}
A traditional displayor which can focus on a tag by showing it.
Same as @code{semantic-displayor-traditional}, but with selection between
multiple tags with the same name done by 'focusing' on the source
location of the different tags to differentiate them.

@end deffn

@deffn Type semantic-displayor-tooltip
@anchor{semantic-displayor-tooltip}
Display mechanism using tooltip for a list of possible completions.
@end deffn

NOTE: Add sections for writing new collectors.

@c (eieiodoc-class semantic-displayor-abstract "cd")

@c END OF DISPLAYOR


@node Old Tag Completion
@section Older Tag Completion functions

These are older completion functions.  They may still be useful.

@defun semantic-read-symbol prompt &optional default stream filter
@anchor{semantic-read-symbol}
Read a symbol name from the user for the current buffer.
@var{prompt} is the prompt to use.
Optional arguments:
@var{default} is the default choice.  If no default is given, one is read
from under point.
@var{stream} is the list of tokens to complete from.
@var{filter} is provides a filter on the types of things to complete.
@var{filter} must be a function to call on each element.
@end defun

@defun semantic-read-variable prompt &optional default stream
@anchor{semantic-read-variable}
Read a variable name from the user for the current buffer.
@var{prompt} is the prompt to use.
Optional arguments:
@var{default} is the default choice.  If no default is given, one is read
from under point.
@var{stream} is the list of tokens to complete from.
@end defun

@defun semantic-read-function prompt &optional default stream
@anchor{semantic-read-function}
Read a function name from the user for the current buffer.
@var{prompt} is the prompt to use.
Optional arguments:
@var{default} is the default choice.  If no default is given, one is read
from under point.
@var{stream} is the list of tags to complete from.
@end defun

@defun semantic-read-type prompt &optional default stream
@anchor{semantic-read-type}
Read a type name from the user for the current buffer.
@var{prompt} is the prompt to use.
Optional arguments:
@var{default} is the default choice.  If no default is given, one is read
from under point.
@var{stream} is the list of tags to complete from.
@end defun

@node Override Methods
@chapter Override Methods

@dfn{Override methods} provide generic behaviors, which a given
language can override.  For example, finding a dependency (required
file) file in Emacs lisp can be done with the @code{locate-library}
command (which overrides the default behavior.)  In C, a dependency
(include file) can be found by searching a generic search path which
can be passed in via a variable.

If you plan to use one of these functions from a buffer that is not
of the same major-mode as the original tag, you can use this form to
make sure the correct action takes place:

@defun semantic-with-mode-bindings mode &rest body
@anchor{semantic-with-mode-bindings}
Evaluate @var{BODY} with the local bindings of @var{MODE}.
The current mode bindings are saved, @var{BODY} is evaluated, and the saved
bindings are restored, even in case of an abnormal exit.
Value is what @var{BODY} returns.
@end defun

For more on override methods, @inforef{Semantic Overload Mechanism, , lang-support-guide}.

@menu
* Format Tag::                  Converting Tokens into text strings
* Tag Members::                 Tags in tags
* Tag Details::                 Arbitrary token detail fetching
* Tag File Reference::	        Files a tag references.
* Jump to a Tag::	        Go to a tag's location
* Making New Methods::          How to add your own methods for your own tool
@end menu

@node Format Tag
@section Format Tag

Any given tag consists of Meta information which is best viewed in
some textual form.  This could be as simple as the tag's name, or as
a prototype to be added to header file in C.  Not only are there
several default converters from a Tag into text, but there is also
some convenient variables that can be used with them.  Use these
variables to allow options on output forms when displaying tags in
your programs.

@defvar semantic-format-tag-functions
@anchor{semantic-format-tag-functions}
List of functions which convert a tag to text.
Each function must take the parameters @var{tag} &optional @var{parent} @var{color}.
@var{tag} is the tag to convert.
@var{parent} is a parent tag or name which refers to the structure
or class which contains @var{tag}.  @var{parent} is @var{not} a class which a @var{tag}
would claim as a parent.
@var{color} indicates that the generated text should be colored using
@code{font-lock}.
@end defvar

@defvar semantic-format-tag-custom-list
@anchor{semantic-format-tag-custom-list}
A List used by customizable variables to choose a tag to text function.
Use this variable in the @code{:type} field of a customizable variable.
@end defvar

Every tag to text conversion function must take the same parameters,
which are @var{TAG}, the tag to be converted, @var{PARENT}, the
containing parent (like a structure which contains a variable), and
@var{COLOR}, which is a flag specifying that color should be applied
to the returned string.

When creating, or using these strings, particularly with color, use
@dfn{concat} to build up larger strings instead of @dfn{format}.  This
will preserve text properties.

@defun semantic-format-tag-name tag &optional parent color
@anchor{semantic-format-tag-name}
Return the name string describing @var{tag}.
The name is the shortest possible representation.
Optional argument @var{parent} is the parent type if @var{tag} is a detail.
Optional argument @var{color} means highlight the prototype with font-lock colors.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@obsolete{semantic-name-nonterminal,semantic-format-tag-name}
@end defun

@defun semantic-format-tag-abbreviate tag &optional parent color
@anchor{semantic-format-tag-abbreviate}
Return an abbreviated string describing @var{tag}.
The abbreviation is to be short, with possible symbols indicating
the type of tag, or other information.
Optional argument @var{parent} is the parent type if @var{tag} is a detail.
Optional argument @var{color} means highlight the prototype with font-lock colors.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@obsolete{semantic-abbreviate-nonterminal,semantic-format-tag-abbreviate}
@end defun

@defun semantic-format-tag-summarize tag &optional parent color
@anchor{semantic-format-tag-summarize}
Summarize @var{tag} in a reasonable way.
Optional argument @var{parent} is the parent type if @var{tag} is a detail.
Optional argument @var{color} means highlight the prototype with font-lock colors.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@obsolete{semantic-summerize-nonterminal,semantic-format-tag-summarize}
@end defun

@defun semantic-format-tag-prototype tag &optional parent color
@anchor{semantic-format-tag-prototype}
Return a prototype for @var{tag}.
This function should be overloaded, though it need not be used.
This is because it can be used to create code by language independent
tools.
Optional argument @var{parent} is the parent type if @var{tag} is a detail.
Optional argument @var{color} means highlight the prototype with font-lock colors.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@obsolete{semantic-prototype-nonterminal,semantic-format-tag-prototype}
@end defun

@defun semantic-format-tag-concise-prototype tag &optional parent color
@anchor{semantic-format-tag-concise-prototype}
Return a concise prototype for @var{tag}.
Optional argument @var{parent} is the parent type if @var{tag} is a detail.
Optional argument @var{color} means highlight the prototype with font-lock colors.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@obsolete{semantic-concise-prototype-nonterminal,semantic-format-tag-concise-prototype}
@end defun

@defun semantic-format-tag-uml-abbreviate tag &optional parent color
@anchor{semantic-format-tag-uml-abbreviate}
Return a @var{uml} style abbreviation for @var{tag}.
Optional argument @var{parent} is the parent type if @var{tag} is a detail.
Optional argument @var{color} means highlight the prototype with font-lock colors.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@obsolete{semantic-uml-abbreviate-nonterminal,semantic-format-tag-uml-abbreviate}
@end defun

@defun semantic-format-tag-uml-prototype tag &optional parent color
@anchor{semantic-format-tag-uml-prototype}
Return a @var{uml} style prototype for @var{tag}.
Optional argument @var{parent} is the parent type if @var{tag} is a detail.
Optional argument @var{color} means highlight the prototype with font-lock colors.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@obsolete{semantic-uml-prototype-nonterminal,semantic-format-tag-uml-prototype}
@end defun

@defun semantic-format-tag-uml-concise-prototype tag &optional parent color
@anchor{semantic-format-tag-uml-concise-prototype}
Return a @var{uml} style concise prototype for @var{tag}.
Optional argument @var{parent} is the parent type if @var{tag} is a detail.
Optional argument @var{color} means highlight the prototype with font-lock colors.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@obsolete{semantic-uml-concise-prototype-nonterminal,semantic-format-tag-uml-concise-prototype}
@end defun

@defun semantic-format-tag-prin1 tag &optional parent color
@anchor{semantic-format-tag-prin1}
Convert @var{tag} to a string that is the print name for @var{tag}.
@var{parent} and @var{color} are ignored.
@obsolete{semantic-prin1-nonterminal,semantic-format-tag-prin1}
@end defun

An additional utility will return a string for just the data type of
a tag.  This function is used in the above routines as well.

@defun semantic-format-tag-type tag color
@anchor{semantic-format-tag-type}
Convert the data type of @var{tag} to a string usable in tag formatting.
It is presumed that @var{type} is a string or semantic tag.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun

@node Tag Members
@section Tag Members

Tags are often in a hierarchical form, meaning that a tag found in
the top-level list may itself contain additional members.

The following overridable functions can fetch those tags.

@defun semantic-tag-components tag
Return a list of components for @var{tag}.
A Component is a part of @var{tag} which itself may be a @var{tag}.
Examples include the elements of a structure in a 
tag of class `type, or the list of arguments to a
tag of class @code{'function}.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun

@defun semantic-tag-components-with-overlays tag
Return the list of top level components belonging to @var{tag}.
Children are any sub-tags which contain overlays.

Default behavior is to get @dfn{semantic-tag-components} in addition
to the components of an anonymous types (if applicable.)

Note for language authors:
  If a mode defines a language tag that has tags in it with overlays
you should still return them with this function.
Ignoring this step will prevent several features from working correctly.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun

Some languages can define parts of a tag outside the actual scope of
the parent tag.  You can fetch information about them with these
overload functions.


@defun semantic-tag-external-member-p parent tag
@anchor{semantic-tag-external-member-p}
Return non-@code{nil} if @var{parent} is the parent of @var{tag}.
@var{tag} is an external member of @var{parent} when it is somehow tagged
as having @var{parent} as its parent.
@var{parent} and @var{tag} must both be semantic tags.

The default behavior, if not overridden with
@code{tag-external-member-p} is to match @code{:parent} attribute in
the name of @var{tag}.

If this function is overridden, use
@code{semantic-tag-external-member-children-p-default} to also
include the default behavior, and merely extend your own.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@obsolete{semantic-nonterminal-external-member-p,semantic-tag-external-member-p}
@end defun

@defun semantic-tag-external-member-children tag &optional usedb
@anchor{semantic-tag-external-member-children}
Return the list of children which are not *in* @var{tag}.
If optional argument @var{usedb} is non-@code{nil}, then also search files in
the Semantic Database.  If @var{usedb} is a list of databases, search those
databases.

Children in this case are functions or types which are members of
@var{tag}, such as the parts of a type, but which are not defined inside
the class.  @var{c}++ and @var{clos} both permit methods of a class to be defined
outside the bounds of the class' definition.

The default behavior, if not overridden with
@code{tag-external-member-children} is to search using
@dfn{semantic-tag-external-member-p} in all top level definitions
with a parent of @var{tag}.

If this function is overridden, use
@dfn{semantic-tag-external-member-children-default} to also
include the default behavior, and merely extend your own.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@obsolete{semantic-nonterminal-external-member-children,semantic-tag-external-member-children}
@end defun

@node Tag Details
@section Tag Details

These functions help derive information about tags that may not
be obvious for non-traditional languages with their own token types.

@defun semantic-tag-protection tag &optional parent
@anchor{semantic-tag-protection}
Return protection information about @var{tag} with optional @var{parent}.
This function returns on of the following symbols:
   @code{nil}        - No special protection.  Language dependent.
   @code{'public}    - Anyone can access this @var{tag}.
   @code{'private}   - Only methods in the local scope can access @var{tag}.
   @code{'protected} - Like private for outside scopes, like public for child
                classes.
Some languages may choose to provide additional return symbols specific
to themselves.  Use of this function should allow for this.

The default behavior (if not overridden with @code{tag-protection}
is to return a symbol based on type modifiers.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
It makes the overload @dfn{semantic-nonterminal-protection} obsolete.
@obsolete{semantic-nonterminal-protection,semantic-tag-protection}
@end defun

@defun semantic-tag-protected-p tag protection &optional parent
@anchor{semantic-tag-protected-p}
Non-@code{nil} if @var{tag} is is protected.
@var{protection} is a symbol which can be returned by the method
@dfn{semantic-tag-protection}.
@var{parent} is the parent data type which contains @var{tag}.

For these PROTECTIONs, true is returned if @var{tag} is:
@table @asis
@item @code{nil}
  Always true
@item  private
  True if @code{nil}.
@item protected
  True if private or @code{nil}.
@item public
  True if private, protected, or @code{nil}.
@end table
@end defun

@defun semantic-tag-abstract-p tag &optional parent
@anchor{semantic-tag-abstract-p}
Return non @code{nil} if @var{tag} is abstract.
Optional @var{parent} is the parent tag of @var{tag}.
In @var{uml}, abstract methods and classes have special meaning and behavior
in how methods are overridden.  In @var{uml}, abstract methods are italicized.

The default behavior (if not overridden with @code{tag-abstract-p}
is to return true if @code{abstract} is in the type modifiers.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
It makes the overload @dfn{semantic-nonterminal-abstract} obsolete.
@obsolete{semantic-nonterminal-abstract,semantic-tag-abstract-p}
@end defun

@defun semantic-tag-leaf-p tag &optional parent
@anchor{semantic-tag-leaf-p}
Return non @code{nil} if @var{tag} is leaf.
Optional @var{parent} is the parent tag of @var{tag}.
In @var{uml}, leaf methods and classes have special meaning and behavior.

The default behavior (if not overridden with @code{tag-leaf-p}
is to return true if @code{leaf} is in the type modifiers.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
It makes the overload @dfn{semantic-nonterminal-leaf} obsolete.
@obsolete{semantic-tag-leaf,semantic-tag-leaf-p}
@end defun

@defun semantic-tag-static-p tag &optional parent
@anchor{semantic-tag-static-p}
Return non @code{nil} if @var{tag} is static.
Optional @var{parent} is the parent tag of @var{tag}.
In @var{uml}, static methods and attributes mean that they are allocated
in the parent class, and are not instance specific.
@var{uml} notation specifies that @var{static} entries are underlined.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@obsolete{semantic-tag-static,semantic-tag-static-p}
@end defun

@node Tag File Reference
@section Tag File Reference

Some tags refer to some other file.

For include files, these options help Semantic find those files:

@defvar semantic-dependency-system-include-path
@anchor{semantic-dependency-system-include-path}
Defines the system include path.
This should be set with either @dfn{defvar-mode-local}, or with
@dfn{semantic-add-system-include}.

When searching for a file associated with a name found in an tag of
class include, this path will be inspected for includes of type
@code{system}.  Some include tags are agnostic to this setting and will
check both the project and system directories.
@end defvar

@defun semantic-dependency-tag-file &optional tag
@anchor{semantic-dependency-tag-file}
Find the filename represented from @var{tag}.
Depends on @code{semantic-dependency-include-path} for searching.  Always searches
@code{.} first, then searches additional paths.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
It makes the overload @dfn{semantic-find-dependency} obsolete.
@obsolete{semantic-find-dependency,semantic-dependency-tag-file}
@end defun

In languages with prototypes, such as C/C++, you can try to find a
corresponding file where a prototype to some implementation lives.

@defun semantic-prototype-file buffer
@anchor{semantic-prototype-file}
Return a file in which prototypes belonging to @var{buffer} should be placed.
Default behavior (if not overridden) looks for a token specifying the
prototype file, or the existence of an @var{ede} variable indicating which
file prototypes belong in.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun

The semantic support for Texinfo lets you find references to functions
in doc you might be maintaining.

@defun semantic-texi-find-documentation name &optional type
@anchor{semantic-texi-find-documentation}
Find the function or variable @var{name} of @var{type} in the texinfo source.
@var{name} is a string representing some functional symbol.
@var{type} is a string, such as ``variable`` or ''Command'' used to find
the correct definition in case @var{name} qualifies as several things.
When this function exists, @var{point} is at the definition.
If the doc was not found, an error is thrown.
Note: @var{type} not yet implemented.
@end defun


@node Jump to a Tag
@section Jump to a Tag

Each tag has a file from which it came.  If a tag has been managed
properly, you can jump to it with this function:

@defun semantic-go-to-tag tag &optional parent
@anchor{semantic-go-to-tag}
Go to the location of @var{tag}.
@var{tag} may be a stripped element, in which case @var{parent} specifies a
parent tag that has position information.
Different behaviors are provided depending on the type of tag.
For example, dependencies (includes) will seek out the file that is
depended on (see @dfn{semantic-dependency-tag-file}.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
It makes the overload @dfn{semantic-find-nonterminal} obsolete.
@obsolete{semantic-find-nonterminal,semantic-go-to-tag}
@end defun

When extracting tags from a database via search routines, those tags,
by default, do not have the necessary information in them.  Be sure
that when the database results are stripped, you use options that
force that file information to be kept.

@node Making New Methods
@section Making New Methods

The infrastructure for creating overridable methods base on major mode
is handled by @file{mode-local.el} which is independent of @semantic{}.

To create your own application specific mode local function, you
should use @dfn{define-overloadable-function}.  This function creates
the framework needed for different mode-authors to customize your
applications.

Once a function has been defined as mode-local, you should use
@dfn{define-mode-local-override} to add a mode specific feature.

@defun define-overloadable-function name args docstring &rest body
@anchor{define-overload}
Define a new function, as with @dfn{defun} which can be overloaded.
@var{name} is the name of the function to create.
@var{args} are the arguments to the function.
@var{docstring} is a documentation string to describe the function.  The
docstring will automatically had details about its overload symbol
appended to the end.
@var{body} is code that would be run when there is no override defined.  The
default is to call the function @code{NAME-default} with the appropriate
arguments.

@var{body} can also include an override form that specifies which part of
@var{body} is specifically overridden.  This permits to specify common code
run for both default and overridden implementations.
An override form is one of:

  1. @code{(:override [OVERBODY])}
  2. @code{(:override-with-args OVERARGS [OVERBODY])}

@var{overbody} is the code that would be run when there is no override
defined.  The default is to call the function @code{NAME-default} with the
appropriate arguments deduced from @var{args}.
@var{overargs} is a list of arguments passed to the override and
@code{NAME-default} function, in place of those deduced from @var{args}.
@end defun

@defun define-mode-local-override name mode args docstring &rest body
@anchor{define-mode-local-override}
Define a mode specific override of the function overload @var{name}.
Has meaning only if @var{name} has been created with @dfn{define-overload}.
@var{mode} is the major mode this override is being defined for.
@var{args} are the function arguments, which should match those of the same
named function created with @dfn{define-overload}.
@var{docstring} is the documentation string.
@var{body} is the implementation of this function.
@obsolete{define-mode-overload-implementation,define-mode-local-override}
@end defun


You can also create variable values that are mode local.

@defun defvar-mode-local mode sym val &optional docstring
@anchor{defvar-mode-local}
Define @var{mode} local variable @var{sym} with value @var{val}.
@var{docstring} is optional.
@end defun

@defun defconst-mode-local mode sym val &optional docstring
@anchor{defconst-mode-local}
Define @var{mode} local constant @var{sym} with value @var{val}.
@var{docstring} is optional.
@end defun

Mode local variables are implemented as buffer local.  Special hooks
enable mode-local to set these variables for the mode specified.  To
set a value as in code, you can use a special setq form.

@defun setq-mode-local mode &rest args
@anchor{setq-mode-local}
Assign new values to variables local in @var{mode}.
@var{mode} must be a major mode symbol.
@var{args} is a list (@var{sym} @var{val} @var{sym} @var{val} @dots{}).
The symbols @var{sym} are variables; they are literal (not evaluated).
The values @var{val} are expressions; they are evaluated.
Set each @var{sym} to the value of its @var{val}, locally in buffers already in
@var{mode}, or in buffers switched to that mode.
Return the value of the last @var{val}.
@end defun

@node Parser Features
@chapter Parser Features

If you write a program that uses a tag table in a persistent
display or database, it is necessary to know when tag tables change so
that your displays can be updated.  This is especially important as
tags can be replaced, changed, or deleted, and the associated
overlays will then throw errors when you try to use them.  Complete
integration with tag changes can be achieved via several hooks.

If you write an application that frequenly accesses the tags tables,
it is important to make sure those tags are up to date, and to make
sure you application does not adversely effect all the other minor
modes that may be running.

The semantic parser has many features and hooks that applications can
use to provide a good user experience.

@menu
* Editing Buffers::             Let the parser know you are changing a buffer.
* Parser State::                Knowing if the tag table is out of date
* Parser Hooks::                Knowing when tags change
* Lexical Safety::              Preventing lexical errors from making a mess
@end menu

@node Editing Buffers
@section Editing Buffers

One interesting way to interact with the parser is to let it know that
changes you are going to make will not require re-parsing.

@defvar semantic-edits-are-safe
When non-@code{nil}, modifications do not require a reparse.
This prevents tokens from being marked dirty, and it
prevents top level edits from causing a cache check.
Use this when writing programs that could cause a full
reparse, but will not change the tag structure, such
as adding or updating top-level comments.
@end defvar

@node Parser State
@section Parser State

It is sometimes useful to know what the current parsing state
is.  These function can let you know what level of re-parsing may be
needed.  Careful choices on when to reparse can make your program much
faster.

@defun semantic-parse-tree-needs-update-p
@anchor{semantic-parse-tree-needs-update-p}
Return non-@code{nil} if the current parse tree needs to be updated.
@end defun

@defun semantic-parse-tree-needs-rebuild-p
@anchor{semantic-parse-tree-needs-rebuild-p}
Return non-@code{nil} if the current parse tree needs to be rebuilt.
@end defun

@defun semantic-parse-tree-unparseable-p
@anchor{semantic-parse-tree-unparseable-p}
Return non-@code{nil} if the current buffer has been marked unparseable.
@end defun

@defun semantic-parse-tree-up-to-date-p
@anchor{semantic-parse-tree-up-to-date-p}
Return non-@code{nil} if the current parse tree is up to date.
@end defun

@node Parser Hooks
@section Parser Hooks

If you just want to know when a buffer changes, use this hook.

@defvar semantic-after-toplevel-cache-change-hook
@anchor{semantic-after-toplevel-cache-change-hook}
Hooks run after the buffer tag list has changed.
This list will change when a buffer is reparsed, or when the tag list
in a buffer is cleared.  It is *@var{not}* called if the current tag list is
partially reparsed.

Hook functions must take one argument, which is the new list of tags
associated with this buffer.

For language specific hooks, make sure you define this as a local hook.
@end defvar

If you want tighter interaction with how the user is editing
different tags, you can use this hook instead.

@defvar semantic-after-partial-cache-change-hook
@anchor{semantic-after-partial-cache-change-hook}
Hooks run after the buffer cache has been updated.

This hook will run when the cache has been partially reparsed.
Partial reparses are incurred when a user edits a buffer, and only the
modified sections are rescanned.

Hook functions must take one argument, which is the list of tokens
updated in the current buffer.

For language specific hooks, make sure you define this as a local hook.
@end defvar

It is also useful to clean up any data your application is using when
semantic flushes its tags table.

@defvar semantic-before-toplevel-cache-flush-hook
@anchor{semantic-before-toplevel-cache-flush-hook}
Hooks run before the toplevel tag cache is flushed.
For language specific hooks, make sure you define this as a local
hook.  This hook is called before a corresponding
@code{semantic-after-toplevel-cache-change-hook} which is also called
during a flush when the cache is given a new value of @code{nil}.
@end defvar

@node Lexical Safety
@section Lexical Safety

If you application frequenly requests lists of tags upon user request,
it may be important to avoid lexical problems that frequenly occur
when the user has partially written an expression, such as starting a
string, or argument list.

You can protect your code from lexical problems with this macro:

@defun semantic-lex-catch-errors symbol &rest forms
@anchor{semantic-lex-catch-errors}
Using @var{SYMBOL}, execute @var{FORMS} catching lexical errors.
If @var{FORMS} results in a call to the parser that throws a lexical error,
the error will be caught here without the buffer's cache being thrown
out of date.
If there is an error, the syntax that failed is returned.
If there is no error, then the last value of @var{FORMS} is returned.
@end defun

It is important to provide a good @var{SYMBOL} so that these macros
can nest correctly.

If you want your code to run anyway, even if there is a lexical
error, using this macro like this:

@example
(semantic-lex-catch-errors
   (semantic-fetch-tags))
@end example

will put the parser into the 'unparseable' state, and allow other
routines to request the tag table without incurring additional parser
attempts.

@node Semantic Database
@chapter Semantic Database

Semanticdb is a database mechanism for storing tags parsed by
@semantic{}.  The database operates in the background, saving tags as
they are parsed between sessions.  When a file is read in, and there
is a previously created set of tags available for it, semanticdb will
save time by not parsing the file, and using the cached copy.

In applications, semanticdb can provide access to the sum of all tags
in a project or in the basic system.  This database can then be
searched using a set of special routines.

@menu
* Semanticdb in Programs::      Basic usage.
* Semanticdb Tag Queries::      Searching for tokens in the databases.
* System Databases::            Special kinds of databases for system tags.
* Semanticdb references::       Tables can refer to eachother.
@end menu

@node Semanticdb in Programs
@section Semanticdb in Programs::

If you write a program using semanticdb, you will probably want to
make sure it is active in your program.

@defun semanticdb-minor-mode-p
@anchor{semanticdb-minor-mode-p}
Return non-@code{nil} if @code{semanticdb-minor-mode} is active.
@end defun

Since semanticdb is optional, it is best if a program can gracefully
degrade service when semanticdb is not available, or to throw an
error letting the user know it is required to be active.

At the simplest level, you can ask if a given file is in the
database, receiving a tag table.  Semanticdb will give you an
accurate set of tags just by asking.

@defun semanticdb-file-stream file
@anchor{semanticdb-file-stream}
Return a list of tags belonging to @var{file}.
If file has database tags available in the database, return them.
If file does not have tags available, then load the file, and create them.
@end defun

Alternately, you can get the table object for a file by asking for it.

@defun semanticdb-file-table-object file &optional dontload
@anchor{semanticdb-file-table-object}
Return a semanticdb table belonging to @var{file}.
If file has database tags available in the database, return it.
If file does not have tags available, and @var{dontload} is @code{nil},
then load the tags for @var{file}, and create a new table object for it.
@var{dontload} does not affect the creation of new database objects.
@end defun

@node Semanticdb Tag Queries
@section Semanticdb Tag Queries

You can search for tags in the semantic database using the
semanticdb-find API.  It is important to note that database search
functions do not return a plain list of tags.  This is because some
tags may not be loaded in a buffer, which means that the found tag
would not have an overlay, and no way to determine where it came from.

As such, all search functions return a special Database Results list.

There are several types of searches, divided into groups by
implementation.  While it is possible to add new types of searches,
or write custom searches, the built in searches are usually the only
ones available in system backends @ref{System Databases}.

When the term @b{brute} or @b{brutish} is used as a search criteria,
that is distinguishing between an include-path based search, and a
search that scans everything available in a project.

Non-brute force searches assume that all symbols available in a given
buffer are on the search path, or in some file that has been
included, imported, or otherwise indicated in the source file
itself.  While not always true for interpreted languages (such as
Emacs Lisp), it is common among declaritive languages.

Sometimes a brute force approach is needed, scanning every file
available to the database.  You may want to do this if your
application is collecting data unrelated to a file currently being
worked on.

@menu
* DB Results::                  Accessing the results of a search.
* DB Search Paths::             The list of tables to search.
* DB Basic Name Search::        Searches based on name.
* DB Data Type Search::         Searches for datatypes.
* DB Basic Brute Search::       Searches on common tag attributes.
* DB Advanced Search::          Complex searches on associations
* DB Generic Search::           Do It Yourself search criteria
@end menu

@node DB Results
@subsection DB Results

The successful result of a search returns a special list of the
following form:

@example
   ( (DATABASE TAG1 TAG2 ...) (DATABASE2 TAG3 TAG4 ...) ...)
@end example

It should not be necessary to access the results in this way,
however, as there are several routines that can be used to access
this list.

To turn a semanticdb search result into a simple tag table, use:

@defun semanticdb-strip-find-results results &optional find-file-match
@anchor{semanticdb-strip-find-results}
Strip a semanticdb search @var{results} to exclude objects.
This makes it appear more like the results of a @code{semantic-find-} call.
Optional @var{find-file-match} loads all files associated with @var{results}
into buffers.  This has the side effect of enabling @dfn{semantic-tag-buffer} to
return a value.
If the input @var{results} are not going to be used again, and if @var{find-file-match} is @code{nil},
you can use @dfn{semanticdb-fast-strip-find-results} instead.
@end defun

@defun semanticdb-fast-strip-find-results results
@anchor{semanticdb-fast-strip-find-results}
Destructively strip a semanticdb search @var{results} to exclude objects.
This makes it appear more like the results of a @code{semantic-find-} call.
This is like @dfn{semanticdb-strip-find-results}, except the input list @var{results}
will be changed.
@end defun

To write a function that accepts a tag table, or a semanticdb search
result, use this to test if it is a semanticdb search result:

@defun semanticdb-find-results-p resultp
@anchor{semanticdb-find-results-p}
Non-@code{nil} if @var{resultp} is in the form of a semanticdb search result.
This query only really tests the first entry in the list that is @var{resultp},
but should be good enough for debugging assertions.
@end defun

@defun semanticdb-find-result-with-nil-p resultp
@anchor{semanticdb-find-result-with-nil-p}
Non-@code{nil} of @var{resultp} is in the form of a semanticdb search result.
@code{nil} is a valid value where a @var{table} usually is, but only if the @var{tag}
results include overlays.
This query only really tests the first entry in the list that is @var{resultp},
but should be good enough for debugging assertions.
@end defun

To operate on the search results as though it were a simple tags
table, or plain list, use these routines.

@defun semanticdb-find-result-length result
@anchor{semanticdb-find-result-length}
Number of tags found in @var{result}.
@end defun

@defun semanticdb-find-result-nth result n
@anchor{semanticdb-find-result-nth}
In @var{result}, return the Nth search result.
This is a @var{0} based search result, with the first match being element @var{0}.

The returned value is a cons cell: (@var{tag} . @var{table}) where @var{tag}
is the tag at the Nth position.  @var{table} is the semanticdb table where
the @var{tag} was found.  Sometimes @var{table} can be @code{nil}.
@end defun

@defun semanticdb-find-result-nth-in-buffer result n
@anchor{semanticdb-find-result-nth-in-buffer}
In @var{result}, return the Nth search result.
Like @dfn{semanticdb-find-result-nth}, except that only the @var{tag}
is returned, and the buffer it is found it will be made current.
If the result tag has no position information, the originating buffer
is still made current.
@end defun

@defun semanticdb-find-result-mapc fcn result
@anchor{semanticdb-find-result-mapc}
Apply @var{fcn} to each element of find @var{result} for side-effects only.
@var{fcn} takes two arguments.  The first is a @var{tag}, and the
second is a @var{db} from whence @var{tag} originated.
Returns result.
@end defun

@node DB Search Paths
@subsection DB Search Paths

For searches based on an include path (non-brutish) a path of tables
needs to be generated.  Searching a lot of tables is slow, which is
why a brutish search is not always recommended.  An include-based
approach can also generate a lot of tables, so you can control how
detailed a search is with a throttle variable.

Ideally, each language mode will have a mode-specific value for
this throttle value.  A user can also specify their own values if the
default is not good enough.

@defvar semanticdb-find-default-throttle
@anchor{semanticdb-find-default-throttle}
The default throttle for @code{semanticdb-find} routines.
The throttle controls how detailed the list of database
tables is for a symbol lookup.  The value is a list with
the following keys:

@table @code
@item file
The file the search is being performed from.  This option is here for
completeness only, and is assumed to always be on.
@item local
Tables from the same local directory are included.  This includes
files directly referenced by a file name which might be in a different
directory.
@item project
Tables from the same local project are included If @code{project} is
specified, then @code{local} is assumed.
@item unloaded
If a table is not in memory, load it.  If it is not cached on disk
either, get the source, parse it, and create the table.
@item system
Tables from system databases.  These are specifically tables
from system header files, or language equivalent.
@item recursive
For include based searches, includes tables referenced by included
files.
@item omniscience
Included system databases which are omniscience, or somehow know
everything.  Omniscience databases are found in
@code{semanticdb-project-system-databases}.  The Emacs Lisp system
@var{db} is an omniscience database.
@end table

@end defvar


You can use the command @code{semanticdb-find-test-translate-path} to
interactively test out how the path translator is working.  The path
translation routines are:

@defun semanticdb-find-translate-path path brutish
@anchor{semanticdb-find-translate-path}
Translate @var{path} into a list of semantic tables.
Path translation involves identifying the @var{path} input argument
in one of the following ways:
  @code{nil} - Take the current buffer, and use its include list
  buffer - Use that buffer's include list.
  filename - Use that file's include list.  If the file is not
      in a buffer, see of there is a semanticdb table for it.  If
      not, read that file into a buffer.
  tag - Get that tag's buffer of file file.  See above.
  table - Search that table, and its include list.
  find result - Search the results of a previous find.

In addition, once the base path is found, there is the possibility of
each added table adding yet more tables to the path, so this routine
can return a lengthy list.

If argument @var{brutish} is non-@code{nil}, then instead of using the include
list, use all tables found in the parent project of the table
identified by translating @var{path}.  Such searches use brute force to
scan every available table.

The return value is a list of objects of type @dfn{semanticdb-table} or
its children.  In the case of passing in a find result, the result
is returned unchanged.

This routine uses @dfn{semanticdb-find-table-for-include} to translate
specific include tags into a semanticdb table.

Note: When searching using a non-brutish method, the list of
included files will be cached between runs.  Database-references
are used to track which files need to have their include lists
refreshed when things change.  See @dfn{semanticdb-ref-test}.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun

@defun semanticdb-find-table-for-include includetag &optional table
@anchor{semanticdb-find-table-for-include}
For a single @var{includetag} found in @var{table}, find a @dfn{semanticdb-table} object
@var{includetag} is a semantic @var{tag} of class @code{'include}.
@var{table} as defined by @dfn{semantic-something-to-tag-table} to identify
where the tag came from.  @var{table} is optional if @var{includetag} has an
overlay of @code{:filename} attribute.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun


TODO : Make this next part show up somewhere better.


Each major mode should define their local include path with
@code{defcustom-mode-local-semantic-dependency-system-include-path}.
This macro builds a customizable variable that is kept in sync with
the mode-local variable, and any include decorations that are active.

@defun defcustom-mode-local-semantic-dependency-system-include-path mode name value &optional docstring
@anchor{defcustom-mode-local-semantic-dependency-system-include-path}
Create a mode-local value of the system-dependency include path.
@var{mode} is the @code{major-mode} this name/value pairs is for.
@var{name} is the name of the customizable value users will use.
@var{value} is the path to add.
@var{docstring} is a documentation string applied to the variable @var{name}
users will customize.

Creates a customizable variable users can customize that will
keep semantic data structures up to date.
@end defun


@node DB Basic Name Search
@subsection DB Basic Name Search

 These searches scan a database table collection for tags based on
name.  They are divided into normal and deep searches.  A deep
search, as with in buffer tag scanning, implies that all entries are
scanned, including those in type declarations.

Normal Searches:

@defun semanticdb-find-tags-by-name name &optional path find-file-match
@anchor{semanticdb-find-tags-by-name}
Search for all tags matching @var{name} on @var{path}.
See @dfn{semanticdb-find-translate-path} for details on @var{path}.
@var{find-file-match} indicates that any time a match is found, the file
associated with that tag should be loaded into a buffer.
@end defun

@defun semanticdb-find-tags-by-name-regexp regexp &optional path find-file-match
@anchor{semanticdb-find-tags-by-name-regexp}
Search for all tags matching @var{regexp} on @var{path}.
See @dfn{semanticdb-find-translate-path} for details on @var{path}.
@var{find-file-match} indicates that any time a match is found, the file
associated with that tag should be loaded into a buffer.
@end defun

@defun semanticdb-find-tags-for-completion prefix &optional path find-file-match
@anchor{semanticdb-find-tags-for-completion}
Search for all tags matching @var{prefix} on @var{path}.
See @dfn{semanticdb-find-translate-path} for details on @var{path}.
@var{find-file-match} indicates that any time a match is found, the file
associated with that tag should be loaded into a buffer.
@end defun

@defun semanticdb-find-tags-by-class class &optional path find-file-match
@anchor{semanticdb-find-tags-by-class}
Search for all tags of @var{class} on @var{path}.
See @dfn{semanticdb-find-translate-path} for details on @var{path}.
@var{find-file-match} indicates that any time a match is found, the file
associated with that tag should be loaded into a buffer.
@end defun

Deep Searches:

@defun semanticdb-deep-find-tags-by-name name &optional path find-file-match
@anchor{semanticdb-deep-find-tags-by-name}
Search for all tags matching @var{name} on @var{path}.
Search also in all components of top level tags founds.
See @dfn{semanticdb-find-translate-path} for details on @var{path}.
@var{find-file-match} indicates that any time a match is found, the file
associated with that tag should be loaded into a buffer.
@end defun

@defun semanticdb-deep-find-tags-by-name-regexp regexp &optional path find-file-match
@anchor{semanticdb-deep-find-tags-by-name-regexp}
Search for all tags matching @var{regexp} on @var{path}.
Search also in all components of top level tags founds.
See @dfn{semanticdb-find-translate-path} for details on @var{path}.
@var{find-file-match} indicates that any time a match is found, the file
associated with that tag should be loaded into a buffer.
@end defun

@defun semanticdb-deep-find-tags-for-completion prefix &optional path find-file-match
@anchor{semanticdb-deep-find-tags-for-completion}
Search for all tags matching @var{prefix} on @var{path}.
Search also in all components of top level tags founds.
See @dfn{semanticdb-find-translate-path} for details on @var{path}.
@var{find-file-match} indicates that any time a match is found, the file
associated with that tag should be loaded into a buffer.
@end defun

@node DB Data Type Search
@subsection DB Data Type Search

In typed languages, datatypes are looked up frequently in order to
provide smart completions.  Semantic has a specialized datatype search
that builds a cache of all datatypes on the include path.  Once this
is built the first time, datatype lookups become very fast.

Since it takes a long time to make a typecache the first time, you can
have your tool decide if it wants to do work based on the existence of
a typecache.

@defun semanticdb-have-typecache-p table
@anchor{semanticdb-have-typecache-p}
Return non-@code{nil} (the typecache) if @var{table} has a pre-calculated typecache.
@end defun

@defun semanticdb-get-typecache table
@anchor{semanticdb-get-typecache}
Retrieve the typecache from the semanticdb @var{table}.
If there is no table, create one, and fill it in.
@end defun

Searching doesn't require a typecache.  You can just pass in a
database table, or path, much the way most semantic database searches work.

@defun semanticdb-typecache-find type &optional path
@anchor{semanticdb-typecache-find}
Search the typecache for @var{type} in @var{path}.
If type is a string, split the string, and search for the parts.
If type is a list, treat the type as a pre-split string.
@var{path} can be @code{nil} for the current buffer, or a semanticdb table.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun

You can debug the typecache with this routine:

@deffn Command semanticdb-typecache-dump
@anchor{semanticdb-typecache-dump}
Dump the typecache for the current buffer.
@end deffn

@node DB Basic Brute Search
@subsection DB Basic Brute Search

 These searches allow searching on specific attributes of tags,
 such as name, type, or other attribute.

@defun semanticdb-brute-deep-find-tags-by-name name &optional path find-file-match
@anchor{semanticdb-brute-deep-find-tags-by-name}
Search for all tags matching @var{name} on @var{path}.
See @dfn{semanticdb-find-translate-path} for details on @var{path}.
The argument @var{brutish} will be set so that searching includes all tables
in the current project.
@var{find-file-match} indicates that any time a matchi is found, the file
associated wit that tag should be loaded into a buffer.
@end defun

@node DB Advanced Search
@subsection DB Advanced Search

 These are searches that were needed to accomplish some
 specialized tasks as discovered in utilities.  Advanced searches
 include matching methods defined outside some parent class.

 The reason for advanced searches are so that external
 repositories such as the Emacs obarray, or java @file{.class} files can
 quickly answer these needed questions without dumping the entire
 symbol list into Emacs for a regular semanticdb search.

@defun semanticdb-find-tags-external-children-of-type type &optional path find-file-match
@anchor{semanticdb-find-tags-external-children-of-type}
Search for all tags defined outside of @var{type} w/ @var{type} as a parent.
See @dfn{semanticdb-find-translate-path} for details on @var{path}.
@var{find-file-match} indicates that any time a match is found, the file
associated with that tag should be loaded into a buffer.
@end defun

@defun semanticdb-find-tags-subclasses-of-type type &optional path find-file-match
@anchor{semanticdb-find-tags-subclasses-of-type}
Search for all tags of class type defined that subclass @var{TYPE}.
See @dfn{semanticdb-find-translate-path} for details on @var{PATH}.
@var{FIND-FILE-MATCH} indicates that any time a match is found, the file
associated with that tag should be loaded into a buffer.
@end defun

@node DB Generic Search
@subsection DB Generic Search

If you would like to write your own search routine, you can the
generic tag collector.  It will map your function across valid
semantic databases.

@defun semanticdb-find-tags-collector function &optional path find-file-match brutish
@anchor{semanticdb-find-tags-collector}
Collect all tags returned by @var{function} over @var{path}.
The @var{function} must take two arguments.  The first is @var{table},
which is a semanticdb table containing tags.  The second argument
to @var{function} is @var{tags}.  @var{tags} may be a list of tags.  If @var{tags} is non-@code{nil}, then
@var{function} should search the @var{tag} list, not through @var{table}.

See @dfn{semanticdb-find-translate-path} for details on @var{path}.
@var{find-file-match} indicates that any time a match is found, the file
associated with that tag should be loaded into a buffer.

Note: You should leave @var{find-file-match} as @code{nil}.  It is far more
efficient to take the results from any search and use
@dfn{semanticdb-strip-find-results} instead.  This argument is here
for backward compatibility.

If optional argument @var{brutish} is non-@code{nil}, then ignore include statements,
and search all tables in this project tree.
@end defun

@node System Databases
@section System Databases

System Databases are special implementations of the database and
table API which make some external tag source appear as though it
were a normal buffer with semantic parsed tags available.

Search routines for these databases return a special type of table
not associated with a file.  It is important to be aware of this
possible return value.


@deffn Type semanticdb-project-database-emacs-lisp
@anchor{semanticdb-project-database-emacs-lisp}
Database representing Emacs core.
@end deffn

This Emacs database is loaded automatically.


@deffn Type semanticdb-project-database-ebrowse
@anchor{semanticdb-project-database-ebrowse}
Semantic Database deriving tags using the @var{ebrowse} tool.
@var{ebrowse} is a C/C++ parser for use with @code{ebrowse} Emacs program.
@end deffn

To create new EBROWSE project databases, use:

@deffn Command semanticdb-create-ebrowse-database dir
@anchor{semanticdb-create-ebrowse-database}
Create an @var{ebrowse} database for directory @var{dir}.
The database file is stored in ~/.semanticdb, or whichever directory
is specified by @code{semanticdb-default-system-save-directory}.
@end deffn

@node Semanticdb references
@section Semanticdb References

Semantic database can keep references to eachother.  The semanticdb
search routine @code{semanticdb-find-translate-path} will keep the
references up-to date whenever you do a semanticdb search.  Whenever a
buffer is reparsed, all caches are synchronized through the reference
tables.

The reference mechanism will let you identify references in either
direction.

This routine will return a list of TAGS that refer to some database.
Use the routine @code{semanticdb-find-table-for-include} to conver
these include tags into tables.

@defun semanticdb-includes-in-table dbt
@anchor{semanticdb-includes-in-table}
Return a list of direct includes in table @var{dbt}.
@end defun

To run a function against all @semantic{} tables that refer to the
current table, use this routine:

@defun semanticdb-notify-references dbt method
@anchor{semanticdb-notify-references}
Notify all references of the table @var{dbt} using method.
@var{method} takes two arguments.
  (@var{method} @var{table-to-notify} @var{dbt})
@var{table-to-notify} is a semanticdb-table which is being notified.
@var{dbt}, the second argument is @var{dbt}.
@end defun


The following routines will help keep things up-to-date:

@defun semanticdb-check-references dbt
@anchor{semanticdb-check-references}
Check and cleanup references in the database @var{dbt}.
Any reference to a file that cannot be found, or whos file no longer
refers to @var{dbt} will be removed.
@end defun

To debug references, use this routine:

@deffn Command semanticdb-ref-test refresh
@anchor{semanticdb-ref-test}
Dump out the list of references for the current buffer.
If @var{refresh} is non-@code{nil}, cause the current table to have its references
refreshed before dumping the result.
@end deffn



@node Idle Scheduling
@chapter Idle Scheduling

The Semantic Idle Scheduler is a minor mode which performs semantic
specific tasks in idle time.
See @inforef{Idle Scheduler, , semantic-user.info}.

It performs the following tasks in order:

@enumerate
@item 
Reprarse the current buffer if needed
@item
Reparse other buffers that need it
@item
Execute other scheduled semantic related operations.
@end enumerate

Care is take in the idle scheduler to exit immediately if user input
is detected, improving editing performance.

The reason for grouping these tasks together is so that the automatic
reparsing code executes before other idle services.  This allows
lexically broken buffers to be detected so that the other
applications that follow do not accidentally reparse the buffer
leaving unmatched syntax all over.

You can create new minor modes that are automatically scheduled by
the semantic idle scheduler.  Create the new minor mode with:

@defun define-semantic-idle-service name doc &rest forms
@anchor{define-semantic-idle-service}
Create a new idle services with @var{NAME}.
@var{DOC} will be a documentation string describing @var{FORMS}.
@var{FORMS} will be called during idle time after the current buffer's
semantic tag information has been updated.
This routines creates the following functions and variables:
@end defun

@section User Input Handling

When writing an idle service, it is important for tasks that can take
a long time to correctly exit upon user input.

You can test for user input in your idle handler with the following
routines:

@defun semantic-throw-on-input from
@anchor{semantic-throw-on-input}
Exit with @dfn{throw} when in @dfn{semantic-exit-on-input} on user input.
@var{FROM} is an indication of where this function is called from as a value
to pass to @dfn{throw}.  It is recommended to use the name of the function
calling this one.
@end defun

If you need to carefully extract from your function, you can wrap
just a section of your function to exit on user input by wrapping it
with this macro:

@defun semantic-exit-on-input symbol &rest forms
@anchor{semantic-exit-on-input}
Using @var{SYMBOL} as an argument to @dfn{throw}, execute @var{FORMS}.
If @var{FORMS} includes a call to @code{semantic-thow-on-input}, then
if a user presses any key during execution, this form macro
will exit with the value passed to @dfn{semantic-throw-on-input}.
If @var{FORMS} completes, then the return value is the same as @dfn{progn}.
@end defun

Upon catching user input, you can try to detect if there was an exit
from the return argument, and continue throwing with an additional
call to @code{semantic-throw-on-input}.

@node Example Programs
@chapter Programming Examples

  *** NOTE ***  This section needs to be written


@node Current Context
@chapter Deriving the Current Context

This chapter deals with how to derive the current context, and also
how a language maintainer can get the current context API to work
with their language.

By default, the behavior will function in C like languages.  This
means languages with parenthetical blocks, and type dereferencing
which uses a similar form.

@menu
* Blocks::                      
* Local Variables::             Getting lists of local variables.
* Derived Context::             What goes at a given location?
* Context Analysis::            Analysis information about the local context.
@end menu

@node Blocks
@section Blocks and Navigation

Source code is typically built up of control structures, and blocks of
context, or lexical scope.  Semantic terms these lexical scopes as a
``context''.  The following functions can be used to navigate contexts.
Some of them are override functions.  Language authors can override
a subset of them to make them work for their language.

@defun semantic-up-context &optional point bounds-type
@anchor{semantic-up-context}
Move point up one context from @var{point}.
Return non-@code{nil} if there are no more context levels.
Overloaded functions using @code{up-context} take no parameters.
@var{bounds-type} is a symbol representing a tag class to restrict
movement to.  If this is @code{nil}, @code{'function} is used.
This will find the smallest tag of that class (function, variable,
type, etc) and make sure non-@code{nil} is returned if you cannot
go up past the bounds of that tag.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun

@defun semantic-beginning-of-context &optional point
@anchor{semantic-beginning-of-context}
Move @var{point} to the beginning of the current context.
Return non-@code{nil} if there is no upper context.
The default behavior uses @dfn{semantic-up-context}.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun

@defun semantic-end-of-context &optional point
@anchor{semantic-end-of-context}
Move @var{point} to the end of the current context.
Return non-@code{nil} if there is no upper context.
Be default, this uses @dfn{semantic-up-context}, and assumes parenthetical
block delimiters.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun

These next set of functions can be used to navigate across commands.

@defun semantic-end-of-command
@anchor{semantic-end-of-command}
Move to the end of the current command.
Be default, uses @code{semantic-command-separation-character}.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun

@defun semantic-beginning-of-command
@anchor{semantic-beginning-of-command}
Move to the beginning of the current command.
Be default, uses @code{semantic-command-separation-character}.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun

@node Local Variables
@section Deriving local variables

Within a given context, or block of code, local variables are often
defined.  These functions can be used to retrieve lists of locally
scoped variables.

@defun semantic-get-local-variables &optional point
@anchor{semantic-get-local-variables}
Get the local variables based on POINT's context.
Local variables are returned in Semantic tag format.
This can be overriden with @code{get-local-variables}.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun

@defun semantic-get-local-arguments &optional point
@anchor{semantic-get-local-arguments}
Get arguments (variables) from the current context at @var{point}.
Parameters are available if the point is in a function or method.
Return a list of tags unlinked from the originating buffer.
Arguments are obtained by overriding @code{get-local-arguments}, or by the
default function @dfn{semantic-get-local-arguments-default}.  This, must
return a list of tags, or a list of strings that will be converted to
tags.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun

@defun semantic-get-all-local-variables &optional point
@anchor{semantic-get-all-local-variables}
Get all local variables for this context, and parent contexts.
Local variables are returned in Semantic tag format.
Be default, this gets local variables, and local arguments.
Optional argument @var{point} is the location to start getting the variables from.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun

@node Derived Context
@section Deriving the Current Context

While a context has already been used to describe blocks of code,
other context include more local details, such as the symbol the
cursor is on, or the fact we are assigning into some other variable.

These context deriving functions can be overridden to provide language
specific behavior.  By default, it assumes a C like language.

@defun semantic-ctxt-current-symbol &optional point
@anchor{semantic-ctxt-current-symbol}
Return the current symbol the cursor is on at @var{point} in a list.
This will include a list of type/field names when applicable.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun

@defun semantic-ctxt-current-assignment &optional point
@anchor{semantic-ctxt-current-assignment}
Return the current assignment near the cursor at @var{point}.
Return a list as per @dfn{semantic-ctxt-current-symbol}.
Return @code{nil} if there is nothing relevant.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun

@defun semantic-ctxt-current-function &optional point
@anchor{semantic-ctxt-current-function}
Return the current function call the cursor is in at @var{point}.
The function returned is the one accepting the arguments that
the cursor is currently in.  It will not return function symbol if the
cursor is on the text representing that function.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun

@defun semantic-ctxt-current-argument &optional point
@anchor{semantic-ctxt-current-argument}
Return the index of the argument position the cursor is on at @var{point}.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun

@defun semantic-ctxt-current-thing
@anchor{semantic-ctxt-current-thing}
Calculate a thing identified by the current cursor position.
Calls previously defined @code{semantic-ctxt-current-@dots{}} calls until something
gets a match.  See @dfn{semantic-ctxt-current-symbol},
@dfn{semantic-ctxt-current-function}, and @dfn{semantic-ctxt-current-assignment}
for details on the return value.
@end defun

@defun semantic-ctxt-current-class-list &optional point
@anchor{semantic-ctxt-current-class-list}
Return a list of tag classes that are allowed at @var{point}.
If @var{point} is @code{nil}, the current buffer location is used.
For example, in Emacs Lisp, the symbol after a ( is most likely
a function.  In a makefile, symbols after a : are rules, and symbols
after a $( are variables.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun

@defun semantic-ctxt-scoped-types &optional point
@anchor{semantic-ctxt-scoped-types}
Return a list of type names currently in scope at @var{point}.
The return value can be a mixed list of either strings (names of
types that are in scope) or actual tags (type declared locally
that may or may not have a name.)
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end defun

@node Context Analysis
@section Analysis of the current context

The context parsing API is used in a context analysis library.  This
library provides high level routines for scanning through token
databases to create lists of token associates.  At its core is a set
of EIEIO classes defining a context.  The context contains information
about what was parsed at a given position, such as the strings there,
and they type of assignment.  The analysis library then searches the
databases to determine the types and names available.

Two high level functions which can be run interactively are:

@deffn Command semantic-analyze-current-context &optional position
@anchor{semantic-analyze-current-context}
Analyze the current context at optional @var{position}.
If called interactively, display interesting information about @var{position}
in a separate buffer.
Returns an object based on symbol @dfn{semantic-analyze-context}.

This function can be overriden with the symbol @code{analyze-context}.
When overriding this function, your override will be called while
cursor is at @var{position}.  In addition, your function will not be called
if a cached copy of the return object is found.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end deffn


@deffn Command semantic-analyze-possible-completions context
@anchor{semantic-analyze-possible-completions}
Return a list of semantic tags which are possible completions.
@var{context} is either a position (such as point), or a precalculated
context.  Passing in a context is useful if the caller also needs
to access parts of the analysis.
Completions run through the following filters:

@itemize
@item
Elements currently in scope
@item
Constants currently in scope
@item
Elements match the @code{:prefix} in the @var{context}.
@item
Type of the completion matches the type of the context.
@end itemize

Context type matching can identify the following:

@itemize
@item
No specific type
@item
Assignment into a variable of some type.
@item
Argument to a function with type constraints.
@end itemize

When called interactively, displays the list of possible completions
in a buffer.
This function can be overloaded (see @dfn{define-mode-local-override} for details).
@end deffn

@menu
* Analysis Overview::           A description of how the analyzer works.
* Analysis Objects::            What is in the analysis object.
* Completion Overview::         How completions are calculated.
@end menu

@node Analysis Overview
@subsection Analysis Overview

The semantic analysis function @dfn{semantic-analye-current-context}
creates an Analysis Object.  See @ref{Analysis Objects}.  This object
contains many useful pieces of information needed to do any other
kind of intelligent action on the local context.

If you call this function interactively, it will popup a buffer with
a summary of the return value.  This is useful when debugging.

@example
+--------+   +----------------+      +-----------------+
| Buffer |---| Context Parser |------|   Scope Object  |
+--------+   +----------------+      +-----------------+
    |                                        |
+--------+   +-----------+                   |
| Parser |---| Tag Table |---------------+   |
+--------+   +-----------+               |   |
                                         |   |
                                         |   |
             +-----------+               |   |
         +-->| Typecache |-----------+   |   |
         |   +-----------+           |   |   |
         |                           |   |   |
         |                           V   V   V
+-------------+                     +-------------------+
| Semantic DB |-------------------->| Semantic Analyzer |
+-------------+                     +-------------------+
                                             |
                                             V
                                     +-----------------+
                                     | Analysis Object |
                                     +-----------------+
@end example

@node Analysis Objects
@subsection Analysis Objects

@defindex analyze

@c First, delete text between this comment and END OF ANALYZE OBJECT text.
@c 
@c Execute the below line with C-x C-e
@c

@c (progn (require 'semantic-analyze) (eieiodoc-class semantic-analyze-context "analyze"))

NOTE: Need to regenerate this section

@c END OF ANALZE OBJECT SECTION

@node Completion Overview
@subsection Completion Overview

NOTE: Need to write this section too.

@node Data Debugger
@chapter Data structure debugger

The data structures that @semantic{} provides can be complex, and
figuring out why some level of application API performs incorrectly
can be difficult.

The data debugger is provided by @file{data-debug.el} which is
independent of @semantic{}, though @semantic{} extends it for tag
structures and objects it provides.

The data debugger provides a way to look inside the
various data structures of Semantic in a structures and complete way
to help identify what a problem may be.

When using @code{edebug} to interactively debug a function, the key
@kbd{E} is bound to @code{data-debug-edebug-expr}, which will provide
a buffer with the evaluated expression shown in it.

@deffn Command data-debug-edebug-expr expr
@anchor{data-debug-edebug-expr}
Dump out the context of some expression @var{expr} in edebug with ddebug.
@end deffn

@section App Debugger Entry Points

There are a few basic functions that enter into the debugger.  For
historical reasons, the @semantic{} functions use the name
@code{adebug} to specify functions that use the data debugger.

@deffn Command semantic-adebug-bovinate
@anchor{semantic-adebug-bovinate}
The same as @dfn{bovinate}. Display the results in a debug buffer.
@end deffn

@deffn Command semantic-adebug-searchdb regex
@anchor{semantic-adebug-searchdb}
Search the semanticdb for @var{regex} for the current buffer.
Display the results as a debug list.
@end deffn

@deffn Command semantic-adebug-analyze
@anchor{semantic-adebug-analyze}
Perform @dfn{semantic-analyze-current-context}.
Display the results as a debug list.
@end deffn

@section data-debug mode

The semantic adebug API now sits on @code{data-debug} mode, which
provides a simple user facing UI for looking into the data structures.

@deffn Command data-debug-mode
@anchor{semantic-adebug-mode}
Major-mode for the Data Debugging.

Keybindings:
@table @kbd
@item spc
Expand or contract
@item N
Next entry, and expand/contract.
@item P
Previous entry, and expand/contract.
@item n
Next entry
@item p
Next entry
@item <mouse-2>
Expand/Contract entries.
@end table

@end deffn

@section Create new debugger entry commands

Creating a new Application debugger entry point is easy.
First, get a datastructure you need to analyze.

The first function to call is:

@defun data-debug-new-buffer name
@anchor{semantic-adebug-new-buffer}
Create a new ddebug buffer with @var{name}.
@end defun

Next, you need to find the correct function for inserting your
datastructure.  All adebug insertion functions are of the form
@code{data-debug-insert-THING}, where @var{thing} is either the word
@code{thing}, or whatever your object is.  Use Emacs help to pick
something out.

@defun data-debug-insert-thing thing prefix prebuttontext &optional parent
@anchor{data-debug-insert-thing}
Insert @var{thing} with @var{prefix}.
@var{prebuttontext} is some text to insert between prefix and the thing
that is not included in the indentation calculation of any children.
If @var{parent} is non-@code{nil}, it is somehow related as a parent to thing.
@end defun


@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl.texi

@node Index
@unnumbered Index
@printindex cp

@iftex
@contents
@summarycontents
@end iftex

@bye

@c Following comments are for the benefit of ispell.

