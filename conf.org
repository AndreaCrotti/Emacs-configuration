#+OPTIONS: toc:t LEVEL:4

MINIMAL EMACS CONFIGURATION
Emacs is no more about text editing than astronomy is about telescopes.

* DONE Write a function that setups all the possible paths automatically
  CLOSED: [2010-05-04 Mar 11:41]
* DONE See if it's worthy to byte compile everything or not
  CLOSED: [2010-05-24 Lun 14:01]
  - CLOSING NOTE [2010-05-24 Lun 14:01] \\
    Solved nicely with byte-compile-cache, some cases it could not work
* DONE Include another more up-to-date semantic version finally
  CLOSED: [2010-08-08 Dom 16:13]
  - CLOSING NOTE [2010-08-08 Dom 16:13] \\
    included a version from cvs
* DONE Add options to create encrypted org-files for storing password and more delicate informations
  CLOSED: [2011-04-12 Tue 14:03]
  - CLOSING NOTE [2011-04-12 Tue 14:03] \\
    using gnupg already to manage it

* TODO See how to use variables like *special-buffer-regexps* to have a better control over the buffer windows
* TODO Build an automatic list of versions of the packages
* TODO Check out what dictem is from this conf [[file:~/bash_conf/emacs.org][other guy emacs.org]]

* Links
  - [[http://www.gnu.org/software/emacs/tour/][A guided tour of emacs features]]
  - [[http://www.delorie.com/gnu/docs/emacs-lisp-intro/emacs-lisp-intro_toc.html][nice emacs lisp intro]]
  - [[http://www.emacswiki.org/][emacs wiki]]
  - [[http://github.com/purcell/emacs.d/][purcell configuration]]
  - [[http://code.google.com/p/yasnippet/][yasnippet template system]]
    See [[http://yasnippet.googlecode.com/svn/trunk/doc/snippet-development.html#importing-textmate-snippets][snippet developement web page]]

  - [[http://www.emacsblog.org/][emacs blog]]
  - [[http://orgmode.org/][org mode]]
  - [[http://www.linuxjournal.com/article/6771][intermediate emacs hacking]]
  - [[https://github.com/AndreaCrotti/Emacs-conf/tree][my own configuration]]
  - [[http://www.emacswiki.org/emacs/EmacsScreencasts][emacs screencasts]], also how to create your own screencasts
  - [[http://emacs-fu.blogspot.com/][emacs fu]], interesting blog about emacs
  - [[http://geosoft.no/development/emacs.html][emacs tricks and tips]]
  - [[http://lispservice.posterous.com/][lisp emacs blog]]
  - [[http://emacs.wordpress.com/][emacs wordpress blog]]
  - [[http://wttools.sourceforge.net/emacs-stuff/package.html][emacs suggestions (jdee)]]
  - [[http://mytechrants.wordpress.com/][my tech rants, emacs fan blog]]
  - [[http://livollmers.net/index.php/2008/10/06/back-to-myemacs/][back to my emacs]]
  - [[http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html][emergency lisp]]
  - [[http://deep.syminet.com/emacside.html][emacsside, nice cheatsheet]]
  - [[http://platypope.org/yada/emacs-demo/][emacs video demo]], with [[http://platypope.org/blog/2006/9/8/i-need-a-cool-european-accent][explanation of the features showed]]
  - [[http://snarfed.org/space/why_I_dont_run_shells_inside_Emacs][running a shell inside emacs]]
  - [[http://stackoverflow.com/questions/649000/why-emacs-vim-textmate-isnt-xcode-good-enough][why isn't xcode good enough (vs vim and emacs)]]
  - [[http://dotfiles.org/.emacs][ultimate dotfiles repository]]

* Sparse documentation 
  From newcomment.el:
** Define a custom variable with a dynamic list
#+begin_src emacs-lisp :tangle yes
  (defcustom comment-style 'indent
    "Style to be used for `comment-region'.
  See `comment-styles' for a list of available styles."
    :type (if (boundp 'comment-styles)
              `(choice ,@(mapcar (lambda (s) `(const ,(car s)))
                                 comment-styles))
            'symbol)
    :version "23.1"
    :group 'comment)
#+end_src

** How to extend emacs
   [[http://www.enigmacurry.com/2009/01/14/extending-emacs-with-advice/][example about advising functions]]
   - If you can use the mode hooks provided by the author, use them instead.
   - If there is a bug in the original mode, just fix it in the original code and submit a patch.
   - If there is a new feature you want, add it to the original mode and submit a patch. Talk to the author, work with him, and it will most likely end up in the next release.
   - If you are an Emacs developer, working on Emacs itself, or one of the modes shipped with Emacs, never use advice. It's the least maintainable method of extending Emacs with the exception of a pure fork, and since you're working on Emacs itself, it's not a fork.
   - If your patch is not accepted, or you know that what you want is fringe enough or hackish enough to not warrant submitting a patch, only then should you use advice or fork the project.

** Some very useful commands
   - *kill-buffer-and-window*
   - *shell*
   - *list-load-path-shadows* (find hiding libraries)
   - *symbol-function* (find where a symbol is defined)
   - *trace-function* (for debugging and see what really happens), untrace-function to undo
   - *read-string* (getting a string from the minibuffer, see how prompt strings work)
   - *completing-read* (creating a nice menu getting the tab-completion in minibuffer)
   - *string-rectangle* (select a rectangle and replace the inserted text /\C-x r t/)
   - *split-line* (split a line keeping indentation, bound to /\C-\M-o/)
   - *c-set-style*, set the indentation style for your code, many preset useful settings
     Used for java and cc-mode
   - *thing-at-point*, gets what it can find at local point
   - *regexp-builder* very nice to create dynamically a regexp
   - *align* align list of things in a more readable way
   - *ielm*, nice interactive elisp environment
   - *semantic-mrub-switch-tags*, allows to jump to last modified positions with semantic
   - *C-c C-h* (or some other prefix) allows you to see all the commands you can give
   - *describe-mode* (C-h m) 

** Tips and tricks
*** Using always spaces instead of tabs
   There are many opinions about the usage of tabs or spaces in source code.
   I think the best and easiest approach is to use spaces everywhere, tabbing will still create the right number of spaces.

   Setting up the right /style/ with *c-set-style* we can have the desired behavior.
   This is the to set:
#+BEGIN_SRC elisp
   ;; Setting indent-tabs-mode for only spaces
   (setq indent-tabs-mode nil)
#+END_SRC
   If you want to convert from spaces to tabs or tabs to spaces use *tabify* or *untabify* respectively.

*** Make emacs ignore a key
    See for example
#+begin_src emacs-lisp :tangle no
  (global-set-key (kbd "<f2>") 'ignore)
#+end_src

*** Untabify before writing out a file
    In this example we use a hook to untabify before it's finally written out
#+begin_src emacs-lisp :tangle yes
  (defun java-mode-untabify ()
    "untabify the whole buffer"
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "[ \t]+$" nil t)
        (delete-region (match-beginning 0) (match-end 0)))
      (goto-char (point-min))
      (if (search-forward "\t" nil t)
          (untabify (1- (point)) (point-max))))
    nil)
  
  ;; example on how to use this function
  ;; (add-hook 'java-mode-hook 
  ;;           '(lambda ()
  ;;              (make-local-variable 'write-contents-hooks)
  ;;              (add-hook 'write-contents-hooks 'java-mode-untabify)))
#+end_src

*** Replacement stuff in emacs
    List of things to substitute with emacs

    | \&                    | the original found text                                           |
    | \1, \2,               | etc.  the 1st, 2nd, etc. parenthesized subgroup in the found text |
    | \#                    | the number of replacements done so far                            |
    | \?                    | a string obtained by prompting the user on each match             |
    | \,(lisp-expression â€¦) | the result of evaluating an arbitrary function                    |

** How to set up your initialization
   The configuration should be as modular as possible, and should use autoloads when possible.
   There are different way to set up variables on not loaded libraries:
   - *simple variables*
     use simply *setq* and evaluate it on emacs loading

   - *adding default values of an extension*
     for example /(define-key foo-mode-map ...)/ use *eval-after-load*.
     This will add default values once the extension is loaded.

   - *run code after initialization*
     Use mode hooks, normally simply <mode-name>-hook, and modify them with *add-hook*

** [[http://steve-yegge.blogspot.com/2006/06/shiny-and-new-emacs-22.html][Very nice explanation about emacs and replacing functions]]

** Org mode
   - [[http://members.optusnet.com.au/~charles57/GTD/gtd_workflow.html][org mode as a gtd system]]
     Create some subsections
     + tasks
     + calendar
     + projects
     + financial (use ledger for that)
     + borrowed
     + configuration?

* Aliasing and other useful shortcuts
#+begin_src emacs-lisp :tangle yes
  (defalias 'eb 'eval-buffer)
  (defalias 'er 'eval-region)
  (defalias 'yes-or-no-p 'y-or-n-p)
  (defalias 'rs 'replace-string)
  (defalias 'qs 'query-replace)
  (defalias 'qrs 'query-replace-regexp)
  (defalias 'ac 'auto-complete-mode)
  (defalias 'go 'google-search-it)
  (defalias 'gs 'google-search-selection)
  (defalias 'spell 'flyspell-mode)
  (defalias 'spell-prog 'flyspell-prog-mode)
  (defalias 'dml 'delete-matching-lines)
  (defalias 'bb 'bury-buffer)
  (defalias 'elm 'emacs-lisp-mode)
  
  (defalias 'ys 'yas/reload-all)
  (defalias 'yv 'yas/visit-snippet-file)
  
  (defalias 'ascii 'org-export-as-ascii)
  (defalias 'html 'org-export-as-html-and-open)
  (defalias 'pdf 'org-export-as-pdf-and-open)
  (defalias 'box 'comment-box)
  (defalias 'rb 'revert-buffer)
  
  (defalias 'sh 'shell)
  
  (defalias 'ws 'whitespace-mode)
  (defalias 'bu 'browse-url)
  
  (defalias 'mem 'doxymacs-insert-member-comment)
  (defalias 'fun 'doxymacs-insert-function-comment)
  (defalias 'file 'doxymacs-insert-file-comment)
  
  ;; Those below are my favourite themes
  (defalias 'black 'color-theme-hober)
  (defalias 'blue 'color-theme-deep-blue)
  (defalias 'grey 'color-theme-black-on-gray)
  (defalias 'blipp 'color-theme-blippblopp)
  (defalias 'high 'color-theme-high-contrast)
  (defalias 'billw 'color-theme-billw)
  (defalias 'coal 'color-theme-charcoal-black)
  
  (defalias 'batt 'display-battery-mode)
  
  (defun get-some-messages ()
    (interactive)
    (gnus-summary-rescan-group 1000))
  ;; gnus
  (defalias 'gg 'get-some-messages)
  (defalias 'jd 'javadoc-lookup)
  (defalias 'br 'babel-region-default)
  (defalias 'git 'open-git-files)
  
  (defalias 'fold 'senator-fold-tag-toggle)
  
  (defalias 'pd 'print-desktop)
  (defalias 'dcd 'desktop-change-dir)
  (defalias 'gcb 'git-change-branch)
#+end_src   

* Preliminary settings
** Provide the library
#+begin_src emacs-lisp :tangle yes
  (provide 'miniconf)
#+end_src

** Custom settings
#+begin_src emacs-lisp :tangle yes
  (setq custom-file (concat base "custom.el"))
#+end_src

** Constants and some global settings
#+begin_src emacs-lisp :tangle yes
  (defcustom default-closing-char ";"
    "default closing char, change in newline-force-close-alist if needed"
    :type 'string)
  
  ;; TODO: use a defcustom instead
  (defcustom newline-force-close-alist
    '((python-mode . ":")
      (jython-mode . ":")
      (prolog-mode . ".")
      (latex-mode . " \\newline")
      (org-mode . " \\newline")
      (tuareg-mode . ";;")
      (html-mode . " <br>"))
    "Closing char for different modes"
    :type 'list)
#+end_src

** Some useful functions
   We suppose that the global variable *conf* has been already set from the outside.

*** Enable semantic when possible
#+begin_src emacs-lisp :tangle yes
  (defun my-next-tag ()
    (interactive)
    (semantic-refresh-tags-safe)
    (senator-next-tag))
  
  (defun activate-more-semantic-bindings ()
    "add some other nice bindings to modes supported by semantic"
    (interactive)
    (local-set-key (kbd "M-n") 'my-next-tag)
    (local-set-key (kbd "M-p") 'senator-previous-tag)
    (local-set-key "\C-cq" 'semantic-ia-show-doc)
    ;; TODO: the senator stuff should be enabled only where senator actually works!!
    (local-set-key [f6] 'senator-fold-tag-toggle)
    ;; narrows to the actual function or class analyzed
    ;; C-x n w to widen again
    (local-set-key "\C-xnn" 'semantic-narrow-to-tag)
    (local-set-key (kbd "M-.") 'semantic-complete-jump)
    (local-set-key (kbd "M-?") 'semantic-ia-fast-jump))
#+end_src

*** Make a script executable
#+begin_src emacs-lisp :tangle yes
  ;FIXME: not correct yet
  (defun px()
    (interactive)
    (chmod (buffer-file-name) "777"))
#+end_src
    
*** Make fortune
    Print below a fortune cookie if the command is present in the system.

#+begin_src emacs-lisp :tangle yes
  (defun make-fortune ()
  (interactive)
  (let ((beg (point)))
    (insert (shell-command-to-string "fortune"))
    (end-of-paragraph-text)))
#+end_src
 
*** Gen path dirs
   All all the directories in the first level of the configuration directory to the load path.

#+begin_src emacs-lisp :tangle yes
  (defun gen-path-dirs (base-dir)
    "Add to load path all the subdirectories of first level"
    (interactive)
    (message "adding all directories in the first level to the load-path")
    (dolist (dir (directory-files base-dir t))
      (if (and 
           (file-directory-p dir)
           (not (file-symlink-p dir)))
          (add-to-list 'load-path dir))))
  
  ; next step is to remove conf completely
  (defun reload-dirs ()
    (interactive)
    (gen-path-dirs base))
  
  (reload-dirs)
#+end_src

*** Add programming tools to the path
#+begin_src emacs-lisp :tangle yes
  (let
      ((tools (concat base "programming-tools")))
    (add-to-list 'exec-path tools)
    (setenv "PATH" (concat (getenv "PATH") ":" tools)))
  
#+end_src

*** Google map it
   Search an address in google map
#+begin_src emacs-lisp :tangle yes
  (defun google-map-it (address)
    "get the map of the given address"
    (interactive "sSearch for: ")
    (let
        ((base "http://maps.google.it/maps?q=%s"))
      (browse-url (format base (url-hexify-string address)))))
#+end_src   

*** New line
   Those functions are inspired by textmate
#+begin_src emacs-lisp :tangle yes
  ;; My own functions
  (defun newline-force()
    "Goes to newline leaving untouched the rest of the line"
    (interactive)
    (end-of-line)
    (newline-and-indent))
  
  (defun newline-force-close()
    "Same as newline-force but putting a closing char at end unless it's already present"
    (interactive)
    (let ((closing-way (assoc major-mode newline-force-close-alist))
          closing-char)
      ;; Setting the user defined or the constant if not found
      (if (not closing-way)
          (progn
            (message "closing char not defined for this mode, using default")
            (setq closing-char default-closing-char))
        (setq closing-char (cdr closing-way)))
      (when (not (bobp))
        ;; if we're at beginning of buffer, the backward-char will beep
        ;; :( This works even in the case of narrowing (e.g. we don't
        ;; look outside of the narrowed area.
        (if (not (looking-at (format ".*%s.*" closing-char)))
            (progn
              (end-of-line)
              (insert closing-char))
          (message "%s already present" closing-char))
        (newline-force))))
#+end_src

*** Error switch
    Useful function to toogle on and off the debug mode
#+begin_src emacs-lisp :tangle yes
  (defun err-switch()
    "switch on/off error debugging"
    (interactive)
    (if debug-on-error
        (setq debug-on-error nil)
      (setq debug-on-error t))
    (message "debug-on-error now %s" debug-on-error))
#+end_src

*** Swap windows
#+begin_src emacs-lisp :tangle yes
  ;; someday might want to rotate windows if more than 2 of them
  (defun swap-windows ()
    "If you have 2 windows, it swaps them."
    (interactive)
    (cond 
     ((not (= (count-windows) 2)) (message "You need exactly 2 windows to do this."))
     (t
      (let* ((w1 (first (window-list)))
             (w2 (second (window-list)))
             (b1 (window-buffer w1))
             (b2 (window-buffer w2))
             (s1 (window-start w1))
             (s2 (window-start w2)))
        (set-window-buffer w1 b2)
        (set-window-buffer w2 b1)
        (set-window-start w1 s2)
        (set-window-start w2 s1)))))
#+end_src
# TODO: Add something to rotate the windows gracefully

*** Rename file and buffer
**** TODO Add something VCS related for moving away files
#+begin_src emacs-lisp :tangle yes
  (defun rename-file-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME." (interactive "sNew name: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not filename)
          (message "Buffer '%s' is not visiting a file!" name)
        (if (get-buffer new-name)
            (message "A buffer named '%s' already exists!" new-name)
          (progn   (rename-file name new-name 1)   (rename-buffer new-name)        (set-visited-file-name new-name)        (set-buffer-modified-p nil)))))) ;;
#+end_src

*** Move buffer file
#+begin_src emacs-lisp :tangle yes
  (defun move-buffer-file (dir)
    "Moves both current buffer and file it's visiting to DIR." (interactive "DNew directory: ")
    (let* ((name (buffer-name))
           (filename (buffer-file-name))
           (dir
            (if (string-match dir "\\(?:/\\|\\\\)$")
                (substring dir 0 -1) dir))
           (newname (concat dir "/" name)))
  
      (if (not filename)
          (message "Buffer '%s' is not visiting a file!" name)
        (progn         (copy-file filename newname 1)  (delete-file filename)  (set-visited-file-name newname)         (set-buffer-modified-p nil)     t))))
#+end_src

*** Delete current file
#+begin_src emacs-lisp :tangle yes
  (defun delete-current-file () 
    "Delete the file associated with the current buffer." 
    (interactive) 
    (let (currentFile) 
      (setq currentFile (buffer-file-name)) 
      (when (yes-or-no-p (format "Delete file % s and kill buffer? " currentFile)) 
        (kill-buffer (current-buffer)) 
        (delete-file currentFile) 
        (message "Deleted file: %s " currentFile))))
#+end_src

*** Open git files
    Run *git ls-files* and visits all the buffer given from it

#+begin_src emacs-lisp :tangle yes
  (defun open-git-files ()
    "Visit all the files in the current git project"
    (interactive)
    (dolist
        (file (ls-git-files))
      (message "Opening %s" file)
      ;; we have to keep the original position
      (save-excursion (find-file file))))
  
  (defun before-last (list)
    (nth (- (length list) 2) list))
  
  (defun dired-git (directory)
    (interactive "D")
    (dired-git-files directory))
  
  (defun dired-git-files (directory)
    (cd directory)
    "Open a dired buffer containing the local git files"
    (let ((files (ls-git-files)))
      (if
          (or 
           (< (length files) 200)
           (yes-or-no-p (format "%d files, are you sure?" (length files))))
          ;; rename the buffer to something with a sense
          (progn
            (dired (ls-git-files))
            (rename-buffer (git-dired-buffer-name directory))))))
  
  (defun git-dired-buffer-name (directory)
    (concat "git-" (before-last (split-string directory "/"))))
  
  ;; TODO: take the return code instead
  (defun ls-git-files ()
    (let
        ((result (shell-command-to-string (concat "git ls-files"))))
      (if
          (string-match "fatal" result)
          nil
        (split-string result))))
#+end_src

*** Run git grep and see the results
#+begin_src emacs-lisp :tangle yes
  (defun git-grep-string (string-to-find)
    "Look for a string using git-grep"
    (interactive "sString: ")
    (let ((grep-result-buffer (get-buffer-create "*git grep result*")))
      (shell-command (format "git --no-pager grep -nH -e %s" string-to-find) grep-result-buffer)
      (pop-to-buffer grep-result-buffer)
      (grep-mode))
    )
#+end_src

*** Change git branch
#+begin_src emacs-lisp :tangle yes
  (defun git-branches-list ()
    "list the current branches"
    (remove "*" (split-string (shell-command-to-string "git branch"))))
  
  (defun git-change-branch ()
    "change the actual git branch asking with completion"
    (interactive)
    (let
        ((branches (git-branches-list)))
      (if
          (> (length branches) 1)
          (let 
              ((branch (completing-read "checkout to: " branches)))
            (shell-command (concat "git checkout " branch)))
        (message "no other branches, sorry"))))
  
  (defun git-create-branch ()
    "creates a new branch"
    (interactive)
    (let
        ((branch-name (read-from-minibuffer "Name: ")))
      (shell-command (concat "git checkout -b " branch-name))))
#+end_src

*** Replace in regexp
#+begin_src emacs-lisp :tangle yes
  (defun query-replace-in-git (from to)
    "query replace regexp on the files given"
    (interactive "sFrom: \nsTo: ")
    (dired-git (pwd))
    (dired-mark-files-regexp ".[ch]")
    (dired-do-query-replace-regexp from to))
#+end_src 

*** Camelizing
    (un)Camelizing allows to convert quickly function/variables names from camelized to non camelized mode.

#+begin_src emacs-lisp :tangle yes
  (defun mapcar-head (fn-head fn-rest list)
    "Like MAPCAR, but applies a different function to the first element."
    (if list
        (cons (funcall fn-head (car list)) (mapcar fn-rest (cdr list)))))
  
  (defun camelize (s)
    "Convert under_score string S to CamelCase string."
    (mapconcat 'identity (mapcar
                          '(lambda (word) (capitalize (downcase word)))
                          (split-string s "_")) ""))
  
  (defun camelize-method (s)
    "Convert under_score string S to camelCase string."
    (mapconcat 'identity (mapcar-head
                          '(lambda (word) (downcase word))
                          '(lambda (word) (capitalize (downcase word)))
                          (split-string s "_")) ""))
  
  (defun un-camelcase-string (s &optional sep start)
    "Convert CamelCase string S to lower case with word separator SEP.
      Default for SEP is a hyphen \"-\".
      If third argument START is non-nil, convert words after that
      index in STRING."
    (let ((case-fold-search nil))
      (while (string-match "[A-Z]" s (or start 1))
        (setq s (replace-match (concat (or sep "-") 
                                       (downcase (match-string 0 s))) 
                               t nil s)))
      (downcase s)))
  
  (defun manipulate-matched-text (fn)
    (let (matchedText newText)
      (setq matchedText
            (buffer-substring
             (match-beginning 0) (match-end 0)))
      (setq newText
            (apply 'fn match-end))
      newText))
  
  ; TODO: use the more general manipulation
  (defun uncamel ()
    (let (matchedText newText)
      (setq matchedText
            (buffer-substring
             (match-beginning 0) (match-end 0)))
      (setq newText
            (un-camelcase-string matchedText "_"))
      newText))
  
    ;; (manipulate-matched-text 'un-camelcase-string))
    ;; "use this function with query-replace-regexp"
#+end_src

    For example the above functions might be very useful to convert an entire project from camelcase to non camelcase.
    
    - Open dired
    - mark the files you want
    - "Q" RET [a-z]+?[A-Z] RET \,(uncamel)
    
    And the fun begins

    We also have [[http://www.eecs.ucf.edu/~leavens/emacs/camelCase/camelCase-mode.html][camel case mode]] which makes moving in camelized words smarter
#+begin_src emacs-lisp :tangle yes
  ;; TODO: with emacs23 is sufficient to enable subword-mode probably
  (autoload 'camelCase-mode "camelCase-mode")
  (defcustom camelCase-modes
    '(python-mode-hook java-mode-hook c-mode-common-hook nesc-mode-hook)
    "Modes where camelizing is allowed"
    :type 'list)
  
  (dolist (hook camelCase-modes)
    (add-hook hook 'camelCase-mode))
#+end_src

*** Find project
    This functions are take from textmate.el and are used to check if we're on a project of some kind.
    Not used at the moment.

#+begin_src emacs-lisp :tangle yes
  ;; When it's a git project we can use a grep over git ls-files
  ;; same thing for mercurial
  ;; check also with the Makefiles in general if we can do something like this
  ;; In this way is too simplicistic
  
  (defvar *project-roots*
    '(".git" ".hg" "Rakefile" "Makefile" "README" "build.xml")
    "The presence of any file/directory in this list indicates a project root.")
  
  (defun root-match(root names)
    (member (car names) (directory-files root)))
  
  (defun root-matches(root names)
    (if (root-match root names)
        (root-match root names)
      (if (eq (length (cdr names)) 0)
          'nil
        (root-matches root (cdr names)))))
  
  ;; should return also the type and the certainty level
  (defun find-project-root (&optional root)
    "Determines the current project root by recursively searching for an indicator."
    (interactive)
    (when (null root)
      (setq root default-directory))
    (cond
     ((root-matches root *project-roots*)
      (expand-file-name root))
     ((equal (expand-file-name root) "/") nil)
     (t
      ;; recursive call
      (find-project-root (concat (file-name-as-directory root) "..")))))
  
  (find-project-root)
#+end_src

*** Select current line
#+begin_src emacs-lisp :tangle yes
  (defun select-line ()
    "If the mark is not active, select the current line.
  Otherwise, expand the current region to select the lines the region touches."
    (interactive)
    (if mark-active ;; expand the selection to select lines
        (let ((top (= (point) (region-beginning)))
              (p1 (region-beginning))
              (p2 (region-end)))
          (goto-char p1)
          (beginning-of-line)
          (push-mark (point))
          (goto-char p2)
          (unless (looking-back "\n")
            (progn
              (end-of-line)
              (if (< (point) (point-max)) (forward-char))))
          (setq mark-active t
                transient-mark-mode t)
          (if top (exchange-point-and-mark)))
      (progn
        (beginning-of-line)
        (push-mark (point))
        (end-of-line)
        (if (< (point) (point-max)) (forward-char))
        (setq mark-active t
              transient-mark-mode t))))
#+end_src

*** Select all from an alist
#+begin_src emacs-lisp :tangle yes
  (defun all-asscs (asslist query)
    "returns a list of all corresponding values (like rassoc)"
    (cond
     ((null asslist) nil)
     (t
      (if (equal (cdr (car asslist)) query)
          (cons (car (car asslist)) (all-asscs (cdr asslist) query))
        (all-asscs (cdr asslist) query)))))
#+end_src

*** Reopen a file in readwrite mode
#+begin_src emacs-lisp :tangle yes
  (defcustom preferred-reopen-rw-mode "sudo"
    "preferred mode for reopen"
    :type 'string
    )
  
  (defun rw ()
    "Reopen the file in rw mode, sui"
    (interactive)
    (let
        ((read-only-old-file (buffer-file-name)))
      (if (not (file-writable-p read-only-old-file))
          (when (yes-or-no-p "kill the read only and reopen in rw?")
            (progn 
              (kill-buffer)
              (find-file (concat "/" preferred-reopen-rw-mode "::" read-only-old-file))))
        (message "you can already write on this file"))))
#+end_src

*** Count words in the buffer
#+begin_src emacs-lisp :tangle yes
  ;FIXME: Not really doing what is expected
  (defun wc-buffer ()
    "Print number of words in Buffer"
    (interactive)
    (shell-command-on-region (point-min) (point-max) "wc -w"))
#+end_src

*** Find-file-root
#+begin_src emacs-lisp :tangle yes
  ;; Taken from http://www.emacswiki.org/emacs/TrampMode
  (defvar find-file-root-prefix (if (featurep 'xemacs) "/[sudo/root@localhost]" "/sudo:root@localhost:" )
    "*The filename prefix used to open a file with `find-file-root'.")
  
  (defvar find-file-root-history nil
    "History list for files found using `find-file-root'.")
  
  (defvar find-file-root-hook nil
    "Normal hook for functions to run after finding a \"root\" file.")
  
  (defun find-file-root ()
    "*Open a file as the root user.
     Prepends `find-file-root-prefix' to the selected file name so that it
     maybe accessed via the corresponding tramp method."
  
    (interactive)
    (require 'tramp)
    (let* ( ;; We bind the variable `file-name-history' locally so we can
           ;; use a separate history list for "root" files.
           (file-name-history find-file-root-history)
           (name (or buffer-file-name default-directory))
           (tramp (and (tramp-tramp-file-p name)
                       (tramp-dissect-file-name name)))
           path dir file)
  
      ;; If called from a "root" file, we need to fix up the path.
      (when tramp
        (setq path (tramp-file-name-localname tramp)
              dir (file-name-directory path)))
  
      (when (setq file (read-file-name "Find file (UID = 0): " dir path))
        (find-file (concat find-file-root-prefix file))
        ;; If this all succeeded save our new history list.
        (setq find-file-root-history file-name-history)
        ;; allow some user customization
        (run-hooks 'find-file-root-hook))))
  
  (global-set-key [(control x) (control r)] 'find-file-root)
#+end_src
  
  Adding also some warning to make sure we don't edit by mistake
#+begin_src emacs-lisp :tangle yes
  (defface find-file-root-header-face
    '((t (:foreground "white" :background "red3")))
    "*Face use to display header-lines for files opened as root.")
  
  (defun find-file-root-header-warning ()
    "*Display a warning in header line of the current buffer.
     This function is suitable to add to `find-file-root-hook'."
    (let* ((warning "WARNING: EDITING FILE AS ROOT!")
           (space (+ 6 (- (window-width) (length warning))))
           (bracket (make-string (/ space 2) ?-))
           (warning (concat bracket warning bracket)))
      (setq header-line-format
            (propertize  warning 'face 'find-file-root-header-face))))
  
  (add-hook 'find-file-root-hook 'find-file-root-header-warning)
#+end_src

** reload this configuration
#+begin_src emacs-lisp :tangle yes
  (defun reload-conf ()
    (interactive)
    (org-babel-load-file (make-conf-path "conf.org")))
#+end_src

* Operating system detection
  This has to be done first because we have some conditional code later
#+begin_src emacs-lisp :tangle yes
  (defconst sysop 
    (cond ((string-match "linux" system-configuration) "linux")
          ((string-match "apple" system-configuration) "mac")
          ((string-match "win" system-configuration) "win") (t "other")))
  
  (defconst linux (string= "linux" sysop))
  (defconst mac (string= "mac" sysop))
  (defconst win (string= "win" sysop))
  (defconst other (string= "other" sysop))
  
  ;; ;; (defconst linux nil)
  ;; ;; (defconst mac nil)
  ;; ;; (defconst win nil)
  ;; ;; (defconst other nil)
  
  ;; (case system-type
  ;;   (gnu/linux (setq linux t))
  ;;   (window-nt (setq mac t))
  ;;   (darwin    (setq win t))
  ;;   (t         (setq other t)))
#+end_src

** Mac configuration
    This will setup the Command key ot be used as meta.
#+begin_src emacs-lisp :tangle yes
  (if mac
      (progn
        (add-to-list 'exec-path "/opt/local/bin")
        (setq ns-alternate-modifier (quote none))
        ;; open a new frame only unless it's the scratch buffer
        (setq ns-pop-up-frames 1)
        (setq ns-command-modifier (quote meta))))
#+end_src

* Other useful paths
#+begin_src emacs-lisp :tangle yes
  (if mac
      (let ((ports-lisp "/opt/local/share/emacs/site-lisp/"))
        (if 
            (file-exists-p ports-lisp)
            (add-to-list 'load-path ports-lisp))))
#+end_src

* Buffer management
  See also [[http://scottfrazersblog.blogspot.com/2010/01/emacs-filtered-buffer-switching.html][this nice article]] for a better filtering of buffers while switching.

** Manage buffer
#+begin_src emacs-lisp :tangle yes
  (defun untabify-buffer ()
    (interactive)
    (untabify (point-min) (point-max)))
  
  (defun indent-buffer ()
    (interactive)
    (indent-region (point-min) (point-max)))
  
  (defun cleanup-buffer ()
    "Perform a bunch of operations on the whitespace content of a buffer."
    (interactive)
    (indent-buffer)
    (untabify-buffer)
    (delete-trailing-whitespace))
  
  (defun ditto ()
    "*Copy contents of previous line, starting at the position above point."
    (interactive)
    (let ((last-command nil))
      (save-excursion
        (previous-line 1)
        (copy-region-as-kill (point) (progn (end-of-line) (point))))
      (yank 1)))
#+end_src

** Dired settings
#+begin_src emacs-lisp :tangle yes
  ;; reverting automatically the buffer
  (setq dired-auto-revert-buffer 1)
  ;; look for filenames if on one already
  (setq dired-isearch-filenames 'dwim)
  ;; so it doesn't open a thousand buffers every time
  (put 'dired-find-alternate-file 'disabled nil)
  
  (setq file-extensions-separately 
        '("\\.pdf$" "\\.rar$" "\\.html?$" "\\.mp3$" "\\.mp4$" "\\.flv$"))
  
  (setq dired-guess-shell-alist-user ())
  
  (if mac
      (dolist (ext file-extensions-separately)
        (add-to-list 'dired-guess-shell-alist-user (list ext "open"))))
  
  ;TODO: add conditions for other operating systems 
  
  (add-hook 'dired-mode-hook
            (lambda ()
              ;; define some more useful keys
              (define-key dired-mode-map "b" 'browse-url-of-dired-file)))
#+end_src

*** Using dired-details for smaller windows
#+begin_src emacs-lisp :tangle yes
  (require 'dired-details)
  (dired-details-install)
#+end_src

** Using the nicer bookmark+
#+begin_src emacs-lisp :tangle yes
   (require 'bookmark+)
#+end_src

** Desktop mode
#+begin_src emacs-lisp :tangle no
  (require 'desktop)
   
  (desktop-save-mode -1)
  ;; save always
  (setq desktop-save nil)
  (defun print-desktop ()
    (interactive)
    (message "current desktop is %s" desktop-dirname))
  
  (setq history-length 250)
  (add-to-list 'desktop-globals-to-save 'file-name-history)
  
  ;; name and mode of buffers to forget
  (setq desktop-buffers-not-to-save
        (concat "\\("
                "^nn\\.a[0-9]+\\|\\.log\\|(ftp)\\|^tags\\|^TAGS"
                "\\|\\.emacs.*\\|\\.diary\\|\\.newsrc-dribble\\|\\.bbdb"
                "\\)$"))
  
  (defun dired-git-current ()
    (dired-git-files  desktop-dirname))
  
  (defcustom dired-git-after-desktop
    nil
    "asking to open a dired buffer every time"
    :type 'boolean)
  
  ;; first we have to pass to the right dir
  (if dired-git-after-desktop
      (add-hook 'desktop-after-read-hook 'dired-git-current))
  
  (add-to-list 'desktop-modes-not-to-save 'dired-mode)
  (add-to-list 'desktop-modes-not-to-save 'Info-mode)
  (add-to-list 'desktop-modes-not-to-save 'info-lookup-mode)
  (add-to-list 'desktop-modes-not-to-save 'fundamental-mode)
  
  (add-hook 'auto-save-hook (lambda () (desktop-save-in-desktop-dir)))
  
  (setq desktop-clear-preserve-buffers
        (append '("\\.newsrc-dribble" "\\.org$" "eternal" "\\*shell\\*" "\\*group\\*" "\\*ielm\\*") desktop-clear-preserve-buffers))
#+end_src

** Uniquify
   Uniquify is used to distinguish easily from buffers with the same name.
#+begin_src emacs-lisp :tangle yes
  ;; Using uniquify for better handling of buffers with same name
  (require 'uniquify)
  ;; Using part of the directory in this case
  (setq uniquify-buffer-name-style 'forward)
#+end_src   

** Saveplace
   Remembers where you were in the buffer
#+begin_src emacs-lisp :tangle yes
   (require 'saveplace)
#+end_src   

** Minibuffer nice stuff
#+begin_src emacs-lisp :tangle yes
  (setq visible-bell nil) ; Turn beep off
  (setq ring-bell-function 'ignore)
  (savehist-mode t) ; save also minibuffer history, very useful
#+end_src

** Ibuffer settings
#+begin_src emacs-lisp :tangle yes
  ;; Set some automatic filters
  (setq ibuffer-saved-filter-groups
        '(("default"
           ("Chat" (or
                    (mode . garak-mode)
                    (name . "^\\*Garak\\*$")
                    (mode . rcirc-mode)))
           ("Organization" (or
                            (mode . diary-mode)
                            (mode . org-mode)
                            (mode . org-agenda-mode)))
           ("Gnus & News" (or
                           (mode . message-mode)
                           (mode . bbdb-mode)
                           (mode . mail-mode)
                           (mode . gnus-group-mode)
                           (mode . gnus-summary-mode)
                           (mode . gnus-article-mode)
                           (name . "^\\(\\.bbdb\\|dot-bbdb\\)$")
                           (name . "^\\.newsrc-dribble$")
                           (mode . newsticker-mode)))
           ("Files" (filename . ".*"))
           ("File Management" (or
                               (mode . dired-mode)
                               (mode . shell-mode)))
           ("Documentation" (or
                             (mode . Info-mode)
                             (mode . apropos-mode)
                             (mode . woman-mode)
                             (mode . help-mode)
                             (mode . Man-mode))))))
  
  (add-hook 'ibuffer-mode-hook
            (lambda ()
              ;; make jumping between filters easier
              (define-key ibuffer-mode-map "\C-n" 'ibuffer-forward-filter-group)
              (define-key ibuffer-mode-map "\C-p" 'ibuffer-backward-filter-group)))
#+end_src
                             
** Hide org-mode Files
   Only works with without ido-mode, not really useful at now
#+begin_src emacs-lisp :tangle yes
  (defun th-hide-org-buffers (arg)
    "Hide org-mode buffers from completion by prepending a space at the buffer name.
  When called with prefix arg (`C-u'), then remove this space again."
    (interactive "P")
    (dolist (b (buffer-list))
      (set-buffer b)
      (when (eq major-mode 'org-mode)
        (rename-buffer
         (if arg 
             (replace-regexp-in-string "^[[:space:]]+" "" (buffer-name))
           (concat " " (buffer-name)))))))
#+end_src

* Package management
  Auto install is a nice way to install packages from emacswiki repository.
  There are other possible ways to manage the emacs packages.
#+begin_src emacs-lisp :tangle yes
  ; Other autoloads
  (autoload 'auto-install-from-emacswiki "auto-install" "auto install from emacswiki" t)
  (setq auto-install-directory (make-conf-path "auto-install/"))
#+end_src

* Frame management
  [[http://www.emacswiki.org/emacs/Shrink-Wrapping_Frames][See shrinking frames]] and onetoone to see what it could be done to make emacs more frame-centric.

  Create some extensions to manage frames more easily, with "select-frame", "next-frame" and so on.

** Create org agenda buffer
   It's useful to be able to generate a smaller frame (which stays at the bottom) with the TODO list agenda.
#+begin_src emacs-lisp :tangle yes
  ;TODO: make it automatically the right size (check why frame-width does not work)
  (defun make-org-agenda-buffer ()
    "Generates a small frame below for showing the agenda"
    (interactive)
    (let ((org-agenda-frame
           (make-frame 
            '((name . "org-agenda")
              (width . 200)
              (heigth . 10)
              (minibuffer . t)))))
      (with-selected-frame org-agenda-frame
        (set-frame-position org-agenda-frame 0 400)
        (bury-buffer)
        (org-agenda 0 "t"))))
  
#+end_src

* Visualization
** Menu and tool-bar disabling
#+begin_src emacs-lisp :tangle yes
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (and linux window-system) (menu-bar-mode -1))
#+end_src

** Fullscreen mode
#+begin_src emacs-lisp :tangle yes
  (defun full (&optional f)
    (interactive)
    (if
        mac
        ;; included in emacs 23.2
        (ns-toggle-fullscreen)
    (set-frame-parameter f 'fullscreen
                         (if (frame-parameter f 'fullscreen) nil 'fullboth))))
  
  ;; this toogle the fullscreen for every new frame (window) created
  ;; (add-hook 'after-make-frame-functions 'full)
#+end_src

** Winner mode
   Winner mode remember the window configuration and allows you to go back and forth
#+begin_src emacs-lisp :tangle yes
  ;; enabling winner mode for window reconfiguration
  (winner-mode t)
#+end_src

** Color theme setting
#+begin_src emacs-lisp :tangle yes
  (require 'color-theme)
  (eval-after-load "color-theme"
    '(progn
       (color-theme-initialize)))
  
  (defcustom preferred-color-theme-function
    'coal
    "preferred color theme"
    :type 'function
  )
#+end_src

** Fringe and stuff todo
   Nice but unable to update itself automatically, but only set when the file is visited first time.
#+begin_src emacs-lisp :tangle no
  (defun annotate-todo ()
    "put fringe marker on TODO: lines in the curent buffer"
    (interactive)
    (save-excursion
      ;; TODO: add also other regexps like FIXME or others
      (goto-char (point-min))
      (while (re-search-forward "TODO:" nil t)
        (let ((overlay (make-overlay (- (point) 5) (point))))
          (overlay-put overlay 'before-string (propertize "A" 'display '(left-fringe right-triangle)))))))
  
  
  (add-hook 'find-file-hook 'annotate-todo)
#+end_src
  
** Font settings
  Defininig some nice fonts and how to switch between theme.
  [[http://xahlee.org/emacs/emacs_unicode_fonts.html][Cycling function definition]]
#+begin_src emacs-lisp :tangle yes
  (setq current "monaco-12")
  (setq font-list
        (list "monaco-12" "inconsolata-14" "courier-13"))
  
  (defun cycle-font ()
    "Change font in current frame"
    (interactive)
  
    (let (fontToUse currentState)
      ;; states starts from 1.
      (setq currentState (if (get this-command 'state) (get this-command 'state) 1))
      (setq fontToUse (nth (1- currentState) font-list))
  
      (set-frame-parameter nil 'font fontToUse)
      (message "Current font is: %s" fontToUse)
      (put this-command 'state (1+ (% currentState (length font-list))))
      (redraw-frame (selected-frame))))
  
  (frame-parameter nil 'font)
#+end_src

* General useful things
** Searching info
   Look for in google
#+begin_src emacs-lisp :tangle yes
  (autoload 'google-search-selection "google_search" "google search" t)
  (autoload 'google-it "google_search" "google search" t)
#+end_src

** Kill ring stuff
   Sometimes the key ring is not easy to manage, we can browse inside it to see what we saved
#+begin_src emacs-lisp :tangle yes
   (require 'browse-kill-ring)
#+end_src

** Translations
*** Org babel
#+begin_src emacs-lisp :tangle yes
  (setq babel-preferred-from-language "German")
  (setq babel-preferred-to-language "English")
  
  (autoload 'babel-region-default "babel" "translating default" t)
  (autoload 'babel-region "babel" "translating a region" t)
  (autoload 'babel "babel" "translating interactively" t)
  (autoload 'babel-buffer "babel" "translate buffer" t)
#+end_src

*** Text translator
#+begin_src emacs-lisp :tangle yes
  (setq text-translator-display-popup t)
  (setq text-translator-default-engine "google.com_deen")
  
  (defun text-translator-region-or-thing-at-point (&optional prompt)
    (interactive)
    "If mark is active, return the region, otherwise, thing at point."
    (cond
     (mark-active
      (buffer-substring-no-properties (region-beginning) (region-end)))
     (t
      (thing-at-point 'symbol ))))
#+end_src

*** Spelling functions
# TODO: make it easier to manage and to scroll through lists of possibilities
#+begin_src emacs-lisp :tangle yes
  (setq ispell-dictionary "american")
  
  ;; TODO: possible to refactor this code maybe?
  (defun en ()
    "Check spelling in english"
     (interactive)
    (ispell-change-dictionary "american")
    (flyspell-mode t))
  
  (defun it ()
    "Check spelling in english"
    (interactive)
    (ispell-change-dictionary "italian")
    (flyspell-mode t))
  
  (defun fr ()
    "Check spelling in english"
    (interactive)
    (ispell-change-dictionary "french")
    (flyspell-mode t))
  
  (defun de ()
    "Check spelling in english"
    (interactive)
    (ispell-change-dictionary "german")
    (flyspell-mode t))
#+end_src

** Dictionary
   Using dictionary.el (downloaded from http://me.in-berlin.de/~myrkr/dictionary/download.html)

#+begin_src emacs-lisp :tangle yes
  ; TODO: add some thing-at-point to guess the current word
  (defun my-dictionary-search ()
    "look for a word here"
    (interactive)
    (let ((word (current-word))
          (enable-recursive-minibuffers t)
          (val))
      (setq val (read-from-minibuffer
                 (concat "Word"
                         (when word
                           (concat " (" word ")"))
                         ": ")))
      (dictionary-new-search
       (cons (cond
              ((and (equal val "") word)
               word)
              ((> (length val) 0)
               val)
              (t
               (error "No word to lookup")))
             dictionary-default-dictionary))))
#+end_src

* Org mode
** Exporting org entries to ical
#+begin_src emacs-lisp :tangle yes
  ;; from http://orgmode.org/worg/org-tutorials/org-google-sync.html#sec-3
  ;;; define categories that should be excluded
  (setq org-export-exclude-category (list "google" "private"))
  
  ;;; define filter. The filter is called on each entry in the agenda.
  ;;; It defines a regexp to search for two timestamps, gets the start
  ;;; and end point of the entry and does a regexp search. It also
  ;;; checks if the category of the entry is in an exclude list and
  ;;; returns either t or nil to skip or include the entry.
  
  (defun org-mycal-export-limit ()
    "Limit the export to items that have a date, time and a range. Also exclude certain categories."
    (setq org-tst-regexp "<\\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\} ... [0-9]\\{2\\}:[0-9]\\{2\\}[^\r\n>]*?\
  \)>")
  
    (setq org-tstr-regexp (concat org-tst-regexp "--?-?" org-tst-regexp))
    (save-excursion
                                          ; get categories
      (setq mycategory (org-get-category))
                                          ; get start and end of tree
      (org-back-to-heading t)
      (setq mystart    (point))
      (org-end-of-subtree)
      (setq myend      (point))
      (goto-char mystart)
                                          ; search for timerange
      (setq myresult (re-search-forward org-tstr-regexp myend t))
                                          ; search for categories to exclude
      (setq mycatp (member mycategory org-export-exclude-category))
                                          ; return t if ok, nil when not ok
      (if (and myresult (not mycatp)) t nil)))
  
  ;;; activate filter and call export function
  (defun org-mycal-export () 
    (let ((org-icalendar-verify-function 'org-mycal-export-limit))
      (org-export-icalendar-combine-agenda-files)))
  
#+end_src

** Contrib directory
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'load-path (make-conf-path "org-mode/contrib/lisp"))
  (require 'org-contacts)
#+end_src

** Setting up what happens when closing a task
#+begin_src emacs-lisp :tangle yes
(setq org-log-done 'note)
#+end_src

** General TODO keywords
   Can be customized per buffer
#+begin_src emacs-lisp :tangle yes
  (setq org-todo-keywords
        '((sequence "TODO(t)" "FEEDBACK(f)" "VERIFY(v)" "|" "DONE(d)" "DELEGATED(D)" "REJECTED(r)")))
#+end_src

** Enforcing TODO dependencies
#+begin_src emacs-lisp :tangle yes
   (setq org-enforce-todo-dependencies t)
   (setq org-enforce-todo-checkbox-dependencies t)
#+end_src
   
** Info configuration
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'Info-default-directory-list (make-conf-path "org-mode/doc/"))
#+end_src

** Clock configuration
#+begin_src emacs-lisp :tangle yes
  ;; Clock configuration
  (setq org-clock-persist t)
  (org-clock-persistence-insinuate)
#+end_src
   
** Check if we are in org-mode
#+begin_src emacs-lisp :tangle yes
  ;; make it like a macro, takes a body and executes it
  (defun check-org-mode ()
    "check if the buffer is in org mode"
    (if
        (eq major-mode 'org-mode)
        t
      (message "this action is possible only in org mode")))
#+end_src

** Add eventually
   This hook enables to expand your KB very easily, every time you create a new org-file it will check if it's already in the agenda and asks to add it.
   Disable this if you don't plan to use org mode and its agenda
#+begin_src emacs-lisp :tangle yes
  ; Not used at the moment
  (defun org-add-eventually()
    "Adding a file to org-agenda when saved"
    (interactive)
    (if
        (org-agenda-is-filtered-p (buffer-file-name))
        (message "filtered out in org-agenda-filter-out, change it to include it again")
      (if 
           (and
            (string= major-mode "org-mode")
            ; TODO: check this condition
            (or (org-agenda-filter-remote-files) (file-remote-p buffer-file-name))
             ;TODO: there should be a function already in org-mode 
            (not (member (abbreviate-file-name buffer-file-name) org-agenda-files)))
           (if
               (yes-or-no-p "add the file to agenda?")
               (org-agenda-file-to-front)))))
  
  
  (defcustom org-agenda-add-eventually-enabled
    nil
    "add interactively enabled or not"
    :type 'boolean)
  
  (defcustom org-agenda-filter-remote-files
    t
    "filter buffers open with tramp-mode"
    :type 'boolean)
  
  (if org-agenda-add-eventually-enabled
      (add-hook 'before-save-hook 'org-add-eventually))
  
  (defcustom org-agenda-filter-out
    '("/Volumes/arch")
    "regexp that are never added to agenda"
    :type 'list)
  
  (defun org-agenda-is-filtered-p (filename)
    (org-agenda-is-filtered-p-rec filename org-agenda-filter-out))
  
  (defun org-agenda-is-filtered-p-rec (filename list)
    (cond
     ((null list) nil)
     ((string-match (car list) (expand-file-name filename)) t)
     (t (org-agenda-is-filtered-p-rec filename (cdr list)))))
#+end_src


*** Org agenda blacklist list
    Having to say "n" every time for a file that we don't want to add to the agenda can be annoying, so every time we say no we call another function.

#+begin_src emacs-lisp :tangle no
  (defun org-agenda-add-to-blacklist ()
    (setq org-agenda-blacklist
          (add-to-list 'org-agenda-blacklist (abbreviate-file-name buffer-file-name)))
    (customize-save-variable org-agenda-blacklist org-agenda-blacklist))
#+end_src

** Org mode for brainstorming
#+begin_src emacs-lisp :tangle yes
  (defcustom org-brainstorm-ideas 10
    "number of brainstorm ideas")
  
  (defun org-brainstorm ()
    "starts a brainstorming of ideas"
    (interactive)
    (save-excursion
      (dotimes (i org-brainstorm-ideas)
        (org-meta-return))))
#+end_src


#+begin_src emacs-lisp :tangle yes
  (setq questions '("Who" "What" "When" "Where" "Why" "How"))
  
  (defun prompt-ideas ()
    (interactive)
    (dolist (q questions)
      (org-meta-return)
      (insert (concat q "?"))))
#+end_src

** Notes
#+begin_src emacs-lisp :tangle yes
  ;; Defining a setup where org-mode takes care of remember notes
  (setq org-directory "~/org/")
  (setq org-default-notes-file (concat org-directory "notes.org"))
#+end_src

** Org babel
#+begin_src emacs-lisp :tangle yes
  ;; TODO: is it possible to use autoload here?
  (require 'ob-ditaa)
  (require 'ob-sh)
  (require 'ob-python)
  (require 'ob-ruby)
  (require 'ob-dot)
#+end_src   

** Export to pdf
#+begin_src emacs-lisp :tangle yes
  ;; TODO: first check if it's installed maybe
  ;;(setq org-latex-to-pdf-process '("texi2dvi -p -b -c -V %f"))
#+end_src

** Conkeror support
   Add something like this to support capturing from conkeror
#+begin_src emacs-lisp :tangle yes
  ;; ;; the 'w' corresponds with the 'w' used before as in:
  ;;   emacsclient \"org-protocol:/capture:/w/  [...]
  ;; (setq org-capture-templates
  ;;   '(
  ;;      ("w" "" entry ;; 'w' for 'org-protocol'
  ;;        (file+headline "www.org" "Notes")
  ;;        "* %^{Title}\n\n  Source: %u, %c\n\n  %i")
  ;;      ;; other templates
  ;; ))
  
  
#+end_src
** Use ebib for my wonderful references
#+begin_src emacs-lisp :tangle yes
  ;; TODO: check if this is really useful and how to autocomplete it
  (org-add-link-type "ebib" 'ebib)
#+end_src

** Refilling somewhere else
#+begin_src emacs-lisp :tangle yes
  '(org-refile-targets (quote (("~/org/gtd.org" :maxlevel . 1) 
                               ("~/org/someday.org" :level . 2))))
#+end_src

** Org functionalities in other modes
#+begin_src emacs-lisp :tangle yes
  (setq org-struct-hooks
        '(message-mode-hook
          mail-mode-hook))
  
  (dolist (hook org-struct-hooks)
    (add-hook hook 'turn-on-orgstruct)
    (add-hook hook 'turn-on-orgtbl))
#+end_src

** Setting org-foonote for other things also
#+begin_src emacs-lisp :tangle yes
   (setq org-footnote-tag-for-non-org-mode-files "*-*-*-*-*-*-*-*-*-*")
#+end_src

* Conkeror support
#+begin_src emacs-lisp :tangle yes
  (setq conkeror-file-path "~/scripts/conkeror")
  
  (when (file-exists-p conkeror-file-path)
    (setq browse-url-browser-function 'browse-url-generic
          browse-url-generic-program conkeror-file-path))
  
#+end_src
* [[http://code.google.com/p/yasnippet/][Yasnippet]]  
#+begin_src emacs-lisp :tangle yes
  (require 'yasnippet)
  (setq yas/root-directory 
        (list(make-conf-path "yasnippet-snippets/")  (make-conf-path "yasnippet-mirror/snippets/")))
    
  ;; Maybe needed to set to fixed for some modes
  (setq yas/indent-line 'auto)
  (yas/initialize)
  (setq yas/ignore-filenames-as-triggers nil)
  
  (mapc 'yas/load-directory yas/root-directory)
  
  ;; don't make backups in the snippet folder, they mess up yasnippet
  (add-to-list 'backup-directory-alist '("/my-snippets/" . "/tmp/"))
  
  ;; simple function to create a .yas-parents
  (defun make-yas-parents-file (path)
    (interactive "DPath: ")
    (find-file (concat path ".yas-parents"))
    (insert "text-mode"))
  
  (defun with-comment (str)
   (format "%s%s%s" comment-start str comment-end))
#+end_src

* Eldoc mode
  Show the documentation of some functions directly in the minibuffer.
#+begin_src emacs-lisp :tangle yes
  (require 'eldoc)
  ;; Maybe better a direct activation??
  (dolist (hook '(ruby-mode-hook
                  lisp-interaction-mode-hook
                  ielm-mode-hook
                  emacs-lisp-mode-hook))
    (add-hook hook 'turn-on-eldoc-mode))
#+end_src

* Auto complete
** Importing all packages
# TODO: add the semantic auto-completion to all modes which use it
   
#+begin_src emacs-lisp :tangle yes
  ;;; Require
  (require 'auto-complete)
  ;; Various configurations
  (require 'auto-complete-config)
  (ac-config-default)
#+end_src  

** Setting up
#+begin_src emacs-lisp :tangle yes
  (setq ac-auto-start 2)                  ;automatically start
  (setq ac-override-local-map nil)        ;don't override local map
  (setq ac-use-menu-map t)
  (setq ac-candidate-limit 20)
  ;; Default settings
  (define-key ac-menu-map "\C-n" 'ac-next)
  (define-key ac-menu-map "\C-p" 'ac-previous)  
  
  ;; making it a bit faster
  (setq ac-delay 5)
  (setq ac-auto-show-menu 0.4)
  (setq ac-quick-help-delay 0.5)
  ;; using a dictionary (emtpy now)
  (add-to-list 'ac-dictionary-directories (make-conf-path "auto-complete/dict"))
#+end_src

** Setting up generic sources
#+begin_src emacs-lisp :tangle yes
  (setq-default ac-sources
                (append ac-sources '(ac-source-yasnippet)))
#+end_src 

** Define allowed modes
#+begin_src emacs-lisp :tangle yes
  (dolist
      (my-ac-mode '(nesc-mode org-mode html-mode xml-mode haskell-mode ned-mode cpp-omnet-mode))
    (add-to-list 'ac-modes my-ac-mode))
  
              
  ; this is used for trigger ac actions from org-mode also
  (add-to-list 'ac-trigger-commands 'org-self-insert-command)
#+end_src

** Elisp configuration
#+begin_src emacs-lisp :tangle yes
;; using a nice function is ac-config
(dolist (hook (list
               'lisp-interaction-mode-hook
               'ielm-mode-hook
               ))
  (add-hook hook 'ac-emacs-lisp-mode-setup))
#+end_src

** Using eclim
#+begin_src emacs-lisp :tangle yes
  (add-hook 'java-mode-hook 
            '(lambda ()
               (add-to-list 'ac-sources 'eclim-complete)))
#+end_src   
* Programmer tools
** Look for a function on google code
#+begin_src emacs-lisp :tangle yes
  ;; TODO: add support for different modes
  (defun look-for-function ()
    (interactive)
    (let ((baseurl "http://www.google.com/codesearch?q=%s"))
      (browse-url (format baseurl (thing-at-point 'symbol) ))))
#+end_src

** Cedet
   See [[http://alexott.net/en/writings/emacs-devenv/EmacsCedet.html][gentle introduction to cedet]] for a nicer tutorial

*** Use cedet and gloabally ede-mode for projects
#+begin_src emacs-lisp :tangle yes
  (load (make-conf-path "cedet/common/cedet"))
  (setq semantic-load-turn-everything-on t)
  (global-ede-mode nil)
  (setq ede-locate-setup-options '(ede-locate-global ede-locate-locate ede-locate-idutils))
#+end_src

*** Activate semantic bindings in some more modes
#+begin_src emacs-lisp :tangle yes
  (dolist 
      (hook '(python-mode-hook c-mode-common-hook emacs-lisp-mode-hook makefile-mode-hook))
    (add-hook hook 'activate-more-semantic-bindings))
#+end_src

*** Options for semantic
#+begin_src emacs-lisp :tangle yes
  (global-semantic-stickyfunc-mode 1)
  ;; (global-semantic-decoration-mode 1)
  (global-semantic-highlight-func-mode 1)
  (global-semantic-highlight-edits-mode 1)
  (global-semantic-idle-scheduler-mode 1)
  (global-semantic-idle-summary-mode 1)
  (global-semantic-mru-bookmark-mode 1)
#+end_src

*** Hook for inline documentation setting local keys
#+begin_src emacs-lisp :tangle yes
  (defun my-c-like-cedet-hook ()
    (local-set-key [(control return)] 'semantic-ia-complete-symbol)
    (local-set-key "\C-c?" 'semantic-ia-complete-symbol-menu)
    (local-set-key "\C-c>" 'semantic-complete-analyze-inline)
    (local-set-key "\C-cj" 'semantic-ia-fast-jump)
    (local-set-key "\C-cq" 'semantic-ia-show-doc)
    (local-set-key "\C-cs" 'semantic-ia-show-summary)
    (local-set-key "\C-cp" 'semantic-analyze-proto-impl-toggle)
    (local-set-key "." 'semantic-complete-self-insert)
    (local-set-key ">" 'semantic-complete-self-insert))
  
  (defun my-cpp-cedet-hook ()
    (local-set-key ":" 'semantic-complete-self-insert))
#+end_src

*** Using semanticdb
#+begin_src emacs-lisp :tangle yes
  (global-semanticdb-minor-mode 1)
  (require 'semanticdb-global)
#+end_src

** Eclim
  Get the power of eclipse right in emacs via [[http://eclim.org/][eclim]]

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'load-path (make-conf-path "emacs-eclim/"))
  ;; only add the vendor path when you want to use the libraries provided with emacs-eclim
  (add-to-list 'load-path (make-conf-path "emacs-eclim/vendor"))
  ;; use it a hook instead with the java mode
  
  ;; TODO: maybe worth using on other modes also
  ;; (add-hook 'java-mode-hook
  ;;           '(lambda ()
  ;;              (require 'eclim)
  
  ;;              (setq eclim-auto-save t)
  ;;              (eclim-mode 1)))
#+end_src
** Tags
*** Etags-select
   This extension to etags helps choosing from equal names of functions.
#+begin_src emacs-lisp :tangle yes
  (require 'etags-select)
#+end_src

*** Etags table to use also in bigger projects
#+begin_src emacs-lisp :tangle yes
   (require 'etags-table)
   (setq etags-table-search-up-depth 1)
#+end_src

*** Gtags
#+begin_src elisp :tangle yes
  (autoload 'gtags-mode "gtags" "gtags mode" t)
#+end_src

  Update or create a new gtag file
#+begin_src emacs-lisp :tangle yes
  (defun my-gtags-create-or-update ()
    "create or update the gnu global tag file"
    (interactive)
    (if (not (= 0 (call-process "global" nil nil nil " -p"))) ; tagfile doesn't exist?
        (when 
            (yes-or-no-p "do you want to enable gtags?")
          (let ((olddir default-directory)
                (topdir (read-directory-name  
                         "gtags: top of source tree:" default-directory)))
            (cd topdir)
            (shell-command "gtags && echo 'created tagfile'")
            (cd olddir)) ; restore   
          ;;  tagfile already exists; update it
          (shell-command "global -u && echo 'updated tagfile'"))))
#+end_src

  Adding a hook to c-mode-common modes
#+begin_src emacs-lisp :tangle no
  (add-hook 'c-mode-common-hook
            (lambda ()
              (require 'gtags)
              (my-gtags-create-or-update)))
  
  ;; same thing for python
  (add-hook 'python-mode-hook
            (lambda ()
              (require 'gtags)
              (my-gtags-create-or-update)))
#+end_src

*** Extending functions
   This functions help to look for the TAGS file in the filesystem when is not in the same working directory
# FIXME: still not working correctly, more iteration is needed here
#+begin_src emacs-lisp :tangle no
  (defun jds-find-tags-file ()
    "recursively searches each parent directory for a file named 'TAGS' and returns the
  path to that file or nil if a tags file is not found. Returns nil if the buffer is
  not visiting a file"
    (progn
      (defun find-tags-file-r (path)
        "find the tags file from the parent directories"
        (let* ((parent (file-name-directory path))
               (possible-tags-file (concat parent "TAGS")))
          (cond
           ((file-exists-p possible-tags-file) (throw 'found-it possible-tags-file))
           ((string= "/TAGS" possible-tags-file) (error "no tags file found"))
           (t (find-tags-file-r (directory-file-name parent))))))
  
      (if (buffer-file-name)
          (catch 'found-it 
            (find-tags-file-r (buffer-file-name)))
        (error "buffer is not visiting a file"))))
  
  (defun jds-set-tags-file-path ()
    "calls `jds-find-tags-file' to recursively search up the directory tree to find
  a file named 'TAGS'. If found, set 'tags-table-list' with that path as an argument
  otherwise raises an error."
    (interactive)
    (setq tags-table-list (list (jds-find-tags-file))))
  
  ;; delay search the TAGS file after open the source file
  (add-hook 'emacs-startup-hook 
            '(lambda () (jds-set-tags-file-path)))
#+end_src

** VC
#+begin_src emacs-lisp :tangle yes
  (setq 
   vc-handled-backends '(Git Hg CVS SVN Bzr)
   ;; always opening the real file instead!
   vc-follow-symlinks t)
#+end_src

*** SVN
#+begin_src emacs-lisp :tangle yes
  (autoload 'svn-status "psvn" "svn status" t)
#+end_src

*** [[http://philjackson.github.com/magit/][Magit]]
   Nice interface for git.
#+begin_src emacs-lisp :tangle yes
  (autoload 'magit-status "magit" "magit" t)
  (setq magit-log-edit-confirm-cancellation t)
  ;; use tty which should be faster, passphrase not allowed here
  (setq magit-process-connection-type nil)
  (setq magit-process-popup-time 10)
  
  (add-hook 'magit-log-edit-mode-hook 'orgtbl-mode)
  (add-hook 'magit-log-edit-mode-hook 'orgstruct-mode)
  (add-hook 'magit-log-edit-mode-hook 'flyspell-mode)
  (add-hook 'magit-log-edit-mode-hook 'auto-fill-mode)
#+end_src

**** Function to enable revert mode when in a git repository
   It's nice to enable auto-revert-mode automatically on files which are surely in a git repository.
   To do this we can simply add a hook to find-file-hook
#+begin_src emacs-lisp :tangle yes
  ;TODO: use  (vc-ensure-vc-buffer) to make it more general
   
  (defun is-version-control-file ()
    "Return nil unless the file is in the git files"
    (if (vc-working-revision (buffer-file-name))
        (auto-revert-mode t)))
  
  (add-hook 'find-file-hook 'is-version-control-file)
#+end_src

* Programming
** Internationalization
   Editing po files
#+begin_src emacs-lisp :tangle yes
  (autoload 'po-mode "po-mode+"
    "Major mode for translators to edit PO files" t)
  
  (add-to-list 'auto-mode-alist
               '("\\.po$" . po-mode))
  
  (add-to-list 'auto-mode-alist
               '("\\.pot$" . po-mode))
  
  
  ;; to automatically find out the coding system
  (modify-coding-system-alist 'file "\\.po\\'\\|\\.po\\."
                              'po-find-file-coding-system)
  (autoload 'po-find-file-coding-system "po-mode")
#+end_src

** To spell mode
   Most of the programming languages we can have syntax checking on the comments and strings.
   Flyspell-prog-mode is just for this
#+begin_src emacs-lisp :tangle yes
  (defcustom to-spell-langs
    '(emacs-lisp-mode-hook python-mode-hook c-mode-common-hook nesc-mode-hook java-mode-hook jde-mode-hook haskell-mode-hook)
    "Set of programming modes for which I want to enable spelling in comments and strings"
    :type 'list)
  
  (dolist (lang-hook to-spell-langs)
    (add-hook  lang-hook 'flyspell-prog-mode))
  
  (require 'auto-complete)
  (ac-flyspell-workaround)
#+end_src

** Web nice utilities
*** Gist
    Use simply *gist-buffer* or *gist-region* to paste code online.
#+begin_src emacs-lisp :tangle yes
    (require 'gist)
#+end_src

*** Lisppast
#+begin_src emacs-lisp :tangle yes
 (autoload 'lisppaste "lisppaste" "lisppaste" t)
#+end_src    
    
** Clojure
   Nice lisp language to work in the java virtual machine without writing java.

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.clj$" . clojure-mode))
  (autoload 'clojure-mode "clojure-mode" "clojure mode" t)
#+end_src

*** Swank configuration for clojure
    We can keep the common lisp also
#+begin_src emacs-lisp :tangle yes
  (autoload 'slime "swank-clojure" "loading the swank-clojure" t)
  (add-hook 'slime-mode-hook
            '(lambda () 
               (add-to-list 'slime-lisp-implementations '(sbcl ("sbcl")))))
#+end_src
  Use "C-u M-x slime sbcl RET" to start sbcl again

** Compilation mode
   This is very useful to remove the compilation buffer if it's successful
#+begin_src emacs-lisp :tangle yes
  (defun kill-compile-buffer-if-successful (buffer string)
    " kill a compilation buffer if succeeded without warnings "
    (if (and
         (string-match "compilation" (buffer-name buffer))
         (string-match "finished" string)
         (not 
          (with-current-buffer buffer
            (search-forward "warning" nil t))))
        (run-with-timer 1 nil
                        'kill-buffer
                        buffer)))
  
  (add-hook 'compilation-finish-functions 'kill-compile-buffer-if-successful)
#+end_src

** Ess
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'load-path (make-conf-path "ess-mirror/lisp"))
  (autoload 'R "ess-site" "loading R env" t)
  (setq ess-directory (expand-file-name "~/"))
  (setq ess-ask-for-ess-directory nil)
#+end_src

** Elisp
#+begin_src emacs-lisp :tangle yes
 (autoload 'paredit-mode "paredit" "paredit mode" t)
 (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
#+end_src

** Mirah
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.mirah$" . ruby-mode))
#+end_src

** C-mode
   Default setting for c-style
#+begin_src emacs-lisp :tangle yes
  (setq c-default-style
        '((java-mode . "java") (awk-mode . "awk") (other . "cc-mode")))
#+end_src

*** Guess the indentation
#+begin_src emacs-lisp :tangle yes
  (autoload 'guess-style-set-variable "guess-style" nil t)
  (autoload 'guess-style-guess-variable "guess-style")
  (autoload 'guess-style-guess-all "guess-style" nil t)
#+end_src

** C++
*** CClookup, look for documentation
#+begin_src emacs-lisp :tangle yes
  (autoload 'cclookup-lookup "cclookup"
    "Lookup SEARCH-TERM in the Python HTML indexes." t)
  
  (autoload 'cclookup-update "cclookup" 
    "Run cclookup-update and create the database at `cclookup-db-file'." t)
  
  (setq cclookup-program (make-conf-path "cclookup/cclookup.py"))
  (setq cclookup-db-file (make-conf-path "cclookup/cclookup.db"))
#+end_src

*** Qt style
#+begin_src emacs-lisp :tangle yes
  (c-add-style "qt-gnu" 
               '("gnu" 
                 (c-access-key .
                               "\\<\\(signals\\|public\\|protected\\|private\\|public slots\\|protected slots\\|private slots\\):")
                 (c-basic-offset . 4)))
#+end_src

*** Auto insert implementation
#+begin_src emacs-lisp :tangle yes
  (autoload 'expand-member-functions "member-functions" "Expand C++ member function declarations" t)
  (add-hook 'c++-mode-hook (lambda () (local-set-key "\C-cm" #'expand-member-functions)))
#+end_src
** Insert headers automatically given the right extension
#+begin_src emacs-lisp :tangle yes
  (defun is-new-file ()
   "Check if it's a new file"
   (not (file-exists-p buffer-file-name)))
  
  (defun my-insert-header ()
    "try to insert the header smartly"
    (when
        (is-new-file)
        (let
            ((snip (find-matching-snippet (file-name-nondirectory (buffer-file-name)))))
          (if
              snip
              (insert-at-startup (cdr snip))))))
  
  (defun find-matching-snippet (filename)
    (assoc-if (lambda (x) (string-match x filename))
                   my-auto-header-conses))
  
  (defun insert-at-startup (snippet)
    "try to expand a snippet at startup"
    (if
        (yes-or-no-p (format "expand snippet %s?" snippet))
        (progn
          (insert snippet)
          ;; add checking
          (yas/expand))))
    
  (defcustom my-auto-header-conses
        '(
          ("setup.py" . "setup")
          ("h$"  . "once")
          ("hpp$" . "once"))
        "snippets to expand per file extension"
        :type 'list)
  
  (add-hook 'find-file-hook 'my-insert-header)
#+end_src

** Python mode
*** Paths and extensions

#+begin_src emacs-lisp :tangle no
  (set-buffer (get-buffer-create "reset_python_test.py"))
  (erase-buffer)
  (when
      (featurep 'python-mode)
    (unload-feature 'python-mode t))
  
  (fundamental-mode)
  (setq py-python-command-args '("-colors" "Linux"))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (load-library (make-conf-path "python-mode/python-mode"))
  (add-to-list 'auto-mode-alist '("\\.py$" . python-mode))
  (add-to-list 'interpreter-mode-alist '("python" . python-mode))
  (autoload 'doctest-mode "doctest-mode" "doc test python mode" t)
#+end_src

*** Enable pymacs and ropemacs
#+begin_src emacs-lisp :tangle yes
    ;; Initialize Pymacs                                                                                           
    (autoload 'pymacs-apply "pymacs")
    (autoload 'pymacs-call "pymacs")
    (autoload 'pymacs-eval "pymacs" nil t)
    (autoload 'pymacs-exec "pymacs" nil t)
    (autoload 'pymacs-load "pymacs" nil t)
    ;; Initialize Rope                                                                                             
  ;;  (pymacs-load "ropemacs" "rope-")
    (setq ropemacs-enable-autoimport t)
    
    ;; now add the source rope
    ;; (add-hook 'python-mode-hook 
    ;;           (lambda ()
    ;;             (set (make-local-variable 'ac-sources)
    ;;                  (append ac-sources '(ac-source-ropemacs))
    ;; )))
    
    ;; (defun my-insert-dot-and-complete (arg)
    ;;   (interactive "p")
    ;;   (self-insert-command arg)
    ;;   (rope-code-assist (py-symbol-near-point))
    ;;   )
    
    ;; (add-hook 'python-mode-hook
    ;;           (lambda () 
    ;;             (local-set-key "." 'my-insert-dot-and-complete)))
#+end_src

** Haskell mode
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.hs$" . haskell-mode))
  (autoload 'haskell-mode "haskell-mode" "haskell mode" t)
  (autoload 'turn-on-haskell-doc-mode "haskell-doc" "haskell doc mode" t)
  (autoload 'turn-on-haskell-indent "haskell-indent" "haskell indent facilities" t)
  
  (autoload 'inf-haskell "inf-haskell" "inf-haskell" t)
  (autoload 'hs-lint "hs-lint" "haskell checker" t)
  
  ;; here some haskell variables
  (setq haskell-doc-show-global-types t)
  (setq haskell-program-name "ghci")
                                          ; where haskell-hoogle is loaded?
  
  ;; enabled to get indentation over if-then-else
  (setq haskell-indent-thenelse 1)
  
  ;; If nothing found pass the control
  (add-hook 'haskell-mode-hook
            '(lambda ()
               (require 'haskell-doc) ; Is this the only way?
               (require 'haskell-indent)
               (require 'haskell-complete)
               (require 'inf-haskell)
               (turn-on-haskell-doc-mode)
               (turn-on-haskell-indentation)
               ;; This would be very nice but it conflicts with yasnippet
               (define-key haskell-mode-map [tab] 'haskell-indent-cycle)
               (define-key haskell-mode-map "\C-ch" 'haskell-hoogle)
               (define-key haskell-mode-map "\C-cl" 'hs-lint)
               (make-variable-buffer-local 'yas/trigger-key)
               (setq yas/trigger-key [tab])
               (define-key yas/keymap [tab] 'yas/next-field)
               (add-to-list 'ac-sources 'my/ac-source-haskell)
               ))
#+end_src

** Prolog
#+begin_src emacs-lisp :tangle yes
  (autoload 'run-prolog "prolog" "Start a Prolog sub-process." t)
  (autoload 'prolog-mode "prolog" "Major mode for editing Prolog programs." t)
  (autoload 'mercury-mode "prolog" "Major mode for editing Mercury programs." t)
  (setq prolog-system 'swi)
  (add-to-list 'auto-mode-alist '("\\.pl$" . prolog-mode))
#+end_src
  
** Nesc
#+begin_src emacs-lisp :tangle yes
  (autoload 'nesc-mode "nesc" nil t)
  (add-to-list 'auto-mode-alist '("\\.nc$" . nesc-mode))
#+end_src

** Omnet++
   NED file syntax, derived from C for syntax and indentation
#+begin_src emacs-lisp :tangle yes
  (autoload 'ned-mode "ned-mode" "Major Mode for editing Ned files" t)
  (add-to-list 'auto-mode-alist '("\\.ned$" . ned-mode))
  
  ;TODO: enable a finer mechanism to let this work
  ;read from http://yasnippet.googlecode.com/svn/trunk/doc/snippet-expansion.html#the-condition-system
#+end_src
   
   Msg file type
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.msg$" . c-mode))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (defun c++-header-file-p ()
    "Return non-nil, if in a C++ header."
    (and (string-match "\\.h$"
                       (or (buffer-file-name)
                           (buffer-name)))
         (save-excursion
           (re-search-forward "\\_<class\\_>" nil t))))
  
  (add-to-list 'magic-mode-alist
               '(c++-header-file-p . c++-mode))
#+end_src

  Try to enable the cpp-omnet-mode automatically when possible
#+begin_src emacs-lisp :tangle yes
  ;;  (add-hook 'c++-mode-hook 'is-omnet-cpp-file)
    ;; (remove-hook 'c++-mode-hook 'is-omnet-cpp-file)
    ;; this means that the variable is set locally
    (make-variable-buffer-local 'changing-to-omnet)
    
    (defun is-omnet-cpp-file ()
      "check if the file is to be considered omnet-mode or not"
      (when 
          (and (or
                (not changing-to-omnet)
                (file-exists-p "omnetpp.ini")
                (search-forward "<omnetpp.h>")))
        (setq changing-to-omnet t)
        (cpp-omnet-mode)
        (setq changing-to-omnet nil)))
#+end_src
  
** Java
*** Jdibug
    We use it without jdee

#+begin_src emacs-lisp :tangle yes
   (setq jdibug-use-jde-source-paths nil)
#+end_src

*** Jdee settings
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'load-path (make-conf-path "jdee/lisp"))
  
  (autoload 'jde-mode "jde" "jde mode" t)
  
  ;; In this way we only load if really necessary
  (add-hook 'jde-mode-hook
            '(lambda ()
               (require 'ecb)
               (setq indent-tabs-mode nil)))
  
  ;; (defun turn-on-font-lock-if-enabled ()
  ;;   "set up to make jdee shut up")
  
  ;; TODO: put some conditional stuff for the different operating systems
  ;; make it more general usage
  (setq jde-jdk-registry
        '(("1.6" . "/System/Library/Frameworks/JavaVM.framework/Versions/1.6/")
          ("1.5" . "/System/Library/Frameworks/JavaVM.framework/Versions/1.5/")
          ("1.3.1" . "/System/Library/Frameworks/JavaVM.framework/Versions/1.3.1/")))
  
  (setq jde-jdk '("1.6" . "/System/Library/Frameworks/JavaVM.framework/Versions/1.6/"))
  
  (setq bsh-jar "/opt/local/share/java/bsh.jar")
#+end_src

** Changelog settings and time
#+begin_src emacs-lisp :tangle yes
  ;; for changelogs
  (setq add-log-always-start-new-record 1)
  (add-hook 'before-save-hook 'time-stamp)
  (setq time-stamp-format "%02d-%02m-%:y, %02H:%02M")
#+end_src

** Doc
*** Doxygen files
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("Doxyfile" . conf-unix-mode))
#+end_src

*** Doxymacs
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'load-path (make-conf-path "doxymacs/lisp"))
  ;; supporting doxymacs and doxymacs font locking
  (add-hook 'c-mode-common-hook 
            '(lambda () 
               (require 'doxymacs)
               (doxymacs-mode t)
               (doxymacs-font-lock)))
  
  (defun doxy-path (basepath classname)
    "convert the class name to the format used by doxygen"
    (concat basepath "doc/html/class_" (un-camelcase-string classname "_") ".html"))
  
  (defun jump-to-doxygen-doc (basepath)
    "jump to the corresponding doxygen page"
    (interactive "D")
    (let
        ((fname (file-name-sans-extension (file-name-nondirectory (buffer-file-name)))))
      (browse-url (doxy-path basepath fname))))
#+end_src

** Applescript mode
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist
               '("\\.applescript$" . applescript-mode))
  (autoload 'applescript-mode "applescript-mode" "mode for applescript files" t)
#+end_src
   
** Lisp
#+begin_src emacs-lisp :tangle yes
   (setq inferior-lisp-program "sbcl")
   (require 'slime)
   (slime-setup)
#+end_src

** Web programming
  Enabling nxhtml mode
#+begin_src emacs-lisp :tangle yes
  (setq nxhtml-menu-mode nil)
#+end_src

#+begin_src emacs-lisp :tangle yes
  (autoload 'mako-html-mumamo-mode "autostart" "auto starting of nxhtml" t)
  ;; add other modes whenever needed
  (add-to-list 'auto-mode-alist '("\\.mak$" . mako-html-mumamo-mode))
  (add-to-list 'auto-mode-alist '("\\.mako$" . mako-html-mumamo-mode))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (setq mumamo-chunk-coloring 3)
#+end_src

** Ocaml
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.ml\\w?" . tuareg-mode))
  (autoload 'tuareg-mode "tuareg" "Major mode for editing Caml code" t)
  (autoload 'camldebug "camldebug" "Run the Caml debugger" t)
#+end_src
   
** Lua
#+begin_src emacs-lisp :tangle yes
  ;; lua mode
  (autoload 'lua-mode "lua-mode" "mode for lua" t)
#+end_src

** Fixme mode
   This is a mode to highlight stuff, adding some more modes
#+begin_src emacs-lisp :tangle yes
  ; TODO: add it globally if possible
  (require 'fixme-mode)
  ; for each of the modes we add it to the hook
  (add-to-list 'fixme-modes 'org-mode)
  (dolist (hook '(python-mode-hook
                  c-mode-common-hook
                  ruby-mode-hook
                  lisp-interaction-mode-hook
                  org-mode-hook
                  haskell-mode-hook
                  emacs-lisp-mode-hook))
    (add-hook hook 'fixme-mode))
#+end_src 

** Ruby mode
*** General settings
#+begin_src emacs-lisp :tangle yes
  (autoload 'ruby-mode "ruby-mode" "Major mode for ruby files" t)
  (add-to-list 'auto-mode-alist '("\\.rb$" . ruby-mode))
  (add-to-list 'interpreter-mode-alist '("ruby" . ruby-mode))
  
  (add-hook 'ruby-mode-hook
            '(lambda ()
               (require 'inf-ruby)
               (require 'ruby-electric)
               (inf-ruby-keys)
               (load-library "rdoc-mode")))
#+end_src

*** Jruby and rinari
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'load-path (make-conf-path "rinari/util"))
#+end_src

** Yaml
#+begin_src emacs-lisp :tangle yes
  (autoload 'yaml-mode "yaml-mode" "mode for yaml" t)
  (add-to-list 'auto-mode-alist
               '("\\.yaml$" . yaml-mode))
  (add-to-list 'auto-mode-alist
               '("\\.yml$" . yaml-mode))
#+end_src

** Go mode
#+begin_src emacs-lisp :tangle yes
  (autoload 'go-mode "go-mode" "go mode" t)
  (add-to-list 'auto-mode-alist
               '("\\.go$" . go-mode))
#+end_src

** [[http://code.djangoproject.com/wiki/Emacs][Django modes]]
   This mode is derived from html and helps writing django templates
#+begin_src emacs-lisp :tangle yes
  (autoload 'django-html-mode "django-html-mode" "mode for django templates" t)
  (add-to-list 'auto-mode-alist
               '("views" . django-html-mode))
#+end_src

** Debugging
*** Setting up GDB to always open right windows
#+begin_src emacs-lisp :tangle yes
   (setq gdb-show-main nil)
   (setq gdb-many-windows t)

#+end_src 

*** Some advices for pdb
#+begin_src emacs-lisp :tangle yes
  (defadvice pdb (before gud-query-cmdline activate)
    "Provide a better default command line when called interactively."
    (interactive
     (list (gud-query-cmdline 'pdb.py
                              (file-name-nondirectory buffer-file-name)))))
#+end_src
* Other modes
** PDF and office documents
#+begin_src emacs-lisp :tangle yes
  (defun ac-doc-view-if-pdf ()
    "Open pdf with doc-view"
    (when (string-match "pdf" (buffer-file-name))
      (doc-view (buffer-file-name))))
  
  (require 'doc-view)
#+end_src

** Writing
   Synonyms
#+begin_src emacs-lisp :tangle yes
  (autoload 'synonyms "synonyms" "thesaurus" t nil)
  (setq synonyms-file (make-conf-path "misc/mthesaur.txt"))
#+end_src

** Autotools facilities
#+begin_src emacs-lisp :tangle yes
  (defun get-autoconf-macro-definition (&optional macro)
    "jump to the definition of a macro"
    (interactive)
    (let
        ((macro (thing-at-point 'symbol)))
        (or
         (get-autoconf-macro-local macro)
         (lookup-in-info "autoconf" macro)
         (lookup-in-info "automake" macro)
         (google-it macro))))
         ;; (progn
         ;;   (message "definition not found")
         ;;   (get-autoconf-macro-definition (read-minibuffer "Look for macro:"))))))
  
  (defun lookup-in-info (section string)
    "lookup string in the given section"
    (info section (format "*%s*<%s>" section string))
    (condition-case nil
        (Info-index string)
      (error nil)))
  
  (defun get-autoconf-macro-local (macro)
    "Look for the definition of the macro in aclocal.m4 before"
    (let
        ((local-macro-file "aclocal.m4"))
      (if (file-exists-p local-macro-file)
          (with-temp-buffer 
            (find-file local-macro-file)
            (condition-case nil
                (search-forward (format "AC_DEFUN([%s])" macro))
              (error nil)))
            nil)))
  
  (add-hook 'autoconf-mode-hook
            (lambda ()
              (local-set-key "\C-j" 'get-autoconf-macro-definition)))
  
  ;; if it's not found try to look for in aclocal.m4 if it exists
#+end_src

** Session mode
   Use a session mode to automate things
#+begin_src emacs-lisp :tangle yes
  (require 'session)
#+end_src   

** Graphviz-dot-mode
#+begin_src emacs-lisp :tangle yes
  (autoload 'dot-mode "graphiz-dot-mode" "graphviz dot mode" t)
#+end_src

** Log4j
#+begin_src emacs-lisp :tangle yes
  (autoload 'log4j-mode "log4j-mode" t)
  (add-to-list 'auto-mode-alist '("\\.log$" . log4j-mode))
#+end_src

** Ledger, accounting mode
#+begin_src emacs-lisp :tangle yes
  (autoload 'ledger-mode "ledger" "ledger mode for accounting" t)
#+end_src

** Finding more conf files
#+begin_src emacs-lisp :tangle yes
;  (add-to-list 'auto-mode-alist '("conf" . conf-mode))
;  (add-to-list 'auto-mode-alist '(".*?rc$" . conf-mode))
#+end_src
* Gpg and keys
  See on [[http://www.emacswiki.org/emacs/AutoEncryption][autoencryption article]] for more information
#+begin_src emacs-lisp :tangle yes
  (require 'epa)
  (epa-file-enable)
#+end_src

* Fetching documentation
** RFC
#+begin_src emacs-lisp :tangle yes
  (setq rfc-url-save-directory "~/rfc")
  (setq rfc-index-url "http://www.ietf.org/iesg/1rfc_index.txt")
  (setq rfc-archive-alist (list (concat rfc-url-save-directory "/rfc.zip")
                                rfc-url-save-directory
                                "http://www.ietf.org/rfc/"))
  (setq rfc-insert-content-url-hook '(rfc-url-save))
  
  (require 'irfc)
  (setq irfc-directory "~/rfcs")
  (add-to-list 'auto-mode-alist
               '("/rfc[0-9]+\\.txt\\'" . irfc-mode))
  
#+end_src

* Latex
** Configuring Auctex
   Auctex is much more powerful than the default latex mode, enabling it using pdf as default mode
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.[tT]e[xX]\\'" . latex-mode))
  (add-to-list 'load-path (make-conf-path "auctex"))
  (autoload 'latex-mode "auctex" "latex mode" t)
  
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq LaTeX-command "latex")
  (setq TeX-PDF-mode t)
  (setq TeX-master nil)
  
  ;; using flyspell also here
  (add-hook 'LaTeX-mode-hook 'turn-on-flyspell)
  ;; make auctex work with reftex
  (setq reftex-plug-into-AUCTeX t)
  
  ;; enable auto-fill-mode always
  (add-hook 'LaTeX-mode-hook 'auto-fill-mode)
  
  (defun ac-reftex-next-label ()
    (interactive)
    (search-forward "label"))
  
  (defun ac-reftex-previous-label ()
    (interactive)
    (search-backward "label"))
  
  ;; set a shortcut to access to labels
  (add-hook 'LaTeX-mode-hook 
            (lambda ()
              (local-set-key (kbd "M-.") 'reftex-goto-label)
              (local-set-key (kbd "M-n") 'ac-reftex-next-label)
              (local-set-key (kbd "M-p") 'ac-reftex-previous-label)))
#+end_src

   Enable preview mode:
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'load-path (make-conf-path "auctex/preview"))
  ;TODO: only require when auctex is loaded maybe 
  (require 'preview)
#+end_src

** Accessing to latex symbols
#+begin_src emacs-lisp :tangle yes
  (setq latex-symbols-file
        (expand-file-name "~/symbols-a4.pdf"))
  
  (defvar latex-command-program
    (cond
     (mac "open")
     (linux "okular"))
    "latex program to execute for viewing pdf")
  
  (defun latex-symbols ()
    "open the latex symbols file"
    (interactive)
    (if (file-exists-p latex-symbols-file)
        (shell-command (concat latex-command-program " " latex-symbols-file))
      (message "file not found")))
#+end_src

** Color code with listings package
#+begin_src emacs-lisp :tangle yes
  ;; requite org-latex so that the following variables are defined
  (require 'org-latex)
  
  ;; require reftex cite for citations
  (require 'reftex-cite)
  (setq reftex-default-bibliography '("cit"))
  
  ;; tell org to use listings
  (setq org-export-latex-listings t)
  
  ;; you must include the listings package
  (add-to-list 'org-export-latex-packages-alist '("" "listings"))
  
  ;; if you want colored source code then you need to include the color package
  (add-to-list 'org-export-latex-packages-alist '("" "color"))
#+end_src

** Correlation mode
#+begin_src emacs-lisp :tangle yes
  (when linux
    (setq TeX-view-program-list '(("Okular" "okular --page %(outpage) %o")))
    (setq TeX-view-program-selection '((output-pdf "Okular"))))
  
  (when mac
    (setq TeX-source-correlate-method 'synctex)
    (setq LaTeX-command "latex -synctex=1"))
  
  (add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
  
  (setq Tex-source-correlate-start-server t)
#+end_src

** Bibtex and open files
#+begin_src emacs-lisp :tangle yes
  ;; code found and adapted from http://www.emacswiki.org/emacs/RefTeX
  ;; Change this to the place where you store all the electronic versions.
  ;; redefine it to the right thing if necessary
  (defvar bibtex-papers-directory
    (expand-file-name  "~/thesis/literature/"))
  
  ;; Translates a BibTeX key into the base filename of the corresponding
  ;; file. Change to suit your conventions.
  ;; Mine is:
  ;; - author1-author2-author3.conferenceYYYY for the key
  ;; - author1-author2-author3_conferenceYYYY.{ps,pdf} for the file
  (defun bibtex-key->base-filename (key)
    (concat bibtex-papers-directory
            (replace-regexp-in-string "\\." "_" key)))
  
  ;; Finds the BibTeX key the point is on.
  ;; You might want to change the regexp if you use other strange characters in the keys.
  (defun bibtex-key-at-point ()
    (let ((chars-in-key "A-Z-a-z0-9_:-\\."))
      (save-excursion
        (buffer-substring-no-properties
         (progn (skip-chars-backward chars-in-key) (point))
         (progn (skip-chars-forward chars-in-key) (point))))))
  
  ;; Opens the appropriate viewer on the electronic version of the paper referenced at point.
  ;; Again, customize to suit your preferences.
  (defun browse-paper-at-point ()
    (interactive)
    (let ((base (bibtex-key->base-filename (bibtex-key-at-point))))
      (cond
       ((file-exists-p (concat base ".pdf"))
        (shell-command (concat "okular " base ".pdf &")))
       ((file-exists-p (concat base ".ps"))
        (shell-command (concat "okular " base ".ps &")))
       (t (message (concat "No electronic version available: " base ".{pdf,ps}"))))))
  
  ;; (global-set-key [S-f6] 'browse-paper-at-point)
  
#+end_src

** [[http://repo.or.cz/w/ebib.git][Ebib, manage a bibtex archive]]

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'load-path (make-conf-path "ebib/src"))
  (autoload 'ebib "ebib" "Ebib, a BibTeX database manager." t)
  (add-to-list 'Info-default-directory-list (make-conf-path "ebib/manual"))
#+end_src

* Communication
** Mail settings
*** General settings for message creation

#+begin_src emacs-lisp :tangle yes
  ;; setting where the mail is coming from
  (setq mail-setup-with-from t)
  
  ;; This is just to enable flyspell in mail-mode
  ;; FIXME: check if this dirty hack is still needed
  (defvar message-signature-separator "^-- *$" "\
      Regexp matching the signature separator.")
#+end_src

*** Setting up gmail smtp server
   Make sure you configure correctly your .authinfo for login and password

#+begin_src emacs-lisp :tangle yes
  (autoload 'smtpmail-send-it "smtpmail")
  ;; rwth server
    
  (if mac
    (setq message-send-mail-function 'message-send-mail-with-mailclient)
    (setq send-mail-function 'smtpmail-send-it))
    
  (setq smtpmail-smtp-server "relay-auth.rwth-aachen.de")
  (setq smtpmail-smtp-service 465)
  (setq smtpmail-debug-info t)
    
#+end_src

*** Setting default sending modality
#+begin_src emacs-lisp :tangle yes
  (setq compose-mail-user-agent-warnings nil)
  ;; message-mode is a superset of mail-mode and nicer to use
  (setq mail-user-agent 'message-user-agent)
#+end_src

** Gnus settings
*** Server settings
   Configuring maildir testing
#+begin_src emacs-lisp :tangle yes
  (setq gnus-select-method
        '(nnimap "gmail"
                 (nnimap-address "imap.gmail.com")
                 (nnir-search-engine imap)
                 (nnimap-stream ssl)))
  
  (setq gnus-message-archive-group "nnimap+gmail:Sent")
  
  (setq gnus-secondary-select-methods
        '((nnimap "rwth"
                (nnimap-address "mailbox.rwth-aachen.de")
                (nnimap-stream ssl))
          (nntp "news.gmane.org")
          ;; Configuration for http://www.eternal-september.org/
          (nntp "eternal"
                (nntp-address "news.eternal-september.org")
                (nntp-port-number 119))
          ;; (nnmaildir "misterbox" (directory "~/mail_clones/andrea_misterbox/"))
  ))
#+end_src

*** Example about splitting
    [[http://efod.se/writings/gnus-and-courier][See article about splitting settings]]

#+begin_src emacs-lisp :tangle yes
  ;; (setq nnimap-split-inbox
  ;;         '("INBOX" ))
  
  ;; (setq nnimap-split-predicate "UNDELETED")
  
  ;; (setq nnimap-split-crosspost nil)
  
  ;; (setq nnimap-split-rule '(("Example" ("INBOX" nnimap-split-fancy)))
  ;;       nnimap-split-fancy 
  ;;       '(| (any "auser@example\\.com" "INBOX.mail")
  ;;        ("X-Spam-Status" "Yes.*" "INBOX.Spamassassined")
  ;;        ("subject" "Backup report" "INBOX.backupreports")
  ;;        ("from" "MAILER-DAEMON@example\\.com" 
  ;;         "INBOX.example.mailer-daemon")
  ;;        (any "myaddr@example.com" "INBOX.mail")
  ;;        "INBOX.mail.unsorted"))
             
  
#+end_src

*** Old messages settings
#+begin_src emacs-lisp :tangle yes
  (setq gnus-large-newsgroup 2000)
  (setq gnus-fetch-old-headers nil)
#+end_src

*** Daemon setting
#+begin_src emacs-lisp :tangle yes
  ;; close idle connections for 30 minutes
;  (gnus-demon-add-handler 'gnus-group-get-new-news 2 t)
;  (gnus-demon-init)
  
#+end_src

*** Group settings
#+begin_src emacs-lisp :tangle yes
 ;; add the topic groups
 (add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
#+end_src

#+begin_src emacs-lisp :tangle no
  (add-hook 'gnus-select-group-hook 'gnus-group-set-timestamp)
  
  (setq gnus-group-line-format "%M\%S\%p\%P\%5y: %(%-40,40g%) %ud\n")
  
  (defun gnus-user-format-function-d (headers)
    (let ((time (gnus-group-timestamp gnus-tmp-group)))
      (if time
          (format-time-string "%b %d  %H:%M" time)
        "")))
  
#+end_src

*** Spell checking
#+begin_src emacs-lisp :tangle yes
  (add-hook 'gnus-select-group-hook
            (lambda ()
              (cond
               ((string-match
                 "^it\\." (gnus-group-real-name gnus-newsgroup-name))
                (if (member "italian" (ispell-valid-dictionary-list))
                    (ispell-change-dictionary "italian")))
               (t
                (ispell-change-dictionary "english")))))
  
  (add-hook 'message-setup-hook (lambda () (flyspell-mode t)))
#+end_src

*** Summary settings
#+begin_src emacs-lisp :tangle yes
  ;; add an additional window buffer with the tree
  (setq gnus-use-trees t
        gnus-generate-tree-function 'gnus-generate-horizontal-tree
        gnus-tree-minimize-window nil)
  (gnus-add-configuration
   '(article
     (vertical 1.0
               (horizontal 0.25
                           (summary 0.75 point)
                           (tree 1.0))
               (article 1.0))))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (setq gnus-thread-hide-subtree 'gnus-article-unread-p)
#+end_src

*** Posting styles
#+begin_src emacs-lisp :tangle yes
  (setq gnus-posting-styles
        '((".*"
           (name "Andrea Crotti")
           (address "andrea.crotti.0@gmail.com"))
          (".*rwth.*"
           (address "andrea.crotti@rwth-aachen.de"))
          ("emacs"
           (signature (emacs-version)))))
#+end_src

*** Appearance
#+begin_src emacs-lisp :tangle yes
  ;; Changing modeline to include also the date of the message
  (setq gnus-summary-line-format "%U%R%z%I%(%[%4L: %-23,23f%]%) %s--%d\n")
#+end_src

#+begin_src emacs-lisp :tangle yes
  ;; enable smileys
  (setq gnus-treat-display-smileys t)
#+end_src

*** Window configuration
#+begin_src emacs-lisp :tangle yes
  (gnus-add-configuration
   '(article
     (horizontal 1.0
                 (vertical 70 (group 1.0))
                 (vertical 1.0
                           (summary 0.3 point)
                           (article 1.0)))))
  
  (gnus-add-configuration
   '(summary
     (horizontal 1.0
                 (vertical 70 (group 1.0))
                 (vertical 1.0 (summary 1.0 point)))))
#+end_src

*** Avoid the annoying saving of the .news file
#+begin_src emacs-lisp :tangle yes
  (add-hook 'gnus-started-hook
            (lambda ()
              (when (buffer-live-p gnus-dribble-buffer)
                (with-current-buffer gnus-dribble-buffer
                  (setq buffer-save-without-query t)))))
#+end_src

*** Gnus synchronization
#+begin_src emacs-lisp :tangle yes
  (setq my-gnussync-remote "thesis")
  (setq my-gnussync-rsync-binary "/opt/local/bin/rsync")
  (setq my-gnussync-rsync-options "-auRvzp --delete")
  (setq my-gnussync-extra-files nil)
  
  (setq my-gnussync-files "~/News ~/Mail .newsrc .newsrc.eld")
  
  (defun gnussync-to-remote ()
    (format "%s %s %s %s:" my-gnussync-rsync-binary my-gnussync-rsync-options my-gnussync-files my-gnussync-remote))
  
  (defun gnussync-from-remote ()
    (format "%s %s %s:'%s' ~/" my-gnussync-rsync-binary my-gnussync-rsync-options my-gnussync-remote my-gnussync-files))
  
  (defun my-gnussync (direction)
    "Synchronize to or from the server"
    (interactive "Sdirection:")
    (let 
        ((bufname (get-buffer-create "*GNUS SYNC*"))
         (command 
          (cond
           ((eq direction 'to-remote) (gnussync-to-remote))
           ((eq direction 'from-remote) (gnussync-from-remote)))))
      (cd "~")
      (when (y-or-n-p (format "running command %s" command))
        (switch-to-buffer bufname)
        (shell-command command bufname))))
  
  ;; this variable has to be set globally somewhere else
  (when (boundp 'local-machine-is-gnus-slave)
    (add-hook 'gnus-before-startup-hook (lambda () (my-gnussync 'from-remote)))
    (add-hook 'gnus-after-exiting-gnus-hook (lambda () (my-gnussync 'to-remote))))
  
#+end_src

** Erc
*** Accessory functions
#+begin_src emacs-lisp :tangle yes
  ;; This is an example of how to make a new command.  Type "/uptime" to
  ;; use it.
  (defun erc-cmd-UPTIME (&rest ignore)
    "Display the uptime of the system, as well as some load-related
       stuff, to the current ERC buffer."
    (let ((uname-output
           (replace-regexp-in-string
            ", load average: " "] {Load average} ["
            ;; Collapse spaces, remove
            (replace-regexp-in-string
             " +" " "
             ;; Remove beginning and trailing whitespace
             (replace-regexp-in-string
              "^ +\\|[ \n]+$" ""
              (shell-command-to-string "uptime"))))))
      (erc-send-message
       (concat "{Uptime} [" uname-output "]"))))
#+end_src

*** Functions to connect to useful servers
#+begin_src emacs-lisp :tangle yes
  ;; Join the #emacs and #erc channels whenever connecting to Freenode.
  (setq erc-autojoin-channels-alist
        '(("freenode.net"
           "#emacs" "#erc" "#ruby-lang" 
           "#python" "#git" "#github"
           "#c" "#c++" "#conkeror"
           "#org-mode" "#android" "#latex"
           "#org-mode" "#postfix" "#procmail"
           "#scipy" "#haskell" "#macosx")))
  
  ;; highlight in the modeline only when my nick is cited
  (setq erc-current-nick-highlight-type 'nick)
  
  ;; enable logging (by default logs everything to ~/log
  (setq erc-log-mode t)
#+end_src

*** Replace text of away/online messages
#+begin_src emacs-lisp :tangle yes
  (erc-replace-mode t)
  (setq erc-replace-alist
        '(("\\*.*? has changed.*?to \\+v \\(\\w+\\)" . "\\1 is online")
          ("\\*.*? has changed.*?to \\-v \\(\\w+\\)" . "\\1 is away")))
#+end_src
  
*** Set some more interesting variables
#+begin_src emacs-lisp :tangle yes
  ;; Interpret mIRC-style color commands in IRC chats
  (setq erc-interpret-mirc-color t)
  
  ;; ignore the useless messages
  (setq erc-hide-list '("JOIN" "PART" "QUIT"))
  
  (autoload 'erc-nicklist "erc-nicklist" "erc nicklist" t)
#+end_src

* General settings
** Mode for startup
#+begin_src emacs-lisp :tangle yes
  (setq initial-major-mode 'emacs-lisp-mode)
#+end_src

** Backup mode customization
#+begin_src emacs-lisp :tangle yes
  (setq
   backup-by-copying t      ; don't clobber symlinks
   backup-directory-alist '(("." . "~/.saves"))    ; don't litter my fs tree
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t)       ; use versioned backups
#+end_src

** Showing more things
#+begin_src emacs-lisp :tangle yes
  (display-time-mode 1)
  (transient-mark-mode 1)
  (setq inhibit-startup-message t)
  (setq initial-scratch-message nil)
  
  (show-paren-mode t)
  (column-number-mode t)
  ;; always truncate lines (useful for netbook), not working yet in ORG MODE
  (setq truncate-lines nil)
  ;; Setting indent-tabs-mode for only spaces
  (setq-default indent-tabs-mode nil)
#+end_src

** Tramp
#+begin_src emacs-lisp :tangle yes
  (require 'tramp)
  ;; this variable is needed there for some reasons
  (setq warning-suppress-types nil)
  (require 'tramp-adb)
#+end_src

** IDO mode
#+begin_src emacs-lisp :tangle yes
  (require 'ido)
  (ido-mode t)
  ;; otherwise it will try to connect to old servers all the time
  (setq ido-enable-tramp-completion t)
  
                                          ;TODO: those could be hard to grasp for a beginner, should make it customizable 
  (setq ido-enable-flex-matching t)
  ;; regexp matching also
  (setq ido-enable-regexp nil)
  (setq ido-use-url-at-point t)
  (setq ido-create-new-buffer 'always)
  (setq ido-use-filename-at-point 'guess)
  (ido-everywhere t)
  (setq ido-default-buffer-method 'selected-window)
  
  ;;  (add-to-list ido-ignore-buffers "\\` ")
  
  ;; Using ido-mode hacks for advising more functions
  ;; (require 'ido-hacks)
  ;; (ido-hacks-mode t)
  
#+end_src

** Windmove
#+begin_src emacs-lisp :tangle yes
  (defcustom windmove-key
    'shift
    "key for moving between windows"
    :type 'symbol)
  
  (windmove-default-keybindings windmove-key)
#+end_src

** Workarounds
   Compiling on emacs 23.2 often gives some strange errors, this is to avoid them
#+begin_src emacs-lisp :tangle yes
  (setq warning-suppress-types nil)
#+end_src

** Calendar setting
#+begin_src emacs-lisp :tangle yes
   (setq calendar-date-style 'european)
#+end_src

* Process management
** Comint
   Make sure we don't incidentally close a process
#+begin_src emacs-lisp :tangle yes
  (defadvice comint-send-eof (around warn-me-please compile activate)
    "Confirm EOF when called interactively, because accidental EOF sucks."
    (when (or (not (member this-command '(comint-send-eof
                                          comint-delchar-or-maybe-eof)))
              (y-or-n-p "Really exit? "))
      ad-do-it))
#+end_src

* Flymake
** Setting up flymake
#+begin_src emacs-lisp :tangle yes
  (require 'flymake)
     
  (defun activate-flymake ()
    "Activates flymake when real buffer and you have write access"
    (if (and
         (buffer-file-name)
         (file-writable-p buffer-file-name))
        (progn 
          (flymake-mode t)
          ;; this is necessary since there is no flymake-mode-hook...
          (local-set-key [f3] 'flymake-goto-prev-error)
          (local-set-key [f4] 'flymake-goto-prev-error))))
#+end_src

** Adding errors to modeline
   With this the error output of othe current line will appear right below in the modeline
#+begin_src emacs-lisp :tangle yes
(defun my-flymake-show-help ()
  (when (get-char-property (point) 'flymake-overlay)
    (let ((help (get-char-property (point) 'help-echo)))
      (if help (message "%s" help)))))

(add-hook 'post-command-hook 'my-flymake-show-help)
#+end_src

** Flymake for python
   We check the errors given by 3 different programs:
   - epylint (which runs pylint and make it more parsable)
   - pyflakes
   - pep8

   The errors or warnings appear right in the source code.
   
#+begin_src emacs-lisp :tangle yes
  (defun flymake-python-init () 
    (let* ((temp-file (flymake-init-create-temp-buffer-copy 
                       'flymake-create-temp-inplace)) 
           (local-file (file-relative-name 
                        temp-file 
                        (file-name-directory buffer-file-name)))) 
      (list "pycheckers" (list local-file))))
  
  (add-to-list 'flymake-allowed-file-name-masks 
               '("\\.py\\'" flymake-python-init))
  
  ;; (setq flymake-py-script-position (make-conf-path "flymake-python/pyflymake.py"))
  ;; (require 'flymake-python)
  
#+end_src

** Flymake in Automake projects
   Add the following to "file.mk" and add "include file.mk" in your *Makefile.am*
#+begin_src makefile
  get_cs_flags = $(foreach target,$(subst .,_,$(subst -,_,$($(2)))),$($(target)_$(1)FLAGS))
  get_cs_all_flags = $(foreach type,$(2),$(call get_cs_flags,$(1),$(type)))
  get_cs_compile = $(if $(subst C,,$(1)),$($(1)COMPILE),$(COMPILE))
  get_cs_cmdline = $(call get_cs_compile,$(1)) $(call get_cs_all_flags,$(1),check_PROGRAMS bin_PROGRAMS lib_LTLIBRARIES) -fsyntax-only
  
  check-syntax:
          s=$(suffix $(CHK_SOURCES));\
          if   [ "$$s" = ".c"   ]; then $(call get_cs_cmdline,C)   $(CHK_SOURCES);\
          elif [ "$$s" = ".cpp" ]; then $(call get_cs_cmdline,CXX) $(CHK_SOURCES);\
          else exit 1; fi
  
  .PHONY: check-syntax
#+end_src

** Flymake in Make projects
   Add this to your makefile
#+begin_src makefile
.PHONY: check-syntax
check-syntax:
	$(CXX) -Wall -Wextra -pedantic -fsyntax-only $(CHK_SOURCES)
#+end_src

* As as server
  This will start the server for the GUI version of emacs, make sure you set up correctly the emacsclient, for example on osx. (you might even start it automatically with launchtctl)
#+begin_src sh
  alias emacsclient='/Applications/Emacs.app/Contents/MacOS/bin/emacsclient'
  # and then setup your $EDITOR to emacsclient...
#+end_src

#+begin_src emacs-lisp :tangle yes
  (if window-system
      (progn
        (require 'server)
        (if
            (not (server-running-p))
            (server-start)
          (message "server already running, check your emacser"))))
#+end_src
  
* Fun
** Fortune settings
#+begin_src emacs-lisp :tangle yes
;; TODO: make it a defcustom also 
(setq fortune-dir "/opt/local/share/games/fortune/")
#+end_src

** Use spotlight for locating
#+begin_src emacs-lisp :tangle yes
  (defun spotlight ()
    "locate with spotlight facility"
    (interactive)
    (let ((locate-command "mdfind"))
      (call-interactively 'locate nil)))
#+end_src

** Run applescript commands
#+begin_src emacs-lisp :tangle yes
  (defun do-applescript (str)
    "Synchronously run applescript STR."
    (with-temp-buffer
      (insert str)
      (shell-command-on-region (point-min) (point-max) "osascript" nil t)
      (buffer-string)))
#+end_src

** Open the terminal
#+begin_src emacs-lisp :tangle yes
  (defun mac-open-terminal ()
    (interactive)
    (let ((dir ""))
      (cond
       ((and (local-variable-p 'dired-directory) dired-directory)
        (setq dir dired-directory))
       ((stringp (buffer-file-name))
        (setq dir (file-name-directory (buffer-file-name))))
       )
      (do-applescript
       (format "
  tell application \"Terminal\"
    activate
    try
      do script with command \"cd %s\"
    on error
      beep
    end try
  end tell" dir))))
  
#+end_src

** Growl popup
   This function can be pretty nice during presentations, it will popup the last pressed key via growl.
#+begin_src emacs-lisp :tangle yes
  (defun growl-popup (msg)
    "Pop up a growl notification with MSG, or display an Emacs message.
  The \"growlnotify\" program is used if `window-system' is non-nil and
  the program is found in `exec-path'; otherwise `message' is used."
    (interactive)
    (if (and window-system (executable-find "growlnotify"))
        (shell-command (concat "growlnotify -a /Applications/Emacs.app/ -m "
                               (shell-quote-argument msg)))
      (message msg)))
  
  (defun popup-last ()
    (interactive)
    (let
        ((last-key (key-description (this-command-keys))))
      ;; check if we don't have a "stupid" sequence
      (unless
          (= (length (this-command-keys-vector)) 1)
          (growl-popup last-key))))
#+end_src

  Now we also create two other functions to enable and disable it
#+begin_src emacs-lisp :tangle yes
  ;TODO: make it an external package and better a minor-mode, switching would also be much easier
   
  (setq growl-mode nil)
  
  (defun growl ()
    (interactive)
    (if (not growl-mode)
        (progn
          (message "enabling growl mode notification")
          (add-hook 'pre-command-hook 'popup-last)
          (setq growl-mode t))
      (progn
        (setq-default pre-command-hook (remq 'popup-last pre-command-hook))
        (message "disabling growl mode notification")
        (setq growl-mode nil))))
#+end_src

** Open port file
#+begin_src emacs-lisp :tangle yes
  ;; Using the right mode for portfiles
  (add-to-list 'auto-mode-alist '("Portfile" . tcl-mode))
  
  ;; TODO: ask for password
  ;; Taken from http://github.com/febeling/emacsd/blob/master/init.el
  (defun port-open (name)
    "Open the portfile for named MacPorts port."
    (interactive "MPort: ")
    (let ((path (substring (shell-command-to-string (format "port file %s" name)) 0 -1)))
      (if (file-exists-p path)
          (find-file-root path))))
  
#+end_src
      
** Change volume on linux
#+begin_src emacs-lisp :tangle yes
  (when linux
    (progn 
      (defun vol-down ()
        (interactive)
        (shell-command "amixer -c 0 set PCM 3%- >/dev/null"))
  
      (defun vol-up ()
        (interactive)
        (shell-command "amixer -c 0 set PCM 3%+ >/dev/null"))))
  
#+end_src

* Presentation mode
  Mode used to enable for presenting emacs power
#+begin_src emacs-lisp :tangle yes
  (defun presentation-mode ()
    "what to enable in a presentation mode"
    ;TODO: also add a function to cancel all this changes 
    (interactive)
    (growl)
    (color-theme-high-contrast)
    (global-semantic-decoration-mode -1)
    (global-semantic-idle-summary-mode -1)
    (add-hook 'python-mode-hook (function activate-flymake)))
#+end_src

* Global keys settings
#+begin_src emacs-lisp :tangle yes
  ;; compile facilities
  (global-set-key [f5] 'recompile)
  
  ;; newline like textmate
  (global-set-key (kbd "M-RET") 'newline-force)
  (global-set-key [M-S-return] 'newline-force-close)
  
  ;; cvs stuff
  (global-set-key "\C-xg" 'magit-status)
  
  ;; some nice global keys
  (global-set-key "\C-cr" 'org-capture)
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-c\C-x\C-o" 'org-clock-out)
  (global-set-key "\C-c\C-x\C-i" 'org-clock-in)
  
  ;; session setting, jump to the last changed thing in the buffer
  ;; session.el package has to be loaded
  (global-set-key "\C-x\C-j" 'session-jump-to-last-change)
  
  ;; overriding defualt not so smart visualization
  (global-set-key "\C-x\C-b" 'ibuffer)
  
  ;; visualization
  (global-set-key [f11] 'full)
  
  ;; window management keys
  (defun sensibly ()
    "split sensibly the selected window"
    (interactive)
    (split-window-sensibly (selected-window)))
  
  (global-set-key [f2] 'sensibly)
  (global-set-key [f1] 'delete-window)
  
  (global-set-key (kbd "<C-f9>") 'cycle-font)
  
  (global-set-key (kbd "M-<left>") 'other-frame)
  (global-set-key (kbd "M-<right>") 'other-frame)
  
  
  (global-set-key [(meta shift l)] 'select-line)
  
  (global-set-key [f7] 'browse-paper-at-point)
  
  (global-set-key (kbd "M-z") 'undo)
  ;; from here
  (global-set-key "\C-x\C-p" 'find-file-at-point)
  
  ;; make shift-TAB works correctly also on osx
  (when mac
    (define-key (keymap-parent local-function-key-map) [S-tab] nil)
    (global-set-key [S-tab] #'tab-to-tab-stop))
  
  (defun ac-lock-screen ()
    (interactive)
    (shell-command "xlock"))
  
  (when linux
    (global-set-key (kbd "<kp-add>") 'vol-up)
    (global-set-key (kbd "<kp-subtract>") 'vol-down)
    (global-set-key [f12] 'ac-lock-screen))
  
  (setq ac-issue-regexp "\\(FIXME\\|TODO\\)")
  
  (defun ac-next-issue ()
    (interactive)
    (re-search-forward ac-issue-regexp))
  
  (defun ac-previous-issue ()
    (interactive)
    (re-search-backward ac-issue-regexp))
  
  (global-set-key (kbd "C-M-n") 'fixme-next)
  (global-set-key (kbd "C-M-p") 'fixme-prev)
#+end_src

* External configuration files
  Some packages use to store their configuration in external files and not in elisp code.
  For example:
  - gnus:
    + ~/.newsrc
    + ~/.newsrc-dribble (an open buffer saving actual status)
    + ~/News (all the message fetched and so on)

  - javadoc-help
    + ~/.javadoc-help (configuration about the sdks)
      
