#+OPTIONS: num:nil todo:nil H:2
MINIMAL EMACS CONFIGURATION
* DONE See if it's possible to have python auto completion without ropemacs
  CLOSED: [2010-05-09 Dom 14:24]
* DONE Write a function that setups all the possible paths automatically
  CLOSED: [2010-05-04 Mar 11:41]
* TODO Make the table of software versions regenerating every time
* DONE See if it's worthy to byte compile everything or not
  CLOSED: [2010-05-24 Lun 14:01]
  - CLOSING NOTE [2010-05-24 Lun 14:01] \\
    Solved nicely with byte-compile-cache, some cases it could not work
* TODO Write a dependency tree of the various chapters in the configuration

* TODO Add options to create encrypted org-files for storing password and more delicate informations
* TODO Define *defcustom* stuff instead of constants for setting up variables
* TODO Understand why sometimes auto-complete disables by itself

* Assumptions
  - $HOME/.emacs.d/scripts is in the $PATH
  - flymake is installed (distributed with emacs 23 also)
  - in general probably working only with emacs 23

  All the other libraries configured here are always included in the standard distribution or in *conf*.

* Things not working in emacs 22
  - autoload stuff from ORG-clock
  - remember mode (not present)

* Dependencies                                                     :noexport:
# insert the dependencies
#+begin_src dot :file dependecy.pdf :cmdline -Tpdf :exports none :results silent
  digraph dep {
          elib -> jdee;
          cedet -> jdee;
          apel -> elscreen;
  }
#+end_src
  
  [[file:dependecy.pdf]]

* Private settings
** Private
   In this file you can store your own personal settings

#+begin_src emacs-lisp :tangle yes
  ;; not complain if not existing
  (if (file-exists-p "private.el")
      (load-file "private.el"))
#+end_src

** Custom settings
#+begin_src emacs-lisp :tangle yes
   (setq custom-file (concat base "custom.el"))
#+end_src

* Prerequisites
** Constants and some global settings
#+begin_src emacs-lisp :tangle yes
(defconst default-closing-char ";"
  "default closing char, change in newline-force-close-alist if needed")

(setq newline-force-close-alist
  '((python-mode . ":")
    (prolog-mode . ".")
    (latex-mode . " \\\\")
    (org-mode . " \\\\")
    (tuareg-mode . ";;")
    (html-mode . " <br>")))

#+end_src

** Some useful functions
   We suppose that the global variable *conf* has been already set from the outside.

*** Make path
#+begin_src emacs-lisp :tangle yes
  (defun make-path (path)
    (concat conf path))
#+end_src

*** Make fortune
    Print below a fortune cookie if the command is present in the system.

#+begin_src emacs-lisp :tangle yes
  (defun make-fortune ()
  (interactive)
  (let ((beg (point)))
    (insert (shell-command-to-string "fortune"))
    (end-of-paragraph-text)))
#+end_src
 
*** Gen path dirs
   All all the directories in the first level of the configuration directory to the load path.

#+begin_src emacs-lisp :tangle yes
  ;; TODO: make it more general
  (defun gen-path-dirs ()
    "Add to load path all the subdirectories of first level"
    (interactive)
    (message "adding all directories in the first level to the load-path")
    (dolist (dir (directory-files conf t))
      (if (and 
           (file-directory-p dir)
           (not (file-symlink-p dir)))
          (add-to-list 'load-path dir))))
  
  (gen-path-dirs)
#+end_src

*** Google map it
   Search an address in google map
#+begin_src emacs-lisp :tangle yes
  (defun google-map-it (address)
    "get the map of the given address"
    (interactive "sSearch for: ")
    (let
        ((base "http://maps.google.it/maps?q=%s"))
      (browse-url (format base (url-hexify-string address)))))
#+end_src   

*** New line
   Those functions are inspired by textmate
#+begin_src emacs-lisp :tangle yes
  ;; My own functions
  (defun newline-force()
    "Goes to newline leaving untouched the rest of the line"
    (interactive)
    (progn
      (end-of-line)
      (newline-and-indent)))
  
  (defun newline-force-close()
    (interactive)
    (end-of-line)
    (let ((closing-way (assoc major-mode newline-force-close-alist))
          closing-char)
      ;; Setting the user defined or the constant if not found
      (if (not closing-way)
          (progn
            (message "closing char not defined for this mode, using default")
            (setq closing-char default-closing-char))
        (setq closing-char (cdr closing-way)))
      (when (not (bobp))
        ;; if we're at beginning of buffer, the backward-char will beep
        ;; :( This works even in the case of narrowing (e.g. we don't
        ;; look outside of the narrowed area.
        (when (not (looking-at closing-char))
          (insert closing-char))
        (newline-force))))
#+end_src

*** Error switch
    Useful function to toogle on and off the debug mode
#+begin_src emacs-lisp :tangle yes
  (defun err-switch()
    "switch on/off error debugging"
    (interactive)
    (if debug-on-error
        (setq debug-on-error nil)
      (setq debug-on-error t)))
#+end_src

*** Swap windows
#+begin_src emacs-lisp :tangle yes
  ;; someday might want to rotate windows if more than 2 of them
  (defun swap-windows ()
    "If you have 2 windows, it swaps them." (interactive) (cond ((not (= (count-windows) 2)) (message "You need exactly 2 windows to do this."))
                                                                (t
                                                                 (let* ((w1 (first (window-list)))
                                                                        (w2 (second (window-list)))
                                                                        (b1 (window-buffer w1))
                                                                        (b2 (window-buffer w2))
                                                                        (s1 (window-start w1))
                                                                        (s2 (window-start w2)))
                                                                   (set-window-buffer w1 b2)
                                                                   (set-window-buffer w2 b1)
                                                                   (set-window-start w1 s2)
                                                                   (set-window-start w2 s1)))))
#+end_src

*** Rename file and buffer
**** TODO Add something VCS related for moving away files
#+begin_src emacs-lisp :tangle yes
  (defun rename-file-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME." (interactive "sNew name: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not filename)
          (message "Buffer '%s' is not visiting a file!" name)
        (if (get-buffer new-name)
            (message "A buffer named '%s' already exists!" new-name)
          (progn   (rename-file name new-name 1)   (rename-buffer new-name)        (set-visited-file-name new-name)        (set-buffer-modified-p nil)))))) ;;
#+end_src

*** Move buffer file
#+begin_src emacs-lisp :tangle yes
  (defun move-buffer-file (dir)
    "Moves both current buffer and file it's visiting to DIR." (interactive "DNew directory: ")
    (let* ((name (buffer-name))
           (filename (buffer-file-name))
           (dir
            (if (string-match dir "\\(?:/\\|\\\\)$")
                (substring dir 0 -1) dir))
           (newname (concat dir "/" name)))
  
      (if (not filename)
          (message "Buffer '%s' is not visiting a file!" name)
        (progn         (copy-file filename newname 1)  (delete-file filename)  (set-visited-file-name newname)         (set-buffer-modified-p nil)     t))))
#+end_src

*** Delete current file
#+begin_src emacs-lisp :tangle yes
  (defun delete-current-file () 
    "Delete the file associated with the current buffer." 
    (interactive) 
    (let (currentFile) 
      (setq currentFile (buffer-file-name)) 
      (when (yes-or-no-p (format "Delete file % s and kill buffer? " currentFile)) 
        (kill-buffer (current-buffer)) 
        (delete-file currentFile) 
        (message "Deleted file: %s " currentFile))))
#+end_src

*** Open git files
    Run *git ls-files* and visits all the buffer given from it

#+begin_src emacs-lisp :tangle yes
  (defun open-git-files ()
    "Visit all the files in the current git project"
    (interactive)
    (dolist
        (file (split-string (shell-command-to-string "git ls-files")))
      (message "Opening %s" file)
      (find-file file)))
#+end_src

** Reload this configuration
#+begin_src emacs-lisp :tangle yes
  (defun reload-conf ()
    (interactive)
    (org-babel-load-file "miniconf.org"))
#+end_src
    
* Font settings
  Defininig some nice fonts and how to switch between theme.
  [[http://xahlee.org/emacs/emacs_unicode_fonts.html][Cycling function definition]]
#+begin_src emacs-lisp :tangle yes
  (setq current "monaco-12")
  (setq font-list
        (list "monaco-12" "inconsolata-14" "courier-13"))
  
  (defun cycle-font ()
    "Change font in current frame"
    (interactive)
  
    (let (fontToUse currentState)
      ;; states starts from 1.
      (setq currentState (if (get this-command 'state) (get this-command 'state) 1))
      (setq fontToUse (nth (1- currentState) font-list))
  
      (set-frame-parameter nil 'font fontToUse)
      (message "Current font is: %s" fontToUse)
      (put this-command 'state (1+ (% currentState (length font-list))))
      (redraw-frame (selected-frame))
      )
    )
  
  (global-set-key (kbd "<C-f9>") 'cycle-font)
#+end_src

* Operating system detection
#+begin_src emacs-lisp :tangle yes
(defconst linux (string-match "linux" system-configuration))
(defconst mac (string-match "apple" system-configuration))
(defconst win (string-match "win" system-configuration))
#+end_src

** Mac configuration
    This will setup the Command key ot be used as meta.
    I also add the path normally used for macports to the exec-path.
#+begin_src emacs-lisp :tangle yes
  (if mac
      (progn
        (add-to-list 'exec-path "/opt/local/bin")
        (setq ns-alternate-modifier (quote none))
        (setq ns-command-modifier (quote meta))))
#+end_src
* Buffer management
  See also [[http://scottfrazersblog.blogspot.com/2010/01/emacs-filtered-buffer-switching.html][this nice article]] for a better filtering of buffers while switching.

** TempBuf
   TempBuf will automatically kill some of the normally useless buffers
#+begin_src emacs-lisp :tangle yes
  (require 'tempbuf)
  
  ;; Enabling tempbuf mode for some kind of buffers
  (add-hook 'dired-mode-hook 'turn-on-tempbuf-mode)
  (add-hook 'custom-mode-hook 'turn-on-tempbuf-mode)
  (add-hook 'w3-mode-hook 'turn-on-tempbuf-mode)
  (add-hook 'Man-mode-hook 'turn-on-tempbuf-mode)
  (add-hook 'view-mode-hook 'turn-on-tempbuf-mode)
#+end_src

** Uniquify
   Uniquify is used to distinguish easily from buffers with the same name.
#+begin_src emacs-lisp :tangle yes
  ;; Using uniquify for better handling of buffers with same name
  (require 'uniquify)
  ;; Using part of the directory in this case
  (setq uniquify-buffer-name-style 'forward)
#+end_src   

** Other nice packages
#+begin_src emacs-lisp :tangle yes
   ;; it will remember where were you in the buffer
   (require 'saveplace)
#+end_src   

** Minibuffer nice stuff
#+begin_src emacs-lisp :tangle yes
  (setq visible-bell t) ; Turn beep off
  (savehist-mode t) ; save also minibuffer history, very useful
#+end_src

* Package management
  Auto install is a nice way to install packages from emacswiki repository.
#+begin_src emacs-lisp :tangle yes
  ; Other autoloads
  (autoload 'auto-install-from-emacswiki "auto-install" "auto install from emacswiki" t)
  (setq auto-install-directory (concat conf "auto-install/"))
#+end_src

** Byte compilation
   Byte compilation can be done automatically by this package that keeps a cache of the compiled packages.

   It's also possible to put some more files in the blacklist.

#+begin_src emacs-lisp :tangle yes
  (require 'byte-code-cache)
  ;; FIXME: This is still not fixing the recursive stuff
  (add-to-list 'bcc-blacklist "eieio")
#+end_src   

* Visualization
** Menu and tool-bar disabling
#+begin_src emacs-lisp :tangle yes
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
#+end_src
** Elscreen
#+begin_src emacs-lisp :tangle yes
  (require 'alist)
  (setq elscreen-path (concat conf "elscreen/"))
  (add-to-list 'load-path (concat elscreen-path "elscreen"))
  (add-to-list 'load-path (concat elscreen-path "elscreen-server"))
  (add-to-list 'load-path (concat elscreen-path "elscreen-color-theme"))
  (require 'elscreen)
  (require 'elscreen-color-theme)
  (require 'elscreen-server)
#+end_src

** Fullscreen mode
   *Doesn't work* yet on OSX 10.6 with emacs 23, works fine with linux and emacs 22 on OSX.
  
#+begin_src emacs-lisp :tangle yes
  (defun fullscreen-portable (&optional f)
    (interactive)
    (if
        ;; more checks on the version and the OS should be necessary here
        mac
        (ns-toggle-fullscreen)
      (set-frame-parameter f 'fullscreen
                         (if (frame-parameter f 'fullscreen) nil 'fullboth))))
  ;; this toogle the fullscreen for every new frame (window) created
  (add-hook 'after-make-frame-functions 'fullscreen-portable)
#+end_src

** Winner mode
   Winner mode remember the window configuration and allows you to go back and forth
#+begin_src emacs-lisp :tangle yes
  ;; enabling winner mode for window reconfiguration
  (winner-mode t)
#+end_src
** Color theme setting
#+begin_src emacs-lisp :tangle yes
  (require 'color-theme)
  (eval-after-load "color-theme"
    '(progn
       (color-theme-initialize)))
  (color-theme-deep-blue)
#+end_src

** Fringe and TODO list
#+begin_src emacs-lisp :tangle no
  (defun annotate-todo ()
    "put fringe marker on TODO: lines in the curent buffer"
    (interactive)
    (save-excursion
      ;; TODO: add also other regexps like FIXME or others
      (goto-char (point-min))
      (while (re-search-forward "TODO:" nil t)
        (let ((overlay (make-overlay (- (point) 5) (point))))
          (overlay-put overlay 'before-string (propertize "A"
                                                          'display '(left-fringe right-triangle)))))))
  
  
  (add-hook 'find-file-hooks 'annotate-todo)
#+end_src

* Spelling functions
#+begin_src emacs-lisp :tangle yes
  (setq ispell-dictionary "english")
  
  ;; TODO: possible to refactor this code maybe?
  (defun en ()
    "Check spelling in english"
    (interactive)
    (ispell-change-dictionary "english")
    (flyspell-mode t))
  
  (defun it ()
    "Check spelling in english"
    (interactive)
    (ispell-change-dictionary "italian")
    (flyspell-mode t))
  
  (defun fr ()
    "Check spelling in english"
    (interactive)
    (ispell-change-dictionary "french")
    (flyspell-mode t))
  
  (defun de ()
    "Check spelling in english"
    (interactive)
    (ispell-change-dictionary "german")
    (flyspell-mode t))
#+end_src

* Org mode
** Setting up what happens when closing a task
#+begin_src emacs-lisp :tangle yes
(setq org-log-done 'note)
#+end_src

** General TODO keywords
#+begin_src emacs-lisp :tangle yes
  (setq org-todo-keywords
        '((sequence "TODO(t)" "FEEDBACK(f)" "VERIFY(v)" "|" "DONE(d)" "DELEGATED(D)")))
#+end_src

** Enforcing TODO dependencies
#+begin_src emacs-lisp :tangle yes
   (setq org-enforce-todo-dependencies t)
   (setq org-enforce-todo-checkbox-dependencies t)
#+end_src
   
** Info configuration
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'Info-default-directory-list "~/.emacs.d/org-mode/doc/")
#+end_src

** Clock configuration
#+begin_src emacs-lisp :tangle yes
;; Clock configuration
(setq org-clock-persist t)
(org-clock-persistence-insinuate)
#+end_src

** Add eventually
   This hook enables to expand your KB very easily, every time you create a new org-file it will check if it's already in the agenda and asks to add it.
#+begin_src emacs-lisp :tangle yes
  (defun org-add-eventually()
    "Adding a file to org-agenda when saved"
    (interactive)
    (if 
        (and
         (string= major-mode "org-mode")
         (not (member (abbreviate-file-name buffer-file-name) org-agenda-files)))
        (if
            (yes-or-no-p "add the file to agenda?")
            (org-agenda-file-to-front)
          ;; adds some regular expressions checks to filter out some buffers
            )))
  
  (add-hook 'before-save-hook 'org-add-eventually)
#+end_src

*** Org agenda blacklist list
    Having to say "n" every time for a file that we don't want to add to the agenda can be annoying, so every time we say no we call another function.

#+begin_src emacs-lisp :tangle no
  (defun org-agenda-add-to-blacklist ()
    (setq org-agenda-blacklist
          (add-to-list 'org-agenda-blacklist (abbreviate-file-name buffer-file-name)))
    (customize-save-variable org-agenda-blacklist org-agenda-blacklist))
#+end_src

** Remember mode
   Org mode can be used in conjunction with remember mode to keep track of repetitive things to remember.

*** Setting up
#+begin_src emacs-lisp :tangle yes
(require 'remember)
(require 'org-remember)
(org-remember-insinuate)
#+end_src

*** Define templates
#+begin_src emacs-lisp :tangle yes
  (setq org-remember-templates
        '(
          ("Note" ?n "* " "~/Documents/pycon/notes.org")))
          ;; ("Note" ?n "* " "~/org/notes.org")
          ;; ("Homeworks" ?h "* TODO %^{homework|german|functional|database|scientific|graphics} \n DEADLINE: %^T" "~/org/homeworks.org")
          ;; ("TOBUY" ?b "* TODO %^{what you want}\n %t" "~/org/tobuy.org")))
#+end_src

** Global keys
   Here below some global key mappings 

#+begin_src emacs-lisp :tangle yes
  ;; Defining a setup where org-mode takes care of remember notes
  (setq org-directory "~/org/")
  (setq org-default-notes-file (concat org-directory "notes.org"))
#+end_src

** Other org babel modes
#+begin_src emacs-lisp :tangle yes
  (require 'org-babel-dot)       ;; dot
  (require 'org-babel-haskell)   ;; haskell, haskell-mode, inf-haskell
  (require 'org-babel-python)    ;; python, and python-mode
  (require 'org-babel-ditaa)
  ;; (require 'org-babel-ruby)      ;; ruby, irb, ruby-mode, and inf-ruby
  (require 'org-babel-sql)       ;; none
  (require 'org-babel-sh)
#+end_src

** Org functionalities in other modes
#+begin_src emacs-lisp :tangle yes
  (setq org-struct-hooks
        '(message-mode-hook
          mail-mode-hook))
  
  (dolist (hook org-struct-hooks)
    (add-hook hook 'turn-on-orgstruct)
    (add-hook hook 'turn-on-orgtbl))
#+end_src

* Tags
** Etags-select
   This extension to etags helps choosing from equal names of functions.
#+begin_src emacs-lisp :tangle yes
  (require 'etags-select)
#+end_src

** Extending functions
   This functions help to look for the TAGS file in the filesystem when is not in the same working directory
# FIXME: still not working correctly, more iteration is needed here
#+begin_src emacs-lisp :tangle no
  (defun jds-find-tags-file ()
    "recursively searches each parent directory for a file named 'TAGS' and returns the
  path to that file or nil if a tags file is not found. Returns nil if the buffer is
  not visiting a file"
    (progn
      (defun find-tags-file-r (path)
        "find the tags file from the parent directories"
        (let* ((parent (file-name-directory path))
               (possible-tags-file (concat parent "TAGS")))
          (cond
           ((file-exists-p possible-tags-file) (throw 'found-it possible-tags-file))
           ((string= "/TAGS" possible-tags-file) (error "no tags file found"))
           (t (find-tags-file-r (directory-file-name parent))))))
  
      (if (buffer-file-name)
          (catch 'found-it 
            (find-tags-file-r (buffer-file-name)))
        (error "buffer is not visiting a file"))))
  
  (defun jds-set-tags-file-path ()
    "calls `jds-find-tags-file' to recursively search up the directory tree to find
  a file named 'TAGS'. If found, set 'tags-table-list' with that path as an argument
  otherwise raises an error."
    (interactive)
    (setq tags-table-list (list (jds-find-tags-file))))
  
  ;; delay search the TAGS file after open the source file
  (add-hook 'emacs-startup-hook 
            '(lambda () (jds-set-tags-file-path)))
#+end_src

* [[http://code.google.com/p/yasnippet/][Yasnippet]]  
#+begin_src emacs-lisp :tangle yes
  (require 'yasnippet)
  
  (setq yas/root-directory
        (mapcar 'make-path
                '("yasnippet/" "my-snippets/")))
  
  ;; Maybe needed to set to fixed for some modes
  (setq yas/indent-line 'auto)
  
  (yas/initialize)
  
  (setq yas/ignore-filenames-as-triggers nil)
  
  (mapc 'yas/load-directory yas/root-directory)
  
  ;; don't make backups in the snippet folder, they mess up yasnippet
  (add-to-list 'backup-directory-alist '("/my-snippets/" . "/tmp/"))
#+end_src

* Eldoc mode
  Show the documentation of some functions directly in the minibuffer.
#+begin_src emacs-lisp :tangle yes
  (require 'eldoc)
  ;; Maybe better a direct activation??
  (dolist (hook '(python-mode-hook
                  c-mode-hook
                  ruby-mode-hook
                  lisp-interaction-mode-hook
                  emacs-lisp-mode-hook))
    (add-hook hook 'turn-on-eldoc-mode))
#+end_src

* Auto complete
** Importing all packages
#+begin_src emacs-lisp :tangle yes
  ;;; Require
  (require 'auto-complete)
  ;; Various configurations
  (require 'auto-complete-config)
  (require 'auto-complete-extension nil t) ;optional
  (require 'auto-complete-yasnippet nil t) ;optional
  (require 'auto-complete-semantic nil t)  ;optional
#+end_src  

** Setting up
#+begin_src emacs-lisp :tangle yes
  ;; Generic setup.
  (global-auto-complete-mode t)           ;enable global-mode
  
  (setq ac-auto-start 3)                  ;automatically start
  (setq ac-override-local-map nil)        ;don't override local map
  
  (define-key ac-complete-mode-map "\C-n" 'ac-next)
  (define-key ac-complete-mode-map "\C-p" 'ac-previous)
#+end_src

** Define allowed modes
#+begin_src emacs-lisp :tangle yes
(setq ac-modes 
      '(python-mode
        emacs-lisp-mode
        c-mode
        nesc-mode
        lisp-interaction-mode
        java-mode
        org-mode
        ))
(add-to-list 'ac-trigger-commands 'org-self-insert-command) ; if you want enable auto-complete at org-mode, uncomment this line
#+end_src

** Elisp configuration
#+begin_src emacs-lisp :tangle yes
(dolist (hook (list
               'emacs-lisp-mode-hook
               'lisp-interaction-mode
               ))
  (add-hook hook '(lambda ()
                    (add-to-list 'ac-sources 'ac-source-symbols))))
#+end_src

* Cedet
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'load-path (concat conf "cedet/common"))
  (add-to-list 'load-path (concat conf "cedet/semantic"))
  (add-to-list 'load-path (concat conf "cedet/eieio"))
#+end_src
  
* Programming
** Web nice utilities
*** Gist
    Use simply *gist-buffer* or *gist-region* to paste code online.
#+begin_src emacs-lisp :tangle yes
    (require 'gist)
#+end_src
    
** C-mode
#+begin_src emacs-lisp :tangle yes
  (require 'c-eldoc)
  (setq c-default-style
        '((java-mode . "java")
         (awk-mode . "awk")
         (other . "cc-mode")))
  
  ;; FIXME: eldoc mode, not working correctly apparently
  ;; See http://www.emacswiki.org/emacs/CEldocMode for more info
  (add-hook 'c-mode-hook 'c-turn-on-eldoc-mode)
#+end_src

** Python
*** Python mode
  [[http://hide1713.wordpress.com/2009/01/30/setup-perfect-python-environment-in-emacs/][Possible configuration for auto completion with ropemacs]]

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.py$" . python-mode))
  (add-to-list 'interpreter-mode-alist '("python" . python-mode))
  (autoload 'doctest-mode "doctest-mode" "doc test python mode" t)
  (autoload 'python-mode "python-mode" "Python editing mode." t)
#+end_src

*** Ropemacs configuration from [[http://www.enigmacurry.com/2009/01/21/autocompleteel-python-code-completion-in-emacs/][ryan code]]

#+begin_src emacs-lisp :tangle no
  ;; Initialize Pymacs                                                                                           
  (autoload 'pymacs-apply "pymacs")
  (autoload 'pymacs-call "pymacs")
  (autoload 'pymacs-eval "pymacs" nil t)
  (autoload 'pymacs-exec "pymacs" nil t)
  (autoload 'pymacs-load "pymacs" nil t)
  ;; Initialize Rope                                                                                             
  (pymacs-load "ropemacs" "rope-")
  (setq ropemacs-enable-autoimport t)
  
  
  (defun prefix-list-elements (list prefix)
    (let (value)
      (nreverse
       (dolist (element list value)
         (setq value (cons (format "%s%s" prefix element) value))))))
  
  (defvar ac-source-rope
    '((candidates
       . (lambda ()
           (prefix-list-elements (rope-completions) ac-target))))
    "Source for Rope")
  
  (defun ac-python-find ()
    "Python `ac-find-function'."
    (require 'thingatpt)
    (let ((symbol (car-safe (bounds-of-thing-at-point 'symbol))))
      (if (null symbol)
          (if (string= "." (buffer-substring (- (point) 1) (point)))
              (point)
            nil)
        symbol)))
  
  (defun ac-python-candidate ()
    "Python `ac-candidates-function'"
    (let (candidates)
      (dolist (source ac-sources)
        (if (symbolp source)
            (setq source (symbol-value source)))
        (let* ((ac-limit (or (cdr-safe (assq 'limit source)) ac-limit))
               (requires (cdr-safe (assq 'requires source)))
               cand)
          (if (or (null requires)
                  (>= (length ac-target) requires))
              (setq cand
                    (delq nil
                          (mapcar (lambda (candidate)
                                    (propertize candidate 'source source))
                                  (funcall (cdr (assq 'candidates source)))))))
          (if (and (> ac-limit 1)
                   (> (length cand) ac-limit))
              (setcdr (nthcdr (1- ac-limit) cand) nil))
          (setq candidates (append candidates cand))))
      (delete-dups candidates)))
  (add-hook 'python-mode-hook
            (lambda ()
              (auto-complete-mode 1)
              (set (make-local-variable 'ac-sources)
                   (append ac-sources '(ac-source-rope) '(ac-source-yasnippet)))
              (set (make-local-variable 'ac-find-function) 'ac-python-find)
              (set (make-local-variable 'ac-candidate-function) 'ac-python-candidate)
  
              ;; without those last two lines works better in theory but it's too slow in practice
              (set (make-local-variable 'ac-auto-start) nil)
              (define-key py-mode-map "\t" 'python-tab)))
  
  (defun python-tab ()
    (interactive)
    (if (eql (ac-start) 0)
        (indent-for-tab-command)))
  
  (defadvice ac-start (before advice-turn-on-auto-start activate)
    (set (make-local-variable 'ac-auto-start) t))
  (defadvice ac-cleanup (after advice-turn-off-auto-start activate)
    (set (make-local-variable 'ac-auto-start) nil))
#+end_src

** Haskell mode
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.hs$" . haskell-mode))
  (autoload 'haskell-mode "haskell-mode" "haskell mode" t)
  (autoload 'turn-on-haskell-doc-mode "haskell-doc" "haskell doc mode" t)
  (autoload 'turn-on-haskell-indent "haskell-indent" "haskell indent facilities" t)
  
  (add-hook 'inf-haskell "inf-haskell" "inf-haskell" t)
  (add-hook 'hs-lint "hs-lint" "haskell checker" t)
  
  ;; here some haskell variables
  (setq haskell-doc-show-global-types t)
  (setq haskell-program-name "ghci")
                                          ; where haskell-hoogle is loaded?
  
  ;; enabled to get indentation over if-then-else
  (setq haskell-indent-thenelse 1)
  
  ;; If nothing found pass the control
  (add-hook 'haskell-mode-hook
            '(lambda ()
               (require 'haskell-doc) ; Is this the only way?
               (require 'haskell-indent)
               (turn-on-haskell-doc-mode)
               (turn-on-haskell-indentation)
               ;; This would be very nice but it conflicts with yasnippet
               (define-key haskell-mode-map [tab] 'haskell-indent-cycle)
               (define-key haskell-mode-map "\C-ch" 'haskell-hoogle)
               (define-key haskell-mode-map "\C-cl" 'hs-lint)
               (make-variable-buffer-local 'yas/trigger-key)
               (setq yas/trigger-key [tab])
               (define-key yas/keymap [tab] 'yas/next-field)))
#+end_src

** Other languages
#+begin_src emacs-lisp :tangle yes
  (autoload 'nesc-mode "nesc" nil t)
  (add-to-list 'auto-mode-alist '("\\.nc$" . nesc-mode))
#+end_src

** Java
*** Javadoc help
#+begin_src emacs-lisp :tangle yes
  (autoload 'javadoc-lookup       "javadoc-help" "Look up Java class in Javadoc."   t)
  (autoload 'javadoc-help         "javadoc-help" "Open up the Javadoc-help menu."   t)
  (autoload 'javadoc-set-predefined-urls  "javadoc-help" "Set pre-defined urls."    t)
#+end_src
  
*** Jdee settings
#+begin_src emacs-lisp :tangle no
  (add-to-list 'load-path (concat conf "jdee/lisp"))
  
  (autoload 'jde-mode "jde" "jde mode" t)
  
  ;; In this way we only load if really necessary
  (add-hook 'jde-mode-hook
            '(lambda ()
               (require 'ecb)
               (setq indent-tabs-mode nil)))
  
  ;; (defun turn-on-font-lock-if-enabled ()
  ;;   "set up to make jdee shut up")
  
  ;; TODO: put some conditional stuff for the different operating systems
  ;; make it more general usage
  (setq jde-jdk-registry
        '(("1.6" . "/System/Library/Frameworks/JavaVM.framework/Versions/1.6/")
          ("1.5" . "/System/Library/Frameworks/JavaVM.framework/Versions/1.5/")
          ("1.3.1" . "/System/Library/Frameworks/JavaVM.framework/Versions/1.3.1/")))
  
  (setq jde-jdk '("1.6" . "/System/Library/Frameworks/JavaVM.framework/Versions/1.6/"))
  
  (setq bsh-jar "/opt/local/share/java/bsh.jar")
#+end_src

** Changelog settings and time
#+begin_src emacs-lisp :tangle yes
  ;; for changelogs
  (setq add-log-always-start-new-record 1)
  (add-hook 'before-save-hook 'time-stamp)
  (setq time-stamp-format "%02d-%02m-%:y, %02H:%02M")
#+end_src

** Doc
*** Doxymacs
#+begin_src emacs-lisp :tangle yes
  (require 'doxymacs)
#+end_src
  
* Mail settings
** General settings for message creation

#+begin_src emacs-lisp :tangle yes
  ;; setting where the mail is coming from
  (setq mail-setup-with-from t)
  
  ;; This is just to enable flyspell in mail-mode
  ;; FIXME: check if this dirty hack is still needed
  (defvar message-signature-separator "^-- *$" "\
      Regexp matching the signature separator.")
#+end_src

** Setting up gmail smtp server
   Make sure you configure correctly your .authinfo for login and password

#+begin_src emacs-lisp :tangle yes
  (setq send-mail-function 'smtpmail-send-it
        message-send-mail-function 'smtpmail-send-it
        smtpmail-starttls-credentials
        '(("smtp.gmail.com" 587 nil nil))
        smtpmail-auth-credentials
        (expand-file-name "~/.authinfo")
        smtpmail-default-smtp-server "smtp.gmail.com"
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587
        ;; This can be commented out for a less verbose output
        smtpmail-debug-info t)
  
  (require 'smtpmail)
#+end_src

** Setting up completion over the addresses with the Mac address book
#+begin_src emacs-lisp :tangle yes
  (if mac
      (progn
        (require 'external-abook)
         (setq external-abook-command "contacts -lf '%%e\t%%n' %s")
         (eval-after-load "message" 
           '(progn 
              (add-to-list 'message-mode-hook 
                           '(lambda ()
                              (define-key message-mode-map "\C-c\t" 'external-abook-try-expand)))))))
#+end_src

* Gnus settings
** Server settings
#+begin_src emacs-lisp :tangle yes
  (setq gnus-select-method '(nntp "news.gmane.org"))
  ;; Set also comp.* hierarchy
  (setq gnus-secondary-select-methods
        '(
          ;; Configuration for http://www.eternal-september.org/
          (nntp "eternal"
                (nntp-authinfo-file "~/.authinfo")
                (nntp-address "news.eternal-september.org")
                (nntp-port-number 119))))
#+end_src

** Old messages settings
#+begin_src emacs-lisp :tangle yes
  (setq gnus-large-newsgroup 500)
  (setq gnus-fetch-old-headers nil)
#+end_src

** Appearance
#+begin_src emacs-lisp :tangle yes
  ;; Changing modeline to include also the date of the message
  (setq gnus-summary-line-format "%U%R%z%I%(%[%4L: %-23,23f%]%) %s--%d\n")
#+end_src

** Avoid the annoying saving of the .news file
#+begin_src emacs-lisp :tangle yes
  (add-hook 'gnus-started-hook
            (lambda ()
              (when (buffer-live-p gnus-dribble-buffer)
                (with-current-buffer gnus-dribble-buffer
                  (setq buffer-save-without-query t)))))
#+end_src

** TODO Setting up some posting styles and other nice settings

* Revision control systems
** [[http://zagadka.vm.bytemark.co.uk/magit/][Magit]]
   Nice interface for git.
#+begin_src emacs-lisp :tangle yes
  (require 'magit)
#+end_src

* General settings
** Aliasing and other useful shortcuts
#+begin_src emacs-lisp :tangle yes
  (defalias 'eb 'eval-buffer)
  (defalias 'er 'eval-region)
  (defalias 'yes-or-no-p 'y-or-n-p)
  (defalias 'rs 'replace-string)
  (defalias 'qs 'query-replace)
  (defalias 'ac 'auto-complete-mode)
  (defalias 'go 'google-search-it)
  (defalias 'gs 'google-search-selection)
  (defalias 'spell 'flyspell-mode)
  (defalias 'dml 'delete-matching-lines)
  (defalias 'bb 'bury-buffer)
  
  (defalias 'ys 'yas/reload-all)
  (defalias 'yv 'yas/visit-snippet-file)
  
  (defalias 'ascii 'org-export-as-ascii)
  (defalias 'html 'org-export-as-html-and-open)
  (defalias 'pdf 'org-export-as-pdf-and-open)
  (defalias 'box 'comment-box)
  (defalias 'rb 'revert-buffer)
  
  (defalias 'sh 'shell)
  
  (defalias 'ws 'whitespace-mode)
  (defalias 'bu 'browse-url)
  
  (defalias 'mem 'doxymacs-insert-member-comment)
  (defalias 'fun 'doxymacs-insert-function-comment)
  (defalias 'file 'doxymacs-insert-file-comment)
  
  ;; Those below are my favourite themes
  (defalias 'black 'color-theme-hober)
  (defalias 'blue 'color-theme-deep-blue)
  (defalias 'grey 'color-theme-black-on-gray)
  (defalias 'blipp 'color-theme-blippblopp)
  (defalias 'high 'color-theme-high-contrast)
  (defalias 'billw 'color-theme-billw)
  (defalias 'charcoal 'color-theme-charcoal-black)
  
  (defalias 'batt 'display-battery-mode)

  (defun get-some-messages ()
    (interactive)
    (gnus-summary-rescan-group 1000))
  ;; gnus
  (defalias 'gg 'get-some-messages)
#+end_src   

** Showing more things
#+begin_src emacs-lisp :tangle yes
(display-time-mode 1)
(transient-mark-mode 1)
(setq inhibit-startup-message t)
(setq initial-scratch-message nil)

(show-paren-mode t)
(column-number-mode t)
;; always truncate lines (useful for netbook), not working yet in ORG MODE
(setq truncate-lines nil)
;; Setting indent-tabs-mode for only spaces
(setq-default indent-tabs-mode nil)
#+end_src

** IDO mode
#+begin_src emacs-lisp :tangle yes
(require 'ido)
(ido-mode t)
#+end_src

** Windmove
#+begin_src emacs-lisp :tangle yes
(windmove-default-keybindings 'shift)
#+end_src

* Flymake
** Setting up flymake
#+begin_src emacs-lisp :tangle yes
(require 'flymake)
   
(defun activate-flymake ()
  "Activates flymake when real buffer and you have write access"
  (if (and
       (buffer-file-name)
       (file-writable-p buffer-file-name))
      (flymake-mode t)))
#+end_src

** Adding errors to modeline
   With this the error output of othe current line will appear right below in the modeline
#+begin_src emacs-lisp :tangle yes
(defun my-flymake-show-help ()
  (when (get-char-property (point) 'flymake-overlay)
    (let ((help (get-char-property (point) 'help-echo)))
      (if help (message "%s" help)))))

(add-hook 'post-command-hook 'my-flymake-show-help)
#+end_src

** Flymake for python
   We check the errors given by 3 different programs:
   - epylint (which runs pylint and make it more parsable)
   - pyflakes
   - pep8

   The errors or warnings appear right in the source code.
   
#+begin_src emacs-lisp :tangle yes
  (defun flymake-python-init () 
    (let* ((temp-file (flymake-init-create-temp-buffer-copy 
                       'flymake-create-temp-inplace)) 
           (local-file (file-relative-name 
                        temp-file 
                        (file-name-directory buffer-file-name)))) 
      (list "pycheckers" (list local-file))))
  
  (add-to-list 'flymake-allowed-file-name-masks 
               '("\\.py\\'" flymake-python-init))
  
  ;; Using function is preferred when quoting functions
 ;; (add-hook 'python-mode-hook (function activate-flymake))
#+end_src
  
* Customizable variables
  Still thinking how to manage this for best usage
#+begin_src emacs-lisp :tangle no
  (defgroup variables nil "private variables")
  (defcustom private "private" "file with private settings"
  :group 'variables)
#+end_src

* Some mac tricks
** Open the terminal
#+begin_src emacs-lisp :tangle yes
  (defun mac-open-terminal ()
    (interactive)
    (let ((dir ""))
      (cond
       ((and (local-variable-p 'dired-directory) dired-directory)
        (setq dir dired-directory))
       ((stringp (buffer-file-name))
        (setq dir (file-name-directory (buffer-file-name))))
       )
      (do-applescript
       (format "
  tell application \"Terminal\"
    activate
    try
      do script with command \"cd %s\"
    on error
      beep
    end try
  end tell" dir))
      ))
#+end_src

** Growl popup
   This function can be pretty nice during presentations, it will popup the last pressed key via growl.
#+begin_src emacs-lisp :tangle yes
     (defun growl-popup (msg)
    "Pop up a growl notification with MSG, or display an Emacs message.
  The \"growlnotify\" program is used if `window-system' is non-nil and
  the program is found in `exec-path'; otherwise `message' is used."
    (interactive)
    (if (and window-system (executable-find "growlnotify"))
        (shell-command (concat "growlnotify -a /Applications/Emacs.app/ -m "
                               (shell-quote-argument msg)))
      (message msg)))
  
  (defun popup-last ()
    (interactive)
    (let
        ((last-key (key-description (this-command-keys))))
      (if
          (or
           ;; only enable some combinations discarding the not intersesting ones
           (string-prefix-p "C-" last-key)
           (string-prefix-p "M-" last-key))
          (growl-popup last-key))))
#+end_src

  Now we also create two other functions to enable and disable it
#+begin_src emacs-lisp :tangle yes
  (defun growl-mode-on ()
    (interactive)
    (add-hook 'pre-command-hook 'popup-last))
  
  (defun growl-mode-off ()
    (interactive)
    (setq-default pre-command-hook (remq 'popup-last pre-command-hook)))
#+end_src
      
* Fun
** Fortune settings
#+begin_src emacs-lisp :tangle yes
(setq fortune-dir "/opt/local/share/games/fortune/")
#+end_src

* Global keys settings
#+begin_src emacs-lisp :tangle yes
  ;; compile facilities
  (global-set-key [f5] 'recompile)
  
  ;; newline like textmate
  (global-set-key (kbd "M-RET") 'newline-force)
  (global-set-key [M-S-return] 'newline-force-close)
  
  ;; cvs stuff
  (global-set-key "\C-xg" 'magit-status)
  
  ;; tags related
  (global-set-key "\M-?" 'etags-select-find-tag-at-point)
  (global-set-key "\M-." 'etags-select-find-tag)  
  
  ;; org keys
  (global-set-key "\C-c\C-l" 'org-annotate-file)
  (global-set-key "\C-cr" 'org-remember)
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-c\C-x\C-o" 'org-clock-out)
  
  ;; overriding defualt not so smart visualization
  (global-set-key "\C-x\C-b" 'ibuffer) ;; manage buffers with ibuffer
  
  ;; visualization
  (global-set-key [f11] 'fullscreen-portable)
  
  ;; splitting windows facilitites
  ;; TODO: pass to a sensible splitting instead
  (global-set-key [f2] 'split-window-horizontally)
  (global-set-key [f1] 'delete-window)
#+end_src

* Versions of software
  In this table we collect the actual version of the packages used
  
  | PKG           | version                                      |
  |---------------+----------------------------------------------|
  | emacs         | 23.2.1                                       |
  | yasnippet     |                                              |
  | python mode   | 0.6.1b)                                      |
  | auto-complete | Org-mode version 6.34trans                   |
  | org-mode      | Org-mode version 6.35f (release_6.35f.dirty) |
  #+TBLFM: @2$2='(nth 2 (split-string (emacs-version)))::@4$2='(nth 2 (split-string (yas/about)))::@5$2='(org-version)
