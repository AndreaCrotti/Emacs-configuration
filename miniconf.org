#+OPTIONS: toc:t LEVEL:4
MINIMAL EMACS CONFIGURATION
# FIXME: keys for splitting the screeen
# FIXME: color for transient-mark-mode
# FIXME: ignoring the buffers is ok only if we have can then fix it
# FIXME: add some configurations for different usage of emacs

* DONE Write a function that setups all the possible paths automatically
  CLOSED: [2010-05-04 Mar 11:41]
* DONE See if it's worthy to byte compile everything or not
  CLOSED: [2010-05-24 Lun 14:01]
  - CLOSING NOTE [2010-05-24 Lun 14:01] \\
    Solved nicely with byte-compile-cache, some cases it could not work
* DONE Include another more up-to-date semantic version finally
  CLOSED: [2010-08-08 Dom 16:13]
  - CLOSING NOTE [2010-08-08 Dom 16:13] \\
    included a version from cvs
* TODO Write a dependency tree of the various chapters in the configuration
* TODO Add options to create encrypted org-files for storing password and more delicate informations
* TODO See how to use variables like *special-buffer-regexps* to have a better control over the buffer windows
* TODO Build an automatic list of versions

* Links
  - [[http://www.gnu.org/software/emacs/tour/][A guided tour of emacs features]]
  - [[http://www.delorie.com/gnu/docs/emacs-lisp-intro/emacs-lisp-intro_toc.html][nice emacs lisp intro]]
  - [[http://www.emacswiki.org/][emacs wiki]]
  - [[http://github.com/purcell/emacs.d/][purcell configuration]]
  - [[http://code.google.com/p/yasnippet/][yasnippet template system]]
    See [[http://yasnippet.googlecode.com/svn/trunk/doc/snippet-development.html#importing-textmate-snippets][snippet developement web page]]

  - [[http://www.emacsblog.org/][emacs blog]]
  - [[http://orgmode.org/][org mode]]
  - [[http://www.linuxjournal.com/article/6771][intermediate emacs hacking]]
  - [[https://github.com/AndreaCrotti/Emacs-conf/tree][my own configuration]]
  - [[http://www.emacswiki.org/emacs/EmacsScreencasts][emacs screencasts]], also how to create your own screencasts
  - [[http://emacs-fu.blogspot.com/][emacs fu]], interesting blog about emacs
  - [[http://geosoft.no/development/emacs.html][emacs tricks and tips]]
  - [[http://lispservice.posterous.com/][lisp emacs blog]]
  - [[http://emacs.wordpress.com/][emacs wordpress blog]]
  - [[http://wttools.sourceforge.net/emacs-stuff/package.html][emacs suggestions (jdee)]]
  - [[http://mytechrants.wordpress.com/][my tech rants, emacs fan blog]]
  - [[http://livollmers.net/index.php/2008/10/06/back-to-myemacs/][back to my emacs]]
  - [[http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html][emergency lisp]]
  - [[http://deep.syminet.com/emacside.html][emacsside, nice cheatsheet]]
  - [[http://platypope.org/yada/emacs-demo/][emacs video demo]], with [[http://platypope.org/blog/2006/9/8/i-need-a-cool-european-accent][explanation of the features showed]]
  - [[http://snarfed.org/space/why_I_dont_run_shells_inside_Emacs][running a shell inside emacs]]

* Things not working in emacs 22
  - remember mode (not present) (and consequently org-remmeber)

* Sparse documentation 
  From newcomment.el:
** Define a custom variable with a dynamic list
#+begin_src emacs-lisp :tangle yes
  (defcustom comment-style 'indent
    "Style to be used for `comment-region'.
  See `comment-styles' for a list of available styles."
    :type (if (boundp 'comment-styles)
              `(choice ,@(mapcar (lambda (s) `(const ,(car s)))
                                 comment-styles))
            'symbol)
    :version "23.1"
    :group 'comment)
#+end_src

** How to extend emacs
   [[http://www.enigmacurry.com/2009/01/14/extending-emacs-with-advice/][example about advising functions]]
   - If you can use the mode hooks provided by the author, use them instead.
   - If there is a bug in the original mode, just fix it in the original code and submit a patch.
   - If there is a new feature you want, add it to the original mode and submit a patch. Talk to the author, work with him, and it will most likely end up in the next release.
   - If you are an Emacs developer, working on Emacs itself, or one of the modes shipped with Emacs, never use advice. It's the least maintainable method of extending Emacs with the exception of a pure fork, and since you're working on Emacs itself, it's not a fork.
   - If your patch is not accepted, or you know that what you want is fringe enough or hackish enough to not warrant submitting a patch, only then should you use advice or fork the project.

** Some very useful commands
   - *kill-buffer-and-window*
   - *shell*
   - *list-load-path-shadows* (find hiding libraries)
   - *symbol-function* (find where a symbol is defined)
   - *trace-function* (for debugging and see what really happens), untrace-function to undo
   - *read-string* (getting a string from the minibuffer, see how prompt strings work)
   - *completing-read* (creating a nice menu getting the tab-completion in minibuffer)
   - *string-rectangle* (select a rectangle and replace the inserted text /\C-x r t/)
   - *split-line* (split a line keeping indentation, bound to /\C-\M-o/)
   - *c-set-style*, set the indentation style for your code, many preset useful settings
     Used for java and cc-mode
   - *thing-at-point*, gets what it can find at local point
   - *regexp-builder* very nice to create dynamically a regexp
   - *align* align list of things in a more readable way
   - *ielm*, nice interactive elisp environment
   - *semantic-mrub-switch-tags*, allows to jump to last modified positions with semantic
   - *C-c C-h* (or some other prefix) allows you to see all the commands you can give
   - *describe-mode* (C-h m) 

** Tips and tricks
*** Using always spaces instead of tabs
   There are many opinions about the usage of tabs or spaces in source code.
   I think the best and easiest approach is to use spaces everywhere, tabbing will still create the right number of spaces.

   Setting up the right /style/ with *c-set-style* we can have the desired behavior.
   This is the to set:
#+BEGIN_SRC elisp
   ;; Setting indent-tabs-mode for only spaces
   (setq indent-tabs-mode nil)
#+END_SRC
   If you want to convert from spaces to tabs or tabs to spaces use *tabify* or *untabify* respectively.

*** Make emacs ignore a key
    See for example
#+begin_src emacs-lisp :tangle no
  (global-set-key (kbd "<f2>") 'ignore)
#+end_src

** How to set up your initialization
   The configuration should be as modular as possible, and should use autoloads when possible.
   There are different way to set up variables on not loaded libraries:
   - *simple variables*
     use simply *setq* and evaluate it on emacs loading

   - *adding default values of an extension*
     for example /(define-key foo-mode-map ...)/ use *eval-after-load*.
     This will add default values once the extension is loaded.

   - *run code after initialization*
     Use mode hooks, normally simply <mode-name>-hook, and modify them with *add-hook*

* Aliasing and other useful shortcuts
#+begin_src emacs-lisp :tangle yes
  (defalias 'eb 'eval-buffer)
  (defalias 'er 'eval-region)
  (defalias 'yes-or-no-p 'y-or-n-p)
  (defalias 'rs 'replace-string)
  (defalias 'qs 'query-replace)
  (defalias 'qrs 'query-replace-regexp)
  (defalias 'ac 'auto-complete-mode)
  (defalias 'go 'google-search-it)
  (defalias 'gs 'google-search-selection)
  (defalias 'spell 'flyspell-mode)
  (defalias 'spell-prog 'flyspell-prog-mode)
  (defalias 'dml 'delete-matching-lines)
  (defalias 'bb 'bury-buffer)
  (defalias 'elm 'emacs-lisp-mode)
  
  (defalias 'ys 'yas/reload-all)
  (defalias 'yv 'yas/visit-snippet-file)
  
  (defalias 'ascii 'org-export-as-ascii)
  (defalias 'html 'org-export-as-html-and-open)
  (defalias 'pdf 'org-export-as-pdf-and-open)
  (defalias 'box 'comment-box)
  (defalias 'rb 'revert-buffer)
  
  (defalias 'sh 'shell)
  
  (defalias 'ws 'whitespace-mode)
  (defalias 'bu 'browse-url)
  
  (defalias 'mem 'doxymacs-insert-member-comment)
  (defalias 'fun 'doxymacs-insert-function-comment)
  (defalias 'file 'doxymacs-insert-file-comment)
  
  ;; Those below are my favourite themes
  (defalias 'black 'color-theme-hober)
  (defalias 'blue 'color-theme-deep-blue)
  (defalias 'grey 'color-theme-black-on-gray)
  (defalias 'blipp 'color-theme-blippblopp)
  (defalias 'high 'color-theme-high-contrast)
  (defalias 'billw 'color-theme-billw)
  (defalias 'coal 'color-theme-charcoal-black)
  
  (defalias 'batt 'display-battery-mode)
  
  (defun get-some-messages ()
    (interactive)
    (gnus-summary-rescan-group 1000))
  ;; gnus
  (defalias 'gg 'get-some-messages)
  (defalias 'jd 'javadoc-lookup)
  (defalias 'br 'babel-region-default)
  (defalias 'git 'open-git-files)
  
  (defalias 'fold 'senator-fold-tag-toggle)
  
  (defalias 'pd 'print-desktop)
  (defalias 'dcd 'desktop-change-dir)
  (defalias 'gcb 'git-change-branch)
#+end_src   

* General settings
** Provide the library
#+begin_src emacs-lisp :tangle yes
  (provide 'miniconf)
#+end_src

** Custom settings
#+begin_src emacs-lisp :tangle yes
  (setq custom-file (concat base "custom.el"))
#+end_src

* Prerequisites
** Constants and some global settings
#+begin_src emacs-lisp :tangle yes
  (defcustom default-closing-char ";"
    "default closing char, change in newline-force-close-alist if needed"
    :type 'string)
  
  ;; TODO: use a defcustom instead
  (defcustom newline-force-close-alist
    '((python-mode . ":")
      (jython-mode . ":")
      (prolog-mode . ".")
      (latex-mode . " \\newline")
      (org-mode . " \\newline")
      (tuareg-mode . ";;")
      (html-mode . " <br>"))
    "Closing char for different modes"
    :type 'list)
#+end_src

** Some useful functions
   We suppose that the global variable *conf* has been already set from the outside.

*** Make a script executable
#+begin_src emacs-lisp :tangle yes
  ;FIXME: not correct yet
  (defun px()
    (interactive)
    (chmod (buffer-file-name) "777"))
#+end_src
    
*** Make fortune
    Print below a fortune cookie if the command is present in the system.

#+begin_src emacs-lisp :tangle yes
  (defun make-fortune ()
  (interactive)
  (let ((beg (point)))
    (insert (shell-command-to-string "fortune"))
    (end-of-paragraph-text)))
#+end_src
 
*** Gen path dirs
   All all the directories in the first level of the configuration directory to the load path.

#+begin_src emacs-lisp :tangle yes
  (defun gen-path-dirs (base-dir)
    "Add to load path all the subdirectories of first level"
    (interactive)
    (message "adding all directories in the first level to the load-path")
    (dolist (dir (directory-files base-dir t))
      (if (and 
           (file-directory-p dir)
           (not (file-symlink-p dir)))
          (add-to-list 'load-path dir))))
  
  ; next step is to remove conf completely
  (defun reload-dirs ()
    (interactive)
    (gen-path-dirs base))
  
  (reload-dirs)
#+end_src

*** Google map it
   Search an address in google map
#+begin_src emacs-lisp :tangle yes
  (defun google-map-it (address)
    "get the map of the given address"
    (interactive "sSearch for: ")
    (let
        ((base "http://maps.google.it/maps?q=%s"))
      (browse-url (format base (url-hexify-string address)))))
#+end_src   

*** New line
   Those functions are inspired by textmate
#+begin_src emacs-lisp :tangle yes
  ;; My own functions
  (defun newline-force()
    "Goes to newline leaving untouched the rest of the line"
    (interactive)
    (end-of-line)
    (newline-and-indent))
  
  (defun newline-force-close()
    "Same as newline-force but putting a closing char at end"
    (interactive)
    (end-of-line)
    (let ((closing-way (assoc major-mode newline-force-close-alist))
          closing-char)
      ;; Setting the user defined or the constant if not found
      (if (not closing-way)
          (progn
            (message "closing char not defined for this mode, using default")
            (setq closing-char default-closing-char))
        (setq closing-char (cdr closing-way)))
      (when (not (bobp))
        ;; if we're at beginning of buffer, the backward-char will beep
        ;; :( This works even in the case of narrowing (e.g. we don't
        ;; look outside of the narrowed area.
        ;; FIXME: looking-at not working as expected
        (when (not (looking-at closing-char))
          (insert closing-char))
        (newline-force))))
#+end_src

*** Error switch
    Useful function to toogle on and off the debug mode
#+begin_src emacs-lisp :tangle yes
  (defun err-switch()
    "switch on/off error debugging"
    (interactive)
    (if debug-on-error
        (setq debug-on-error nil)
      (setq debug-on-error t))
    (message "debug-on-error now %s" debug-on-error))
#+end_src

*** Swap windows
#+begin_src emacs-lisp :tangle yes
  ;; someday might want to rotate windows if more than 2 of them
  (defun swap-windows ()
    "If you have 2 windows, it swaps them."
    (interactive)
    (cond 
     ((not (= (count-windows) 2)) (message "You need exactly 2 windows to do this."))
     (t
      (let* ((w1 (first (window-list)))
             (w2 (second (window-list)))
             (b1 (window-buffer w1))
             (b2 (window-buffer w2))
             (s1 (window-start w1))
             (s2 (window-start w2)))
        (set-window-buffer w1 b2)
        (set-window-buffer w2 b1)
        (set-window-start w1 s2)
        (set-window-start w2 s1)))))
#+end_src
# TODO: Add something to rotate the windows gracefully

*** Rename file and buffer
**** TODO Add something VCS related for moving away files
#+begin_src emacs-lisp :tangle yes
  (defun rename-file-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME." (interactive "sNew name: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not filename)
          (message "Buffer '%s' is not visiting a file!" name)
        (if (get-buffer new-name)
            (message "A buffer named '%s' already exists!" new-name)
          (progn   (rename-file name new-name 1)   (rename-buffer new-name)        (set-visited-file-name new-name)        (set-buffer-modified-p nil)))))) ;;
#+end_src

*** Move buffer file
#+begin_src emacs-lisp :tangle yes
  (defun move-buffer-file (dir)
    "Moves both current buffer and file it's visiting to DIR." (interactive "DNew directory: ")
    (let* ((name (buffer-name))
           (filename (buffer-file-name))
           (dir
            (if (string-match dir "\\(?:/\\|\\\\)$")
                (substring dir 0 -1) dir))
           (newname (concat dir "/" name)))
  
      (if (not filename)
          (message "Buffer '%s' is not visiting a file!" name)
        (progn         (copy-file filename newname 1)  (delete-file filename)  (set-visited-file-name newname)         (set-buffer-modified-p nil)     t))))
#+end_src

*** Delete current file
#+begin_src emacs-lisp :tangle yes
  (defun delete-current-file () 
    "Delete the file associated with the current buffer." 
    (interactive) 
    (let (currentFile) 
      (setq currentFile (buffer-file-name)) 
      (when (yes-or-no-p (format "Delete file % s and kill buffer? " currentFile)) 
        (kill-buffer (current-buffer)) 
        (delete-file currentFile) 
        (message "Deleted file: %s " currentFile))))
#+end_src

*** Open git files
    Run *git ls-files* and visits all the buffer given from it

#+begin_src emacs-lisp :tangle yes
  (defun open-git-files ()
    "Visit all the files in the current git project"
    (interactive)
    (dolist
        (file (ls-git-files))
      (message "Opening %s" file)
      ;; we have to keep the original position
      (save-excursion (find-file file))))
  
  (defun before-last (list)
    (nth (- (length list) 2) list))
  
  
  (defun dired-git (directory)
    (interactive "D")
    (dired-git-files directory))
  
  (defun dired-git-files (directory)
    (cd directory)
    "Open a dired buffer containing the local git files"
    (let ((files (ls-git-files)))
      (if
          (or 
           (< (length files) 200)
           (yes-or-no-p (format "%d files, are you sure?" (length files))))
          ;; rename the buffer to something with a sense
          (progn
            (dired (ls-git-files))
            (rename-buffer (git-dired-buffer-name directory))))))
  
  (defun git-dired-buffer-name (directory)
    (concat "git-" (before-last (split-string directory "/"))))
  
  ;; TODO: take the return code instead
  (defun ls-git-files ()
    (let
        ((result (shell-command-to-string (concat "git ls-files"))))
      (if
          (string-match "fatal" result)
          nil
        (split-string result))))
#+end_src

*** Change git branch
#+begin_src emacs-lisp :tangle yes
  (defun git-change-branch ()
    "change the actual git branch asking with completion"
    (interactive)
    (let
        ((branch (completing-read "checkout to: " (split-string (shell-command-to-string "git branch")))))
      (shell-command (concat "git checkout " branch))))
#+end_src

*** Replace in regexp
#+begin_src emacs-lisp :tangle yes
  (defun query-replace-in-git (from to)
    "query replace regexp on the files given"
    (interactive "sFrom: \nsTo: ")
    (dired-git (pwd))
    (dired-mark-files-regexp ".[ch]")
    (dired-do-query-replace-regexp from to))
#+end_src 

*** Camelizing
    (un)Camelizing allows to convert quickly function/variables names from camelized to non camelized mode.

#+begin_src emacs-lisp :tangle yes
  (defun mapcar-head (fn-head fn-rest list)
    "Like MAPCAR, but applies a different function to the first element."
    (if list
        (cons (funcall fn-head (car list)) (mapcar fn-rest (cdr list)))))
  
  (defun camelize (s)
    "Convert under_score string S to CamelCase string."
    (mapconcat 'identity (mapcar
                          '(lambda (word) (capitalize (downcase word)))
                          (split-string s "_")) ""))
  
  (defun camelize-method (s)
    "Convert under_score string S to camelCase string."
    (mapconcat 'identity (mapcar-head
                          '(lambda (word) (downcase word))
                          '(lambda (word) (capitalize (downcase word)))
                          (split-string s "_")) ""))
  
  (defun un-camelcase-string (s &optional sep start)
    "Convert CamelCase string S to lower case with word separator SEP.
      Default for SEP is a hyphen \"-\".
      If third argument START is non-nil, convert words after that
      index in STRING."
    (let ((case-fold-search nil))
      (while (string-match "[A-Z]" s (or start 1))
        (setq s (replace-match (concat (or sep "-") 
                                       (downcase (match-string 0 s))) 
                               t nil s)))
      (downcase s)))
  
  (defun manipulate-matched-text (fn)
    (let (matchedText newText)
      (setq matchedText
            (buffer-substring
             (match-beginning 0) (match-end 0)))
      (setq newText
            (apply 'fn match-end))
      newText))
  
  ; TODO: use the more general manipulation
  (defun uncamel ()
    (let (matchedText newText)
      (setq matchedText
            (buffer-substring
             (match-beginning 0) (match-end 0)))
      (setq newText
            (un-camelcase-string matchedText "_"))
      newText))
  
    ;; (manipulate-matched-text 'un-camelcase-string))
    ;; "use this function with query-replace-regexp"
#+end_src

    For example the above functions might be very useful to convert an entire project from camelcase to non camelcase.
    
    - Open dired
    - mark the files you want
    - "Q" RET [a-z]+?[A-Z] RET \,(uncamel)
    
    And the fun begins

    We also have [[http://www.eecs.ucf.edu/~leavens/emacs/camelCase/camelCase-mode.html][camel case mode]] which makes moving in camelized words smarter
#+begin_src emacs-lisp :tangle yes
  (autoload 'camelCase-mode "camelCase-mode")
  (defcustom camelCase-modes
    '(python-mode-hook java-mode-hook c-mode-hook nesc-mode-hook)
    "Modes where camelizing is allowed"
    :type 'list)
  
  (dolist (hook camelCase-modes)
    (add-hook hook 'camelCase-mode))
#+end_src

*** Find project
    This functions are take from textmate.el and are used to check if we're on a project of some kind.
    Not used at the moment.

#+begin_src emacs-lisp :tangle yes
  ;; When it's a git project we can use a grep over git ls-files
  ;; same thing for mercurial
  ;; check also with the Makefiles in general if we can do something like this
  ;; In this way is too simplicistic
  
  (defvar *project-roots*
    '(".git" ".hg" "Rakefile" "Makefile" "README" "build.xml")
    "The presence of any file/directory in this list indicates a project root.")
  
  (defun root-match(root names)
    (member (car names) (directory-files root)))
  
  (defun root-matches(root names)
    (if (root-match root names)
        (root-match root names)
      (if (eq (length (cdr names)) 0)
          'nil
        (root-matches root (cdr names)))))
  
  ;; should return also the type and the certainty level
  (defun find-project-root (&optional root)
    "Determines the current project root by recursively searching for an indicator."
    (interactive)
    (when (null root)
      (setq root default-directory))
    (cond
     ((root-matches root *project-roots*)
      (expand-file-name root))
     ((equal (expand-file-name root) "/") nil)
     (t
      ;; recursive call
      (find-project-root (concat (file-name-as-directory root) "..")))))
  
  (find-project-root)
#+end_src

*** Select current line
#+begin_src emacs-lisp :tangle yes
  (defun select-line ()
    "If the mark is not active, select the current line.
  Otherwise, expand the current region to select the lines the region touches."
    (interactive)
    (if mark-active ;; expand the selection to select lines
        (let ((top (= (point) (region-beginning)))
              (p1 (region-beginning))
              (p2 (region-end)))
          (goto-char p1)
          (beginning-of-line)
          (push-mark (point))
          (goto-char p2)
          (unless (looking-back "\n")
            (progn
              (end-of-line)
              (if (< (point) (point-max)) (forward-char))))
          (setq mark-active t
                transient-mark-mode t)
          (if top (exchange-point-and-mark)))
      (progn
        (beginning-of-line)
        (push-mark (point))
        (end-of-line)
        (if (< (point) (point-max)) (forward-char))
        (setq mark-active t
              transient-mark-mode t))))
#+end_src

*** Select all from an alist
#+begin_src emacs-lisp :tangle yes
  (defun all-asscs (asslist query)
    "returns a list of all corresponding values (like rassoc)"
    (cond
     ((null asslist) nil)
     (t
      (if (equal (cdr (car asslist)) query)
          (cons (car (car asslist)) (all-asscs (cdr asslist) query))
        (all-asscs (cdr asslist) query)))))
#+end_src

*** Reopen a file in readwrite mode
#+begin_src emacs-lisp :tangle yes
  (defcustom preferred-reopen-rw-mode "sudo"
    "preferred mode for reopen"
    :type 'string
    )
  
  (defun rw ()
    "Reopen the file in rw mode, sui"
    (interactive)
    (let
        ((read-only-old-file (buffer-file-name)))
      (if (not (file-writable-p read-only-old-file))
          (when (yes-or-no-p "kill the read only and reopen in rw?")
            (progn 
              (kill-buffer)
              (find-file (concat "/" preferred-reopen-rw-mode "::" read-only-old-file))))
        (message "you can already write on this file"))))
#+end_src

*** Find-file-root
#+begin_src emacs-lisp :tangle yes
  ;; Taken from http://www.emacswiki.org/emacs/TrampMode
  (defvar find-file-root-prefix (if (featurep 'xemacs) "/[sudo/root@localhost]" "/sudo:root@localhost:" )
    "*The filename prefix used to open a file with `find-file-root'.")
  
  (defvar find-file-root-history nil
    "History list for files found using `find-file-root'.")
  
  (defvar find-file-root-hook nil
    "Normal hook for functions to run after finding a \"root\" file.")
  
  (defun find-file-root ()
    "*Open a file as the root user.
     Prepends `find-file-root-prefix' to the selected file name so that it
     maybe accessed via the corresponding tramp method."
  
    (interactive)
    (require 'tramp)
    (let* ( ;; We bind the variable `file-name-history' locally so we can
           ;; use a separate history list for "root" files.
           (file-name-history find-file-root-history)
           (name (or buffer-file-name default-directory))
           (tramp (and (tramp-tramp-file-p name)
                       (tramp-dissect-file-name name)))
           path dir file)
  
      ;; If called from a "root" file, we need to fix up the path.
      (when tramp
        (setq path (tramp-file-name-localname tramp)
              dir (file-name-directory path)))
  
      (when (setq file (read-file-name "Find file (UID = 0): " dir path))
        (find-file (concat find-file-root-prefix file))
        ;; If this all succeeded save our new history list.
        (setq find-file-root-history file-name-history)
        ;; allow some user customization
        (run-hooks 'find-file-root-hook))))
  
  (global-set-key [(control x) (control r)] 'find-file-root)
#+end_src
  
  Adding also some warning to make sure we don't edit by mistake
#+begin_src emacs-lisp :tangle yes
  (defface find-file-root-header-face
    '((t (:foreground "white" :background "red3")))
    "*Face use to display header-lines for files opened as root.")
  
  (defun find-file-root-header-warning ()
    "*Display a warning in header line of the current buffer.
     This function is suitable to add to `find-file-root-hook'."
    (let* ((warning "WARNING: EDITING FILE AS ROOT!")
           (space (+ 6 (- (window-width) (length warning))))
           (bracket (make-string (/ space 2) ?-))
           (warning (concat bracket warning bracket)))
      (setq header-line-format
            (propertize  warning 'face 'find-file-root-header-face))))
  
  (add-hook 'find-file-root-hook 'find-file-root-header-warning)
#+end_src

** reload this configuration
#+begin_src emacs-lisp :tangle yes
  (defun reload-conf ()
    (interactive)
    (org-babel-load-file (make-conf-path "miniconf.org")))
#+end_src

* Operating system detection
  This has to be done first because we have some conditional code later
#+begin_src emacs-lisp :tangle yes
  (defconst sysop 
    (cond ((string-match "linux" system-configuration) "linux")
          ((string-match "apple" system-configuration) "mac")
          ((string-match "win" system-configuration) "win") (t "other")))
  
  (defconst linux (string= "linux" sysop))
  (defconst mac (string= "mac" sysop))
  (defconst win (string= "win" sysop))
  (defconst other (string= "other" sysop))
  
  ;; ;; (defconst linux nil)
  ;; ;; (defconst mac nil)
  ;; ;; (defconst win nil)
  ;; ;; (defconst other nil)
  
  ;; (case system-type
  ;;   (gnu/linux (setq linux t))
  ;;   (window-nt (setq mac t))
  ;;   (darwin    (setq win t))
  ;;   (t         (setq other t)))
#+end_src

** Mac configuration
    This will setup the Command key ot be used as meta.
#+begin_src emacs-lisp :tangle yes
  (if mac
      (progn
        (add-to-list 'exec-path "/opt/local/bin")
        (setq ns-alternate-modifier (quote none))
        ;; not open new frames/elscreens from emacsclient
        (setq ns-pop-up-frames nil)
        (setq ns-command-modifier (quote meta))))
#+end_src

* Other useful paths
#+begin_src emacs-lisp :tangle yes
  (if mac
      (let ((ports-lisp "/opt/local/share/emacs/site-lisp/"))
        (if 
            (file-exists-p ports-lisp)
            (add-to-list 'load-path ports-lisp))))
#+end_src

* Buffer management
  See also [[http://scottfrazersblog.blogspot.com/2010/01/emacs-filtered-buffer-switching.html][this nice article]] for a better filtering of buffers while switching.

** Dired settings
#+begin_src emacs-lisp :tangle yes
   ;; reverting automatically the buffer
   (setq dired-auto-revert-buffer 1)
   ;; look for filenames if on one already
   (setq dired-isearch-filenames 'dwim)
#+end_src

*** Using dired-details for smaller windows
#+begin_src emacs-lisp :tangle yes
  (require 'dired-details)
  (dired-details-install)
#+end_src

** Using the nicer bookmark+
#+begin_src emacs-lisp :tangle yes
   (require 'bookmark+)
#+end_src

** Desktop mode
#+begin_src emacs-lisp :tangle yes
  (require 'desktop)
   
  (desktop-save-mode 1)
  ;; save always
  (setq desktop-save t)
  (defun print-desktop ()
    (interactive)
    (message "current desktop is %s" desktop-dirname))
  
  (setq history-length 250)
  (add-to-list 'desktop-globals-to-save 'file-name-history)
  
  ;; name and mode of buffers to forget
  (setq desktop-buffers-not-to-save
        (concat "\\("
                "^nn\\.a[0-9]+\\|\\.log\\|(ftp)\\|^tags\\|^TAGS"
                "\\|\\.emacs.*\\|\\.diary\\|\\.newsrc-dribble\\|\\.bbdb"
                "\\)$"))
  
  (defun dired-git-current ()
    (dired-git-files  desktop-dirname))
  
  (defcustom dired-git-after-desktop
    nil
    "asking to open a dired buffer every time"
    :type 'boolean)
  
  ;; first we have to pass to the right dir
  (if dired-git-after-desktop
      (add-hook 'desktop-after-read-hook 'dired-git-current))
  
  (add-to-list 'desktop-modes-not-to-save 'dired-mode)
  (add-to-list 'desktop-modes-not-to-save 'Info-mode)
  (add-to-list 'desktop-modes-not-to-save 'info-lookup-mode)
  (add-to-list 'desktop-modes-not-to-save 'fundamental-mode)
  
  (add-hook 'auto-save-hook (lambda () (desktop-save-in-desktop-dir)))
  
  (setq desktop-clear-preserve-buffers
        (append '("\\.newsrc-dribble" "\\.org$" "eternal" "\\*shell\\*" "\\*group\\*" "\\*ielm\\*") desktop-clear-preserve-buffers))
#+end_src

** Uniquify
   Uniquify is used to distinguish easily from buffers with the same name.
#+begin_src emacs-lisp :tangle yes
  ;; Using uniquify for better handling of buffers with same name
  (require 'uniquify)
  ;; Using part of the directory in this case
  (setq uniquify-buffer-name-style 'forward)
#+end_src   

** Saveplace
   Remembers where you were in the buffer
#+begin_src emacs-lisp :tangle yes
   (require 'saveplace)
#+end_src   

** Minibuffer nice stuff
#+begin_src emacs-lisp :tangle yes
  (setq visible-bell t) ; Turn beep off
  (savehist-mode t) ; save also minibuffer history, very useful
#+end_src

** Ibuffer settings
#+begin_src emacs-lisp :tangle yes
  (setq ibuffer-saved-filter-groups
        '(("default"
           ("Chat" (or
                    (mode . garak-mode)
                    (name . "^\\*Garak\\*$")
                    (mode . rcirc-mode)))
           ("Organization" (or
                            (mode . diary-mode)
                            (mode . org-mode)
                            (mode . org-agenda-mode)))
           ("Gnus & News" (or
                           (mode . message-mode)
                           (mode . bbdb-mode)
                           (mode . mail-mode)
                           (mode . gnus-group-mode)
                           (mode . gnus-summary-mode)
                           (mode . gnus-article-mode)
                           (name . "^\\(\\.bbdb\\|dot-bbdb\\)$")
                           (name . "^\\.newsrc-dribble$")
                           (mode . newsticker-mode)))
           ("Files" (filename . ".*"))
           ("File Management" (or
                               (mode . dired-mode)
                               (mode . shell-mode)))
           ("Documentation" (or
                             (mode . Info-mode)
                             (mode . apropos-mode)
                             (mode . woman-mode)
                             (mode . help-mode)
                             (mode . Man-mode))))))
#+end_src

** Hide org-mode Files
   Only works with without ido-mode, not really useful at now
#+begin_src emacs-lisp :tangle yes
  (defun th-hide-org-buffers (arg)
    "Hide org-mode buffers from completion by prepending a space at the buffer name.
  When called with prefix arg (`C-u'), then remove this space again."
    (interactive "P")
    (dolist (b (buffer-list))
      (set-buffer b)
      (when (eq major-mode 'org-mode)
        (rename-buffer
         (if arg 
             (replace-regexp-in-string "^[[:space:]]+" "" (buffer-name))
           (concat " " (buffer-name)))))))
#+end_src

* Package management
  Auto install is a nice way to install packages from emacswiki repository.
  There are other possible ways to manage the emacs packages.
#+begin_src emacs-lisp :tangle yes
  ; Other autoloads
  (autoload 'auto-install-from-emacswiki "auto-install" "auto install from emacswiki" t)
  (setq auto-install-directory (make-conf-path "auto-install/"))
#+end_src

* Frame management
  [[http://www.emacswiki.org/emacs/Shrink-Wrapping_Frames][See shrinking frames]] and onetoone to see what it could be done to make emacs more frame-centric.

  Create some extensions to manage frames more easily, with "select-frame", "next-frame" and so on.
* Visualization
** Menu and tool-bar disabling
#+begin_src emacs-lisp :tangle yes
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (and linux window-system) (menu-bar-mode -1))
#+end_src

** Elscreen
#+begin_src emacs-lisp :tangle yes
  (require 'alist)
  (setq elscreen-path (make-conf-path "elscreen/"))
  (add-to-list 'load-path (concat elscreen-path "elscreen"))
  (add-to-list 'load-path (concat elscreen-path "elscreen-server"))
  (add-to-list 'load-path (concat elscreen-path "elscreen-color-theme"))
  (require 'elscreen)
  (require 'elscreen-color-theme)
  (require 'elscreen-server)
#+end_src

** Fullscreen mode
#+begin_src emacs-lisp :tangle yes
  (defun full (&optional f)
    (interactive)
    (if
        mac
        ;; included in emacs 23.2
        ;; FIXME: the ns version doesn't take the frame option
        (ns-toggle-fullscreen)
      (set-frame-parameter f 'fullscreen
                           (if (frame-parameter f 'fullscreen) nil 'fullboth))))
  
  ;; this toogle the fullscreen for every new frame (window) created
  ;; (add-hook 'after-make-frame-functions 'full)
#+end_src

** Winner mode
   Winner mode remember the window configuration and allows you to go back and forth
#+begin_src emacs-lisp :tangle yes
  ;; enabling winner mode for window reconfiguration
  (winner-mode t)
#+end_src

** Color theme setting
#+begin_src emacs-lisp :tangle yes
  (require 'color-theme)
  (eval-after-load "color-theme"
    '(progn
       (color-theme-initialize)))
  
  (defcustom preferred-color-theme-function
    'coal
    "preferred color theme"
    :type 'function
  )
#+end_src

** Fringe and stuff todo
   Nice but unable to update itself automatically, but only set when the file is visited first time.
#+begin_src emacs-lisp :tangle no
  (defun annotate-todo ()
    "put fringe marker on TODO: lines in the curent buffer"
    (interactive)
    (save-excursion
      ;; TODO: add also other regexps like FIXME or others
      (goto-char (point-min))
      (while (re-search-forward "TODO:" nil t)
        (let ((overlay (make-overlay (- (point) 5) (point))))
          (overlay-put overlay 'before-string (propertize "A" 'display '(left-fringe right-triangle)))))))
  
  
  (add-hook 'find-file-hook 'annotate-todo)
#+end_src
  
** Font settings
  Defininig some nice fonts and how to switch between theme.
  [[http://xahlee.org/emacs/emacs_unicode_fonts.html][Cycling function definition]]
#+begin_src emacs-lisp :tangle yes
  (setq current "monaco-12")
  (setq font-list
        (list "monaco-12" "inconsolata-14" "courier-13"))
  
  (defun cycle-font ()
    "Change font in current frame"
    (interactive)
  
    (let (fontToUse currentState)
      ;; states starts from 1.
      (setq currentState (if (get this-command 'state) (get this-command 'state) 1))
      (setq fontToUse (nth (1- currentState) font-list))
  
      (set-frame-parameter nil 'font fontToUse)
      (message "Current font is: %s" fontToUse)
      (put this-command 'state (1+ (% currentState (length font-list))))
      (redraw-frame (selected-frame))))
  
  (frame-parameter nil 'font)
#+end_src

* General useful things
** Searching info
   Look for in google
#+begin_src emacs-lisp :tangle yes
  (autoload 'google-search-selection "google_search" "google search" t)
  (autoload 'google-it "google_search" "google search" t)
#+end_src

** Kill ring stuff
   Sometimes the key ring is not easy to manage, we can browse inside it to see what we saved
#+begin_src emacs-lisp :tangle yes
   (require 'browse-kill-ring)
#+end_src

** Translations
*** Org babel
#+begin_src emacs-lisp :tangle yes
  (setq babel-preferred-from-language "German")
  (setq babel-preferred-to-language "English")
  
  (autoload 'babel-region-default "babel" "translating default" t)
  (autoload 'babel-region "babel" "translating a region" t)
  (autoload 'babel "babel" "translating interactively" t)
  (autoload 'babel-buffer "babel" "translate buffer" t)
#+end_src

*** Text translator
#+begin_src emacs-lisp :tangle yes
  (setq text-translator-display-popup t)
  (setq text-translator-default-engine "google.com_deen")
  
  (defun text-translator-region-or-thing-at-point (&optional prompt)
    (interactive)
    "If mark is active, return the region, otherwise, thing at point."
    (cond
     (mark-active
      (buffer-substring-no-properties (region-beginning) (region-end)))
     (t
      (thing-at-point 'symbol ))))
#+end_src

*** Spelling functions
# TODO: make it easier to manage and to scroll through lists of possibilities
#+begin_src emacs-lisp :tangle yes
  (setq ispell-dictionary "english")
  
  
  ;; TODO: possible to refactor this code maybe?
  (defun en ()
    "Check spelling in english"
     (interactive)
    (ispell-change-dictionary "english")
    (flyspell-mode t))
  
  (defun it ()
    "Check spelling in english"
    (interactive)
    (ispell-change-dictionary "italian")
    (flyspell-mode t))
  
  (defun fr ()
    "Check spelling in english"
    (interactive)
    (ispell-change-dictionary "french")
    (flyspell-mode t))
  
  (defun de ()
    "Check spelling in english"
    (interactive)
    (ispell-change-dictionary "german")
    (flyspell-mode t))
#+end_src

** Dictionary
   Using dictionary.el (downloaded from http://me.in-berlin.de/~myrkr/dictionary/download.html)

#+begin_src emacs-lisp :tangle yes
  ; TODO: add some thing-at-point to guess the current word
  (defun my-dictionary-search ()
    "look for a word here"
    (interactive)
    (let ((word (current-word))
          (enable-recursive-minibuffers t)
          (val))
      (setq val (read-from-minibuffer
                 (concat "Word"
                         (when word
                           (concat " (" word ")"))
                         ": ")))
      (dictionary-new-search
       (cons (cond
              ((and (equal val "") word)
               word)
              ((> (length val) 0)
               val)
              (t
               (error "No word to lookup")))
             dictionary-default-dictionary))))
#+end_src

* Org mode
** Setting up what happens when closing a task
#+begin_src emacs-lisp :tangle yes
(setq org-log-done 'note)
#+end_src

** General TODO keywords
#+begin_src emacs-lisp :tangle yes
  (setq org-todo-keywords
        '((sequence "TODO(t)" "FEEDBACK(f)" "VERIFY(v)" "|" "DONE(d)" "DELEGATED(D)" "REJECTED(r)")))
#+end_src

** Enforcing TODO dependencies
#+begin_src emacs-lisp :tangle yes
   (setq org-enforce-todo-dependencies t)
   (setq org-enforce-todo-checkbox-dependencies t)
#+end_src

** Use ido for switching
#+begin_src emacs-lisp :tangle yes
   (setq org-completion-use-ido t)
#+end_src
   
** Info configuration
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'Info-default-directory-list "org-mode/share/info/")
#+end_src

** Clock configuration
#+begin_src emacs-lisp :tangle yes
  ;; Clock configuration
  (setq org-clock-persist t)
  (org-clock-persistence-insinuate)
#+end_src

** Add eventually
   This hook enables to expand your KB very easily, every time you create a new org-file it will check if it's already in the agenda and asks to add it.
   Disable this if you don't plan to use org mode and its agenda
#+begin_src emacs-lisp :tangle yes
  (defun org-add-eventually()
    "Adding a file to org-agenda when saved"
    (interactive)
    (if
        (org-agenda-is-filtered-p (buffer-file-name))
        (message "filtered out in org-agenda-filter-out, change it to include it again")
      (if 
           (and
            (string= major-mode "org-mode")
            ; TODO: check this condition
            (or (org-agenda-filter-remote-files) (file-remote-p buffer-file-name))
             ;TODO: there should be a function already in org-mode 
            (not (member (abbreviate-file-name buffer-file-name) org-agenda-files)))
           (if
               (yes-or-no-p "add the file to agenda?")
               (org-agenda-file-to-front)))))
  
  
  (defcustom org-agenda-add-eventually-enabled
    nil
    "add interactively enabled or not"
    :type 'boolean)
  
  (defcustom org-agenda-filter-remote-files
    t
    "filter buffers open with tramp-mode"
    :type 'boolean)
  
  (if org-agenda-add-eventually-enabled
      (add-hook 'before-save-hook 'org-add-eventually))
  
  (defcustom org-agenda-filter-out
    '("/Volumes/arch")
    "regexp that are never added to agenda"
    :type 'list)
  
  (defun org-agenda-is-filtered-p (filename)
    (org-agenda-is-filtered-p-rec filename org-agenda-filter-out))
  
  (defun org-agenda-is-filtered-p-rec (filename list)
    (cond
     ((null list) nil)
     ((string-match (car list) (expand-file-name filename)) t)
     (t (org-agenda-is-filtered-p-rec filename (cdr list)))))
#+end_src


*** Org agenda blacklist list
    Having to say "n" every time for a file that we don't want to add to the agenda can be annoying, so every time we say no we call another function.

#+begin_src emacs-lisp :tangle no
  (defun org-agenda-add-to-blacklist ()
    (setq org-agenda-blacklist
          (add-to-list 'org-agenda-blacklist (abbreviate-file-name buffer-file-name)))
    (customize-save-variable org-agenda-blacklist org-agenda-blacklist))
#+end_src

** Remember mode
   Org mode can be used in conjunction with remember mode to keep track of repetitive things to remember.

*** Setting up
#+begin_src emacs-lisp :tangle yes
(require 'remember)
(require 'org-remember)
(org-remember-insinuate)
#+end_src

*** Define templates
#+begin_src emacs-lisp :tangle yes
  (setq org-remember-templates
        '(
          ("Note" ?n "* " "~/Documents/pycon/notes.org")))
          ;; ("Note" ?n "* " "~/org/notes.org")
          ;; ("Homeworks" ?h "* TODO %^{homework|german|functional|database|scientific|graphics} \n DEADLINE: %^T" "~/org/homeworks.org")
          ;; ("TOBUY" ?b "* TODO %^{what you want}\n %t" "~/org/tobuy.org")))
#+end_src

** Notes
#+begin_src emacs-lisp :tangle yes
  ;; Defining a setup where org-mode takes care of remember notes
  (setq org-directory "~/org/")
  (setq org-default-notes-file (concat org-directory "notes.org"))
#+end_src

** Org functionalities in other modes
#+begin_src emacs-lisp :tangle yes
  (setq org-struct-hooks
        '(message-mode-hook
          mail-mode-hook))
  
  (dolist (hook org-struct-hooks)
    (add-hook hook 'turn-on-orgstruct)
    (add-hook hook 'turn-on-orgtbl))
#+end_src

** Setting org-foonote for other things also
#+begin_src emacs-lisp :tangle yes
   (setq org-footnote-tag-for-non-org-mode-files "*-*-*-*-*-*-*-*-*-*")
#+end_src
* [[http://code.google.com/p/yasnippet/][Yasnippet]]  
#+begin_src emacs-lisp :tangle yes
  (require 'yasnippet)
  
  (setq yas/root-directory
        (mapcar 'make-conf-path
                '("my-snippets/" "yasnippet/snippets/")))
  
  ;; Maybe needed to set to fixed for some modes
  (setq yas/indent-line 'auto)
  
  (yas/initialize)
  
  (setq yas/ignore-filenames-as-triggers nil)
  
  (mapc 'yas/load-directory yas/root-directory)
  
  ;; don't make backups in the snippet folder, they mess up yasnippet
  (add-to-list 'backup-directory-alist '("/my-snippets/" . "/tmp/"))
  
  ;; simple function to create a .yas-parents
  (defun make-yas-parents-file (path)
    (interactive "DPath: ")
    (find-file (concat path ".yas-parents"))
    (insert "text-mode"))

  (defun with-comment (str)
   (format "%s%s%s" comment-start str comment-end))
#+end_src
* Eldoc mode
  Show the documentation of some functions directly in the minibuffer.
#+begin_src emacs-lisp :tangle yes
  (require 'eldoc)
  ;; Maybe better a direct activation??
  (dolist (hook '(python-mode-hook
                  c-mode-hook
                  ruby-mode-hook
                  lisp-interaction-mode-hook
                  ielm-mode-hook
                  emacs-lisp-mode-hook))
    (add-hook hook 'turn-on-eldoc-mode))
#+end_src

* Auto complete
** Importing all packages
# TODO: add the semantic auto-completion to all modes which use it
   
#+begin_src emacs-lisp :tangle yes
  ;;; Require
  (require 'auto-complete)
  ;; Various configurations
  (require 'auto-complete-config)
  (ac-config-default)
#+end_src  

** Setting up
#+begin_src emacs-lisp :tangle yes
  (setq ac-auto-start 2)                  ;automatically start
  (setq ac-override-local-map nil)        ;don't override local map
  (setq ac-use-menu-map t)
  (setq ac-candidate-limit 20)
  ;; Default settings
  (define-key ac-menu-map "\C-n" 'ac-next)
  (define-key ac-menu-map "\C-p" 'ac-previous)  
  
  ;; making it a bit faster
  (setq ac-delay 5)
  (setq ac-auto-show-menu 0.4)
  (setq ac-quick-help-delay 0.5)
  ;; using a dictionary (emtpy now)
  (add-to-list 'ac-dictionary-directories (make-conf-path "auto-complete/dict"))
#+end_src

** Setting up generic sources
#+begin_src emacs-lisp :tangle yes
  (setq-default ac-sources
                (append ac-sources '(ac-source-yasnippet)))
#+end_src 

** Define allowed modes
#+begin_src emacs-lisp :tangle yes
  (dolist
      (my-ac-mode '(nesc-mode org-mode html-mode xml-mode haskell-mode))
    (add-to-list 'ac-modes my-ac-mode))
  
              
  ; this is used for trigger ac actions from org-mode also
  (add-to-list 'ac-trigger-commands 'org-self-insert-command)
#+end_src

** Elisp configuration
#+begin_src emacs-lisp :tangle yes
;; using a nice function is ac-config
(dolist (hook (list
               'lisp-interaction-mode-hook
               'ielm-mode-hook
               ))
  (add-hook hook 'ac-emacs-lisp-mode-setup))
#+end_src

** Using eclim
#+begin_src emacs-lisp :tangle yes
  (add-hook 'java-mode-hook 
            '(lambda ()
               (add-to-list 'ac-sources 'eclim-complete)))
#+end_src   
* Predictive modes
#+begin_src emacs-lisp :tangle yes
  (autoload 'predictive-mode "predictive" "predictive" t)
  (set-default 'predictive-auto-add-to-dict t)
  (setq predictive-main-dict 'dict-english
        predictive-auto-learn t
        predictive-add-to-dict-ask nil
        predictive-use-auto-learn-cache nil
        predictive-which-dict t)
#+end_src
   
* Programmer tools
** Cedet
   See [[http://alexott.net/en/writings/emacs-devenv/EmacsCedet.html][gentle introduction to cedet]] for a nicer tutorial

*** Use cedet and gloabally ede-mode for projects
#+begin_src emacs-lisp :tangle yes
  (load (make-conf-path "cedet/common/cedet"))
  (setq semantic-load-turn-everything-on t)
#+end_src

*** Options for semantic
#+begin_src emacs-lisp :tangle yes
  (global-semantic-stickyfunc-mode 1)
  ;; (global-semantic-decoration-mode 1)
  (global-semantic-highlight-func-mode 1)
  (global-semantic-highlight-edits-mode 1)
  (global-semantic-idle-scheduler-mode 1)
  (global-semantic-idle-summary-mode 1)
  (global-semantic-mru-bookmark-mode 1)
  ;; enable working on nesc-code, a superset of C, add another language to semantic instead
  ;; (add-to-list 'semantic-new-buffer-setup-functions
  ;;              '(nesc-mode . semantic-default-c-setup))
#+end_src

*** Hook for inline documentation setting local keys
#+begin_src emacs-lisp :tangle yes
  (defun my-c-like-cedet-hook ()
    (local-set-key [(control return)] 'semantic-ia-complete-symbol)
    (local-set-key "\C-c?" 'semantic-ia-complete-symbol-menu)
    (local-set-key "\C-c>" 'semantic-complete-analyze-inline)
    (local-set-key "\C-cj" 'semantic-ia-fast-jump)
    (local-set-key "\C-cq" 'semantic-ia-show-doc)
    (local-set-key "\C-cs" 'semantic-ia-show-summary)
    (local-set-key "\C-cp" 'semantic-analyze-proto-impl-toggle))
  
  ;; (defun my-c-only-cedet-hook ()
  ;;   (local-set-key "." 'semantic-complete-self-insert)
  ;;   (local-set-key ">" 'semantic-complete-self-insert))
#+end_src

*** Using semanticdb
#+begin_src emacs-lisp :tangle yes
  (global-semanticdb-minor-mode)
  ;; (semanticdb-enable-gnu-global-databases 'c-mode)
  ;; (semanticdb-enable-gnu-global-databases 'java-mode)
  ;; (semanticdb-enable-gnu-global-databases 'jde-mode)
  ;; (semanticdb-enable-gnu-global-databases 'python-mode)
#+end_src
** Eclim
  Get the power of eclipse right in emacs via [[http://eclim.org/][eclim]]

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'load-path (make-conf-path "emacs-eclim/"))
  ;; only add the vendor path when you want to use the libraries provided with emacs-eclim
  (add-to-list 'load-path (make-conf-path "emacs-eclim/vendor"))
  ;; use it a hook instead with the java mode
  
  ;; TODO: maybe worth using on other modes also
  (add-hook 'java-mode-hook
            '(lambda ()
               (require 'eclim)
  
               (setq eclim-auto-save t)
               (eclim-mode 1)))
#+end_src
** Tags
*** Etags-select
   This extension to etags helps choosing from equal names of functions.
#+begin_src emacs-lisp :tangle yes
  (require 'etags-select)
#+end_src

*** Etags table to use also in bigger projects
#+begin_src emacs-lisp :tangle yes
   (require 'etags-table)
   (setq etags-table-search-up-depth 1)
#+end_src

*** Extending functions
   This functions help to look for the TAGS file in the filesystem when is not in the same working directory
# FIXME: still not working correctly, more iteration is needed here
#+begin_src emacs-lisp :tangle no
  (defun jds-find-tags-file ()
    "recursively searches each parent directory for a file named 'TAGS' and returns the
  path to that file or nil if a tags file is not found. Returns nil if the buffer is
  not visiting a file"
    (progn
      (defun find-tags-file-r (path)
        "find the tags file from the parent directories"
        (let* ((parent (file-name-directory path))
               (possible-tags-file (concat parent "TAGS")))
          (cond
           ((file-exists-p possible-tags-file) (throw 'found-it possible-tags-file))
           ((string= "/TAGS" possible-tags-file) (error "no tags file found"))
           (t (find-tags-file-r (directory-file-name parent))))))
  
      (if (buffer-file-name)
          (catch 'found-it 
            (find-tags-file-r (buffer-file-name)))
        (error "buffer is not visiting a file"))))
  
  (defun jds-set-tags-file-path ()
    "calls `jds-find-tags-file' to recursively search up the directory tree to find
  a file named 'TAGS'. If found, set 'tags-table-list' with that path as an argument
  otherwise raises an error."
    (interactive)
    (setq tags-table-list (list (jds-find-tags-file))))
  
  ;; delay search the TAGS file after open the source file
  (add-hook 'emacs-startup-hook 
            '(lambda () (jds-set-tags-file-path)))
#+end_src

* Programming
** Internationalization
   Editing po files
#+begin_src emacs-lisp :tangle yes
  (autoload 'po-mode "po-mode+"
    "Major mode for translators to edit PO files" t)
  
  (add-to-list 'auto-mode-alist
               '("\\.po$" . po-mode))
  
  (add-to-list 'auto-mode-alist
               '("\\.pot$" . po-mode))
  
  
  ;; to automatically find out the coding system
  (modify-coding-system-alist 'file "\\.po\\'\\|\\.po\\."
                              'po-find-file-coding-system)
  (autoload 'po-find-file-coding-system "po-mode")
#+end_src

** To spell mode
   Most of the programming languages we can have syntax checking on the comments and strings.
   Flyspell-prog-mode is just for this
#+begin_src emacs-lisp :tangle yes
  (defcustom to-spell-langs
    '(emacs-lisp-mode-hook python-mode-hook c-mode-hook nesc-mode-hook java-mode-hook jde-mode-hook haskell-mode-hook)
    "Set of programming modes for which I want to enable spelling in comments and strings"
    :type 'list)
    
  ;; (setq to-spell-langs
  
  (dolist (lang-hook to-spell-langs)
    (add-hook  lang-hook 'flyspell-prog-mode))
  
  (require 'auto-complete)
  (ac-flyspell-workaround)
#+end_src

** Web nice utilities
*** Gist
    Use simply *gist-buffer* or *gist-region* to paste code online.
#+begin_src emacs-lisp :tangle yes
    (require 'gist)
#+end_src
    
** Clojure
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.clj$" . clojure-mode))
  (autoload 'clojure-mode "clojure-mode" "clojure mode" t)
#+end_src

*** Swank configuration for clojure
    We can keep the common lisp also
#+begin_src emacs-lisp :tangle yes
  (autoload 'slime "swank-clojure" "loading the swank-clojure" t)
  (add-hook 'slime-mode-hook
            '(lambda () 
               (add-to-list 'slime-lisp-implementations '(sbcl ("sbcl")))))
#+end_src
  Use "C-u M-x slime sbcl RET" to start sbcl again

** Ess
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'load-path (make-conf-path "ess/lisp"))
  (autoload 'R "ess-site" "loading R env" t)
#+end_src

** C-mode
*** Using splint
#+begin_src emacs-lisp :tangle yes
  ; FIXME: not working as expected yet
  (defun do-splint ()
    (interactive)
    (shell-command (format "splint %s" buffer-file-name)))
#+end_src

*** Eldoc and style settings
#+begin_src emacs-lisp :tangle yes
  (require 'c-eldoc)
  ; TODO: maybe we can as well modify it more simply in the default structure
  (setq c-default-style
        '((java-mode . "java")
         (awk-mode . "awk")
         (other . "cc-mode")))
  
  ;; FIXME: eldoc mode, not working correctly apparently
  ;; See http://www.emacswiki.org/emacs/CEldocMode for more info
  (add-hook 'c-mode-hook 'c-turn-on-eldoc-mode)
  ;; adding the hook from cedet
  (add-hook 'c-mode-common-hook 'my-c-like-cedet-hook)
#+end_src

** Insert headers automatically given the right extension
#+begin_src emacs-lisp :tangle yes
  (defun is-new-file ()
   "Check if it's a new file"
   (not (file-exists-p buffer-file-name)))
  
  (defun my-insert-header ()
    "try to insert the header smartly"
    (when
        (is-new-file)
        (let
            ((snip (assoc (file-name-extension buffer-file-name) my-auto-header-conses)))
          (if
              snip
              (insert-at-startup (cdr snip))))))
  
  (defun insert-at-startup (snippet)
    "try to expand a snippet at startup"
    (if
        (yes-or-no-p "insert automatic header?")
        (progn
          (insert snippet)
          ;; add checking
          (yas/expand))))
    
  (defcustom my-auto-header-conses
        '(("py" . "!")
          ("rb" . "!")
          ("h"  . "once"))
        "snippets to expand per file extension"
        :type 'list)
  
  (add-hook 'find-file-hook 'my-insert-header)
#+end_src

** Python mode
*** Paths and extensions

#+begin_src emacs-lisp :tangle yes
  ;; TODO: check why is not working with the autoload
  (load-library "python-mode")
  (add-to-list 'auto-mode-alist '("\\.py$" . python-mode))
  (add-to-list 'interpreter-mode-alist '("python" . python-mode))
  (autoload 'doctest-mode "doctest-mode" "doc test python mode" t)
#+end_src

** Haskell mode
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.hs$" . haskell-mode))
  (autoload 'haskell-mode "haskell-mode" "haskell mode" t)
  (autoload 'turn-on-haskell-doc-mode "haskell-doc" "haskell doc mode" t)
  (autoload 'turn-on-haskell-indent "haskell-indent" "haskell indent facilities" t)
  
  (autoload 'inf-haskell "inf-haskell" "inf-haskell" t)
  (autoload 'hs-lint "hs-lint" "haskell checker" t)
  
  ;; here some haskell variables
  (setq haskell-doc-show-global-types t)
  (setq haskell-program-name "ghci")
                                          ; where haskell-hoogle is loaded?
  
  ;; enabled to get indentation over if-then-else
  (setq haskell-indent-thenelse 1)
  
  ;; If nothing found pass the control
  (add-hook 'haskell-mode-hook
            '(lambda ()
               (require 'haskell-doc) ; Is this the only way?
               (require 'haskell-indent)
               (require 'haskell-complete)
               (require 'inf-haskell)
               (turn-on-haskell-doc-mode)
               (turn-on-haskell-indentation)
               ;; This would be very nice but it conflicts with yasnippet
               (define-key haskell-mode-map [tab] 'haskell-indent-cycle)
               (define-key haskell-mode-map "\C-ch" 'haskell-hoogle)
               (define-key haskell-mode-map "\C-cl" 'hs-lint)
               (make-variable-buffer-local 'yas/trigger-key)
               (setq yas/trigger-key [tab])
               (define-key yas/keymap [tab] 'yas/next-field)
               (add-to-list 'ac-sources 'my/ac-source-haskell)
               ))
#+end_src

** Prolog
#+begin_src emacs-lisp :tangle yes
  (autoload 'run-prolog "prolog" "Start a Prolog sub-process." t)
  (autoload 'prolog-mode "prolog" "Major mode for editing Prolog programs." t)
  (autoload 'mercury-mode "prolog" "Major mode for editing Mercury programs." t)
  (setq prolog-system 'swi)
  (add-to-list 'auto-mode-alist '("\\.pl$" . prolog-mode))
#+end_src
  
** Nesc
#+begin_src emacs-lisp :tangle yes
  (autoload 'nesc-mode "nesc" nil t)
  (add-to-list 'auto-mode-alist '("\\.nc$" . nesc-mode))
#+end_src

** Ned mode (for omnet++)
#+begin_src emacs-lisp :tangle yes
   (autoload 'ned-mode "ned-mode" "Major Mode for editing Ned files" t)
   (add-to-list 'auto-mode-alist '("\\.ned$" . ned-mode))
#+end_src   

** Java
*** Jdee settings
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'load-path (make-conf-path "jdee/lisp"))
  
  (autoload 'jde-mode "jde" "jde mode" t)
  
  ;; In this way we only load if really necessary
  (add-hook 'jde-mode-hook
            '(lambda ()
               (require 'ecb)
               (setq indent-tabs-mode nil)))
  
  ;; (defun turn-on-font-lock-if-enabled ()
  ;;   "set up to make jdee shut up")
  
  ;; TODO: put some conditional stuff for the different operating systems
  ;; make it more general usage
  (setq jde-jdk-registry
        '(("1.6" . "/System/Library/Frameworks/JavaVM.framework/Versions/1.6/")
          ("1.5" . "/System/Library/Frameworks/JavaVM.framework/Versions/1.5/")
          ("1.3.1" . "/System/Library/Frameworks/JavaVM.framework/Versions/1.3.1/")))
  
  (setq jde-jdk '("1.6" . "/System/Library/Frameworks/JavaVM.framework/Versions/1.6/"))
  
  (setq bsh-jar "/opt/local/share/java/bsh.jar")
#+end_src

** Changelog settings and time
#+begin_src emacs-lisp :tangle yes
  ;; for changelogs
  (setq add-log-always-start-new-record 1)
  (add-hook 'before-save-hook 'time-stamp)
  (setq time-stamp-format "%02d-%02m-%:y, %02H:%02M")
#+end_src

** Doc
*** Doxygen files
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("Doxyfile" . conf-unix-mode))
#+end_src

*** Doxymacs
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'load-path (make-conf-path "doxymacs/lisp"))
  (add-hook 'c-mode-hook '(lambda () (require 'doxymacs)))
#+end_src

** Applescript mode
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist
               '("\\.applescript$" . applescript-mode))
  (autoload 'applescript-mode "applescript-mode" "mode for applescript files" t)
#+end_src
   
** Lisp
#+begin_src emacs-lisp :tangle yes
   (setq inferior-lisp-program "sbcl")
   (require 'slime)
   (slime-setup)
#+end_src

** Web programming
  Enabling nxhtml mode
#+begin_src emacs-lisp :tangle yes
  (setq nxhtml-menu-mode nil)
#+end_src

#+begin_src emacs-lisp :tangle yes
  (autoload 'mako-html-mumamo-mode "autostart" "auto starting of nxhtml" t)
  ;; add other modes whenever needed
  (add-to-list 'auto-mode-alist '("\\.mak$" . mako-html-mumamo-mode))
  (add-to-list 'auto-mode-alist '("\\.mako$" . mako-html-mumamo-mode))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (setq mumamo-chunk-coloring 3)
#+end_src

** Ocaml
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.ml\\w?" . tuareg-mode))
  (autoload 'tuareg-mode "tuareg" "Major mode for editing Caml code" t)
  (autoload 'camldebug "camldebug" "Run the Caml debugger" t)
#+end_src
   
** Lua
#+begin_src emacs-lisp :tangle yes
  ;; lua mode
  (autoload 'lua-mode "lua-mode" "mode for lua" t)
#+end_src

** Fixme mode
   This is a mode to highlight stuff, adding some more modes
#+begin_src emacs-lisp :tangle yes
  ; TODO: add it globally if possible
  (require 'fixme-mode)
  ; for each of the modes we add it to the hook
  (add-to-list 'fixme-modes 'org-mode)
  (dolist (hook '(python-mode-hook
                  c-mode-hook
                  ruby-mode-hook
                  lisp-interaction-mode-hook
                  org-mode-hook
                  haskell-mode-hook
                  emacs-lisp-mode-hook))
    (add-hook hook 'fixme-mode))
#+end_src 

** Ruby mode
*** General settings
#+begin_src emacs-lisp :tangle yes
  (autoload 'ruby-mode "ruby-mode" "Major mode for ruby files" t)
  (add-to-list 'auto-mode-alist '("\\.rb$" . ruby-mode))
  (add-to-list 'interpreter-mode-alist '("ruby" . ruby-mode))
  
  (add-hook 'ruby-mode-hook
            '(lambda ()
               (require 'inf-ruby)
               (require 'ruby-electric)
               (require 'rubydb)
               (load-library "rdoc-mode")))
#+end_src

*** Jruby and rinari
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'load-path (make-conf-path "rinari/util"))
#+end_src

** Yaml
#+begin_src emacs-lisp :tangle yes
  (autoload 'yaml-mode "yaml-mode" "mode for yaml" t)
  (add-to-list 'auto-mode-alist
               '("\\.yaml$" . yaml-mode))
  (add-to-list 'auto-mode-alist
               '("\\.yml$" . yaml-mode))
#+end_src

** Go mode
#+begin_src emacs-lisp :tangle yes
  (autoload 'go-mode "go-mode" "go mode" t)
  (add-to-list 'auto-mode-alist
               '("\\.go$" . go-mode))
#+end_src

** [[http://code.djangoproject.com/wiki/Emacs][Django modes]]
   This mode is derived from html and helps writing django templates
#+begin_src emacs-lisp :tangle yes
  (autoload 'django-html-mode "django-html-mode" "mode for django templates" t)
  (add-to-list 'auto-mode-alist
               '("views" . django-html-mode))
#+end_src

** Debugging
*** Setting up GDB to always open right windows
#+begin_src emacs-lisp :tangle yes
   (setq gdb-show-main nil)
   (setq gdb-many-windows t)

#+end_src 

*** Some advices for pdb
#+begin_src emacs-lisp :tangle yes
  (defadvice pdb (before gud-query-cmdline activate)
    "Provide a better default command line when called interactively."
    (interactive
     (list (gud-query-cmdline 'pdb.py
                              (file-name-nondirectory buffer-file-name)))))
#+end_src
* Other modes
** Ledger, accounting mode
#+begin_src emacs-lisp :tangle yes
  (autoload 'ledger-mode "ledger" "ledger mode for accounting" t)
#+end_src

** Finding more conf files
#+begin_src emacs-lisp :tangle yes
;  (add-to-list 'auto-mode-alist '("conf" . conf-mode))
;  (add-to-list 'auto-mode-alist '(".*?rc$" . conf-mode))
#+end_src
* Security
#+begin_src emacs-lisp :tangle yes
  (require 'epa)
  (epa-file-enable)
#+end_src

* Latex
** Configuring Auctex
   Auctex is much more powerful than the default latex mode, enabling it using pdf as default mode
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'load-path (make-conf-path "auctex"))
  (autoload 'latex-mode "auctex" "latex mode" t)
  (autoload 'preview-latex "preview-latex" "preview latex in buffer" t)
  
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq LaTeX-command "latex")
  (setq TeX-PDF-mode t)
  (setq TeX-master nil)
  
  ;; using flyspell also here
  (add-hook 'latex-mode-hook 'turn-on-flyspell)
#+end_src

** Accessing to latex symbols
#+begin_src emacs-lisp :tangle yes
  (setq latex-symbols-file
        (expand-file-name "~/howto_guide/languages/latex/symbols-a4.pdf"))
  
  (defvar latex-command-program
    (cond
     (mac "open")
     (linux "evince"))
    "latex program to execute for viewing pdf")
  
  (defun latex-symbols ()
    "open the latex symbols file"
    (interactive)
    (if (file-exists-p latex-symbols-file)
        (shell-command (concat latex-command-program " " latex-symbols-file))
      (message "file not found")))
#+end_src
* Communication
** Mail settings
*** General settings for message creation

#+begin_src emacs-lisp :tangle yes
  ;; setting where the mail is coming from
  (setq mail-setup-with-from t)
  
  ;; This is just to enable flyspell in mail-mode
  ;; FIXME: check if this dirty hack is still needed
  (defvar message-signature-separator "^-- *$" "\
      Regexp matching the signature separator.")
#+end_src

*** Setting up gmail smtp server
   Make sure you configure correctly your .authinfo for login and password

#+begin_src emacs-lisp :tangle yes
  (setq send-mail-function 'smtpmail-send-it
        message-send-mail-function 'smtpmail-send-it
        smtpmail-starttls-credentials
        '(("smtp.gmail.com" 587 nil nil))
        smtpmail-auth-credentials
        (expand-file-name "~/.authinfo")
        smtpmail-default-smtp-server "smtp.gmail.com"
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587
        ;; This can be commented out for a less verbose output
        smtpmail-debug-info t)
  
  (require 'smtpmail)
#+end_src

*** Setting up completion over the addresses with the Mac address book
#+begin_src emacs-lisp :tangle yes
  (if mac
      (progn
        (require 'external-abook)
         (setq external-abook-command "contacts -lf '%%e\t%%n' %s")
         ;; TODO: check if it's dynamic enough
         (eval-after-load "message"
           '(progn 
              (add-hook 'mail-mode-hook
                           '(lambda ()
                              (define-key message-mode-map "\C-c\t" 'external-abook-try-expand)))))))
#+end_src

*** Setting default sending modality
#+begin_src emacs-lisp :tangle yes
  (setq mail-user-agent 'sendmail-user-agent)
#+end_src

*** Using msmtp to change the smtp used
#+begin_src emacs-lisp :tangle no
  (defvar msmtp-executable "/opt/local/bin/msmtp")
  
  (defun msmtp-account (&optional def)
    (let* ((from
            (save-restriction    
              (message-narrow-to-headers)
              (message-fetch-field "From")))
           (account (if from (catch 'match
                               (dolist (element msmtp-name-list)
                                 ;; (message (format "smpt chosen is %s"
                                 element))
                      (when (string-match (format ".*%s.*"
                                                  element) from)
                        (throw 'match element)))) nil)))
  (if account account (if def def "default"))))
  
  (defun msmtp-change-smtp ()
    
    (setq sendmail-program msmtp-executable)
    (setq message-sendmail-envelope-from 'header)
    
    (if (message-mail-p)
        (setq message-sendmail-extra-arguments (list "-a" (msmtp-account
                                                           "default")))))
  
  (add-hook 'message-send-hook 'msmtp-change-smtp)
#+end_src

** Gnus settings
*** Server settings
#+begin_src emacs-lisp :tangle yes
  (setq gnus-select-method '(nntp "news.gmane.org"))
  ;; Set also comp.* hierarchy
  (setq gnus-secondary-select-methods
        '(
          ;; Configuration for http://www.eternal-september.org/
          (nntp "eternal"
                (nntp-authinfo-file "~/.authinfo")
                (nntp-address "news.eternal-september.org")
                (nntp-port-number 119))))
#+end_src

   Configuring maildir testing
#+begin_src emacs-lisp :tangle yes
  (setq gmail-maildir "~/mail_clones/andrea_gmail/")
  
  (add-to-list 'gnus-secondary-select-methods
               '(nnmaildir "mymailbox" (directory gmail-maildir)))
  
  (add-to-list 'mail-sources
               '(maildir :path gmail-maildir :subdirs ("cur" "new")))
#+end_src

*** Old messages settings
#+begin_src emacs-lisp :tangle yes
  (setq gnus-large-newsgroup 500)
  (setq gnus-fetch-old-headers nil)
#+end_src

*** Appearance
#+begin_src emacs-lisp :tangle yes
  ;; Changing modeline to include also the date of the message
  (setq gnus-summary-line-format "%U%R%z%I%(%[%4L: %-23,23f%]%) %s--%d\n")
#+end_src

*** Avoid the annoying saving of the .news file
#+begin_src emacs-lisp :tangle yes
  (add-hook 'gnus-started-hook
            (lambda ()
              (when (buffer-live-p gnus-dribble-buffer)
                (with-current-buffer gnus-dribble-buffer
                  (setq buffer-save-without-query t)))))
#+end_src
** Erc
#+begin_src emacs-lisp :tangle yes
  ;; This is an example of how to make a new command.  Type "/uptime" to
  ;; use it.
  (defun erc-cmd-UPTIME (&rest ignore)
    "Display the uptime of the system, as well as some load-related
       stuff, to the current ERC buffer."
    (let ((uname-output
           (replace-regexp-in-string
            ", load average: " "] {Load average} ["
            ;; Collapse spaces, remove
            (replace-regexp-in-string
             " +" " "
             ;; Remove beginning and trailing whitespace
             (replace-regexp-in-string
              "^ +\\|[ \n]+$" ""
              (shell-command-to-string "uptime"))))))
      (erc-send-message
       (concat "{Uptime} [" uname-output "]"))))
  
  ; TODO: create a new one if necessary or just
  ; activate the current one if possible
  (defun bitlbee ()
    "connect to bitlbee"
    (interactive)
    (select-frame (make-frame))
    (erc :server "localhost" :port "6667" :nick "andrea"))
  
  (defun freenode ()
    "connect to freenode channel"
    (interactive)
    (erc :server "irc.freenode.net" :port "6667" :nick "andrea_crotti"))
  
  ;; Join the #emacs and #erc channels whenever connecting to Freenode.
  (setq erc-autojoin-channels-alist
        '(("freenode.net"
           "#emacs" "#erc" "#ruby-lang" "#python" "#ledger")))
  
  ;; Interpret mIRC-style color commands in IRC chats
  (setq erc-interpret-mirc-color t)
#+end_src

* Revision control systems
** [[http://zagadka.vm.bytemark.co.uk/magit/][Magit]]
   Nice interface for git.
#+begin_src emacs-lisp :tangle yes
  ; TODO: use autoload instead
  (require 'magit)
#+end_src

** Function to enable revert mode when in a git repository
   It's nice to enable auto-revert-mode automatically on files which are surely in a git repository.
   To do this we can simply add a hook to find-file-hook
#+begin_src emacs-lisp :tangle yes
  (defun is-git-file ()
    "Return nil unless the file is in the git files"
    (if
        (member (file-name-nondirectory buffer-file-name)
                (split-string  (shell-command-to-string "git ls-files")))
        (auto-revert-mode t)))
  
  (add-hook 'find-file-hook 'is-git-file)
#+end_src

* General settings
** Mode for startup
#+begin_src emacs-lisp :tangle yes
  (setq initial-major-mode 'emacs-lisp-mode)
#+end_src

** Showing more things
#+begin_src emacs-lisp :tangle yes
  (display-time-mode 1)
  (transient-mark-mode 1)
  (setq inhibit-startup-message t)
  (setq initial-scratch-message nil)
  
  (show-paren-mode t)
  (column-number-mode t)
  ;; always truncate lines (useful for netbook), not working yet in ORG MODE
  (setq truncate-lines nil)
  ;; Setting indent-tabs-mode for only spaces
  (setq-default indent-tabs-mode nil)
#+end_src

** IDO mode
#+begin_src emacs-lisp :tangle yes
  (require 'ido)
  (ido-mode t)
  ;; otherwise it will try to connect to old servers all the time
  (setq ido-enable-tramp-completion t)
  (setq ido-enable-flex-matching t)
  ;; regexp matching also
  (setq ido-enable-regexp nil)
  (setq ido-use-url-at-point t)
  (setq ido-create-new-buffer 'always)
  (setq ido-use-filename-at-point 'guess)
  (ido-everywhere t)
  (add-to-list 'ido-ignore-buffers "\\.org\\'")
  ; miniconf.org should be always visible
  (add-to-list 'ido-ignore-buffers "^miniconf")

  ;; Using ido-mode hacks for advising more functions
  (require 'ido-hacks)
  (ido-hacks-mode t)
#+end_src

*** Use IDO when possible:
    We can advice the *completing-read* default function to use IDO when it's possible
#+begin_src emacs-lisp :tangle no
  (defvar ido-enable-replace-completing-read t
    "If t, use ido-completing-read instead of completing-read if possible.
      
      Set it to nil using let in around-advice for functions where the
      original completing-read is required.  For example, if a function
      foo absolutely must use the original completing-read, define some
      advice like this:
      
      (defadvice foo (around original-completing-read-only activate)
        (let (ido-enable-replace-completing-read) ad-do-it))")
  
  ;; Replace completing-read wherever possible, unless directed otherwise
  (defadvice completing-read
    (around use-ido-when-possible activate)
    (if (or (not ido-enable-replace-completing-read) ; Manual override disable ido
            (boundp 'ido-cur-list)) ; Avoid infinite loop from ido calling this
        ad-do-it
      (let ((allcomp (all-completions "" collection predicate)))
        (if allcomp
            (setq ad-return-value
                  (ido-completing-read prompt
                                       allcomp
                                       nil require-match initial-input hist def))
          ad-do-it))))
#+end_src

** Windmove
#+begin_src emacs-lisp :tangle yes
  (defcustom windmove-key
    'shift
    "key for moving between windows"
    :type 'symbol)
  
  (windmove-default-keybindings windmove-key)
#+end_src

** Workarounds
   Compiling on emacs 23.2 often gives some strange errors, this is to avoid them
#+begin_src emacs-lisp :tangle yes
  (setq warning-suppress-types nil)
#+end_src

* Process management
** Comint
   Make sure we don't incidentally close a process
#+begin_src emacs-lisp :tangle yes
  (defadvice comint-send-eof (around warn-me-please compile activate)
    "Confirm EOF when called interactively, because accidental EOF sucks."
    (when (or (not (member this-command '(comint-send-eof
                                          comint-delchar-or-maybe-eof)))
              (y-or-n-p "Really exit? "))
      ad-do-it))
#+end_src

* Flymake
** Setting up flymake
#+begin_src emacs-lisp :tangle yes
(require 'flymake)
   
(defun activate-flymake ()
  "Activates flymake when real buffer and you have write access"
  (if (and
       (buffer-file-name)
       (file-writable-p buffer-file-name))
      (flymake-mode t)))
#+end_src

** Adding errors to modeline
   With this the error output of othe current line will appear right below in the modeline
#+begin_src emacs-lisp :tangle yes
(defun my-flymake-show-help ()
  (when (get-char-property (point) 'flymake-overlay)
    (let ((help (get-char-property (point) 'help-echo)))
      (if help (message "%s" help)))))

(add-hook 'post-command-hook 'my-flymake-show-help)
#+end_src

** Flymake for python
   We check the errors given by 3 different programs:
   - epylint (which runs pylint and make it more parsable)
   - pyflakes
   - pep8

   The errors or warnings appear right in the source code.
   
#+begin_src emacs-lisp :tangle yes
  (defun flymake-python-init () 
    (let* ((temp-file (flymake-init-create-temp-buffer-copy 
                       'flymake-create-temp-inplace)) 
           (local-file (file-relative-name 
                        temp-file 
                        (file-name-directory buffer-file-name)))) 
      (list "pycheckers" (list local-file))))
  
  (add-to-list 'flymake-allowed-file-name-masks 
               '("\\.py\\'" flymake-python-init))
  
  ;; Using function is preferred when quoting functions
 ;; (add-hook 'python-mode-hook (function activate-flymake))
#+end_src
  
* As as server
  This will start the server for the GUI version of emacs, make sure you set up correctly the emacsclient, for example on osx. (you might even start it automatically with launchtctl)
#+begin_src sh
  alias emacsclient='/Applications/Emacs.app/Contents/MacOS/bin/emacsclient'
  # and then setup your $EDITOR to emacsclient...
#+end_src

#+begin_src emacs-lisp :tangle yes
  (if window-system
      (progn
        (require 'server)
        (if
            (not (server-running-p))
            (server-start)
          (message "server already running, check your emacser"))))
#+end_src
  
* Fun
** Fortune settings
#+begin_src emacs-lisp :tangle yes
;; TODO: make it a defcustom also 
(setq fortune-dir "/opt/local/share/games/fortune/")
#+end_src

*** Use spotlight for locating
#+begin_src emacs-lisp :tangle yes
  (defun spotlight ()
    "locate with spotlight facility"
    (interactive)
    (let ((locate-command "mdfind"))
      (call-interactively 'locate nil)))
#+end_src

*** Run applescript commands
#+begin_src emacs-lisp :tangle yes
  (defun do-applescript (str)
    "Synchronously run applescript STR."
    (with-temp-buffer
      (insert str)
      (shell-command-on-region (point-min) (point-max) "osascript" nil t)
      (buffer-string)))
#+end_src

*** Open the terminal
#+begin_src emacs-lisp :tangle yes
  (defun mac-open-terminal ()
    (interactive)
    (let ((dir ""))
      (cond
       ((and (local-variable-p 'dired-directory) dired-directory)
        (setq dir dired-directory))
       ((stringp (buffer-file-name))
        (setq dir (file-name-directory (buffer-file-name))))
       )
      (do-applescript
       (format "
  tell application \"Terminal\"
    activate
    try
      do script with command \"cd %s\"
    on error
      beep
    end try
  end tell" dir))
      ))
#+end_src

*** Growl popup
   This function can be pretty nice during presentations, it will popup the last pressed key via growl.
#+begin_src emacs-lisp :tangle yes
     (defun growl-popup (msg)
    "Pop up a growl notification with MSG, or display an Emacs message.
  The \"growlnotify\" program is used if `window-system' is non-nil and
  the program is found in `exec-path'; otherwise `message' is used."
    (interactive)
    (if (and window-system (executable-find "growlnotify"))
        (shell-command (concat "growlnotify -a /Applications/Emacs.app/ -m "
                               (shell-quote-argument msg)))
      (message msg)))
  
  (defun popup-last ()
    (interactive)
    (let
        ((last-key (key-description (this-command-keys))))
      ;; check if we don't have a "stupid" sequence
      (unless
          (= (length (this-command-keys-vector)) 1)
          (growl-popup last-key))))
#+end_src

  Now we also create two other functions to enable and disable it
#+begin_src emacs-lisp :tangle yes
  (setq growl-mode nil)
  
  (defun growl ()
    (interactive)
    (if (not growl-mode)
        (progn
          (message "enabling growl mode notification")
          (add-hook 'pre-command-hook 'popup-last)
          (setq growl-mode t))
      (progn
        (setq-default pre-command-hook (remq 'popup-last pre-command-hook))
        (message "disabling growl mode notification")
        (setq growl-mode nil))))
#+end_src

*** Open port file
#+begin_src emacs-lisp :tangle yes
  ;; Using the right mode for portfiles
  (add-to-list 'auto-mode-alist '("Portfile" . tcl-mode))
  
  ;; TODO: ask for password
  ;; Taken from http://github.com/febeling/emacsd/blob/master/init.el
  (defun port-open (name)
    "Open the portfile for named MacPorts port."
    (interactive "MPort: ")
    (let ((path (substring (shell-command-to-string (format "port file %s" name)) 0 -1)))
      (if (file-exists-p path)
          (find-file-other-window path))))
#+end_src
      
* Global keys settings
#+begin_src emacs-lisp :tangle yes
  ;; compile facilities
  (global-set-key [f5] 'recompile)
  
  ;; newline like textmate
  (global-set-key (kbd "M-RET") 'newline-force)
  (global-set-key [M-S-return] 'newline-force-close)
  
  ;; cvs stuff
  (global-set-key "\C-xg" 'magit-status)
  
  ;; org keys
  (global-set-key "\C-c\C-l" 'org-annotate-file)
  (global-set-key "\C-cr" 'org-remember)
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-c\C-x\C-o" 'org-clock-out)
  (global-set-key "\C-c\C-x\C-i" 'org-clock-in)
  
  ;; senator
  (global-set-key "\M-." 'semantic-complete-jump)
  (global-set-key "\M-?" 'semantic-ia-fast-jump)
  
  ;; overriding defualt not so smart visualization
  (global-set-key "\C-x\C-b" 'ibuffer) ;; manage buffers with ibuffer
  
  ;; visualization
  (global-set-key [f11] 'full)
  
  ;; window management keys
  (defun sensibly ()
    "split sensibly the selected window"
    (interactive)
    (split-window-sensibly (selected-window)))
  
  (global-set-key [f2] 'sensibly)
  (global-set-key [f1] 'delete-window)
  
  (global-set-key (kbd "<C-f9>") 'cycle-font)
  
  ;; elscreen nice stuff
  (global-set-key (kbd "M-<left>") 'elscreen-previous)
  (global-set-key (kbd "M-<right>") 'elscreen-next)
  
  ;; narrows to the actual function or class analyzed
  ;; C-x n w to widen again
  (global-set-key "\C-xnn" 'semantic-narrow-to-tag)
  
  (global-set-key [(meta shift l)] 'select-line)
  
  ;; TODO: the senator stuff should be enabled only where senator actually works!!
  (global-set-key [f6] 'senator-fold-tag-toggle)
  
  (global-set-key [f7] 'dired-git)
  
  (global-set-key (kbd "M-n") 'senator-next-tag)
  (global-set-key (kbd "M-p") 'senator-previous-tag)
  
  (global-set-key (kbd "M-z") 'undo)
  ;; from here
  (global-set-key "\C-x\C-p" 'find-file-at-point)
  ;; (defadvice find-file-at-point (around goto-line compile activate)
  ;;   (let ((line (and (looking-at ".*:\\([0-9]+\\)")
  ;;                    (string-to-number (match-string 1)))))
  ;;     ad-do-it
  ;;     (and line (goto-line line))))
#+end_src

* External configuration files
  Some packages use to store their configuration in external files and not in elisp code.
  For example:
  - gnus:
    + ~/.newsrc
    + ~/.newsrc-dribble (an open buffer saving actual status)
    + ~/News (all the message fetched and so on)

  - javadoc-help
    + ~/.javadoc-help (configuration about the sdks)
      
